
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Jest · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="xss.html" />
    
    
    <link rel="prev" href="test.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    进阶知识
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="structure.html">
            
                <a href="structure.html">
            
                    
                    数据结构与算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="test.html">
            
                <a href="test.html">
            
                    
                    测试
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.3" data-path="jest.html">
            
                <a href="jest.html">
            
                    
                    Jest
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="xss.html">
            
                <a href="xss.html">
            
                    
                    XSS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="electron.html">
            
                <a href="electron.html">
            
                    
                    Electron
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="performance.html">
            
                <a href="performance.html">
            
                    
                    性能优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="watch.html">
            
                <a href="watch.html">
            
                    
                    监控
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="node.html">
            
                <a href="node.html">
            
                    
                    Node
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="ab.html">
            
                <a href="ab.html">
            
                    
                    Ab 压测
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="nginx.html">
            
                <a href="nginx.html">
            
                    
                    Nginx
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="linux.html">
            
                <a href="linux.html">
            
                    
                    Linux
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="ssh.html">
            
                <a href="ssh.html">
            
                    
                    SSH
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="docker.html">
            
                <a href="docker.html">
            
                    
                    Docker
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="crontab.html">
            
                <a href="crontab.html">
            
                    
                    crontab 定时任务
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.15" data-path="vim.html">
            
                <a href="vim.html">
            
                    
                    Vim
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Jest</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="jest">Jest</h1>
<div align="center">

  <img src="advance/img/jest01.png" width="100" alt="logo" align="center"></img>
</div>

<p><a href="https://jestjs.io/" target="_blank">jest</a> 是 Facebook 的一套开源的 JavaScript 测试框架， 它自动集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具，是一款几乎零配置的测试框架。并且它对同样是 Facebook 的开源前端框架 React 的测试十分友好。</p>
<p>?&gt; 单元测试特指被测试对象为程序中最小组成单元的测试。这里的最小组成单元可以是一个函数、一个类等等。</p>
<h2 id="安装-jest">安装 Jest</h2>
<h3 id="初始化-packagejson">初始化 package.json</h3>
<p>在 commad 中输入以下命令，初始化前端项目并生成 package.json：</p>
<pre><code class="lang-bash">npm init  -y
</code></pre>
<h3 id="安装-jest-及相关依赖">安装 Jest 及相关依赖</h3>
<p>在 commad 中中输入以下命令，安装测试所需要的依赖：</p>
<pre><code class="lang-bash">cnpm  install  jest babel-jest @babel/core babel-core@^<span class="hljs-number">7.0</span>.<span class="hljs-number">0</span>-bridge.<span class="hljs-number">0</span>  @babel/preset-env --save-dev
</code></pre>
<p>babel-jest、@babel/core、 @babel/preset-env、这几个依赖是为了让我们可以使用 ES6 的语法特性进行单元测试，ES6 提供的 import 来导入模块的方式，Jest 本身是不支持的。</p>
<h3 id="添加babelrc-文件">添加.babelrc 文件</h3>
<p>在项目的根目录下添加.babelrc 文件，并在文件复制如下内容:</p>
<pre><code class="lang-json">{
  <span class="hljs-string">"presets"</span>: [<span class="hljs-string">"@babel/preset-env"</span>],
  <span class="hljs-string">"env"</span>: {
    <span class="hljs-string">"test"</span>: {
      <span class="hljs-string">"presets"</span>: [[<span class="hljs-string">"@babel/env"</span>]]
    }
  }
}
</code></pre>
<h3 id="修改-packagejson-中的-test-脚本">修改 package.json 中的 test 脚本</h3>
<p>打开 package.json 文件，将 script 下的 test 的值修改为 jest：</p>
<pre><code class="lang-json"><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">"test"</span>: <span class="hljs-string">"jest"</span>
}
</code></pre>
<h2 id="编写-jest-测试">编写 Jest 测试</h2>
<ol>
<li>创建 src 和 test 目录及相关文件</li>
<li>在项目根目录下创建 src 目录，并在 src 目录下添加 index.js 文件</li>
<li>在项目根目录下创建 test 目录，并在 test 目录下创建 index.test.js 文件</li>
<li>Jest 会自动找到项目中所有使用.spec.js 或.test.js 文件命名的测试文件并执行，通常我们在编写测试文件时遵循的命名规范：测试文件的文件名 = 被测试模块名 + .test.js，例如被测试模块为 index.js，那么对应的测试文件命名为 index.test.js。</li>
<li>在 src/index.js 中创建被测试的模块</li>
</ol>
<pre><code class="lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  sum(a, b) {
    <span class="hljs-keyword">return</span> a + b;
  }
};
</code></pre>
<p>在 test/index.test.js 文件中创建测试用例</p>
<pre><code class="lang-js"><span class="hljs-keyword">import</span> index <span class="hljs-keyword">from</span> <span class="hljs-string">'../src/index'</span>;

test(<span class="hljs-string">'sum(2 + 2) 等于 4'</span>, () =&gt; {
  expect(index.sum(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)).toBe(<span class="hljs-number">4</span>);
});
</code></pre>
<p>运行 npm run test, Jest 会在 command 中打印出以下消息：</p>
<pre><code class="lang-bash">&gt; jest

 PASS  <span class="hljs-built_in">test</span>/index.test.js
  ✓ sum(<span class="hljs-number">2</span>+<span class="hljs-number">2</span>) 等于<span class="hljs-number">4</span> (<span class="hljs-number">5</span>ms)
Test Suites: <span class="hljs-number">1</span> passed, <span class="hljs-number">1</span> total
Tests:       <span class="hljs-number">1</span> passed, <span class="hljs-number">1</span> total
Snapshots:   <span class="hljs-number">0</span> total
Time:        <span class="hljs-number">2.357</span>s
Ran all <span class="hljs-built_in">test</span> suites.
</code></pre>
<h4 id="测试-peimise">测试 peimise</h4>
<pre><code class="lang-bash"><span class="hljs-built_in">test</span>(<span class="hljs-string">'返回结果{success:true}'</span>,()=&gt;{
    <span class="hljs-built_in">return</span> except(fetchApi()).resoloves.toMatchObject({
      data:{
         success:<span class="hljs-literal">true</span>
      }
    })
})

<span class="hljs-built_in">test</span>(<span class="hljs-string">'返回结果404'</span>,()=&gt;{
    <span class="hljs-built_in">return</span> except(fetchApi()).rejects.toThorw())
})

<span class="hljs-built_in">test</span>(<span class="hljs-string">'返回结果404'</span>,()=&gt;{
    except.assertions(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">return</span> except(fetchApi()).catch((e)=&gt;{
        except(e.toString()).toEqual(<span class="hljs-string">'Error: request failed width status code 404'</span>)
    })
})

<span class="hljs-built_in">test</span>(<span class="hljs-string">'返回结果404'</span>,async()=&gt;{
    except.assertions(<span class="hljs-number">1</span>);//至少执行一次
    try{
      await fetchApi();
    }catche(e){
        except(e.toString()).toEqual(<span class="hljs-string">'Error: request failed width status code 404'</span>)
    }
})

<span class="hljs-built_in">test</span>(<span class="hljs-string">'返回结果404'</span>,async()=&gt;{
     <span class="hljs-built_in">let</span> e=await fetchApi();
     <span class="hljs-built_in">return</span> except(e.toString()).toEqual(<span class="hljs-string">'Error: request failed width status code 404'</span>)
})
</code></pre>
<h3 id="done">done</h3>
<pre><code class="lang-bash">import asyncfun from <span class="hljs-string">'./asyncfun.js'</span>;

<span class="hljs-built_in">test</span>(<span class="hljs-string">'asyncfun'</span>,()=&gt;{
    asyncfun((<span class="hljs-keyword">done</span>)=&gt;{
      except(<span class="hljs-number">2</span>).tobe(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">done</span>();
    })
})
</code></pre>
<h4 id="advancetimersbytime">advanceTimersByTime</h4>
<pre><code class="lang-bash">import asyncfun from <span class="hljs-string">'./asyncfun.js'</span>;
jest.useFakeTimes();

<span class="hljs-built_in">test</span>(<span class="hljs-string">'测试'</span>,()=&gt;{
    const func=jest.fu();
    asyncfun(func);
    jest.advanceTimersByTime(<span class="hljs-number">3000</span>);
    expect(fun).toHaveBeenCalledTimes(<span class="hljs-number">1</span>);
    jest.advanceTimersByTime(<span class="hljs-number">3000</span>);
    expect(fun).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);
})
</code></pre>
<h4 id="runonlypendingtimers">runOnlyPendingTimers</h4>
<pre><code class="lang-bash">import asyncfun from <span class="hljs-string">'./asyncfun.js'</span>;
jest.useFakeTimes();

<span class="hljs-built_in">test</span>(<span class="hljs-string">'测试'</span>,()=&gt;{
    const func=jest.fu();
    asyncfun(func);
    jest.runOnlyPendingTimers();
    expect(fun).toHaveBeenCalledTimes(<span class="hljs-number">1</span>);
})
</code></pre>
<h4 id="runcallback">runCallBack</h4>
<pre><code class="lang-bash">import asyncfun from <span class="hljs-string">'./asyncfun.js'</span>;

<span class="hljs-built_in">test</span>(<span class="hljs-string">'测试。'</span>,()=&gt;{
    const func=jest.fu();
    asyncfun(func);
    asyncfun(func);
    asyncfun(func);
    expect(fun.mock.calls.length).toBe(<span class="hljs-number">3</span>);
})
</code></pre>
<h3 id="jestconfigjs">jest.config.js</h3>
<p>新建 jest.config.js 并添加配置项 module.exports = { 配置项 }
执行 init 生成配置文件</p>
<pre><code class="lang-shell">npx jest --init
</code></pre>
<h4 id="配置项">配置项</h4>
<p>testMatch:设置识别哪些文件是测试文件（glob 形式），与 testRegex 互斥，不能同时写</p>
<pre><code class="lang-js">testMatch: [<span class="hljs-string">'**/__tests__/**/*.js?(x)'</span>, <span class="hljs-string">'**/?(*.)(spec|test).js?(x)'</span>];
</code></pre>
<p>testRegex:设置识别哪些文件是测试文件（正则形式），与 testMatch 互斥，不能同时写</p>
<pre><code class="lang-js">testRegex: <span class="hljs-string">'(/__tests__).*|(\\\\.|/)(test|spec))\\\\.jsx?$'</span>;
</code></pre>
<p>testRnviroment:测试环境，默认值是：jsdom，可修改为 node</p>
<pre><code class="lang-js">testEnvironment: <span class="hljs-string">'jsdom'</span>;
</code></pre>
<p>rootDir:默认值：当前目录，一般是 package.json 所在的目录</p>
<pre><code class="lang-js">rootDir: <span class="hljs-string">' '</span>;
</code></pre>
<p>moduleFileExtensions:测试文件的类型</p>
<pre><code class="lang-js">moduleFileExtensions: [<span class="hljs-string">'js'</span>, <span class="hljs-string">'json'</span>, <span class="hljs-string">'jsx'</span>, <span class="hljs-string">'node'</span>];
</code></pre>
<p>coverageThreshold: { //测试覆盖率, 阈值不满足，就返回测试失败</p>
<pre><code class="lang-js">    global: {
      branches: <span class="hljs-number">90</span>,
      functions: <span class="hljs-number">90</span>,
      lines: <span class="hljs-number">90</span>,
      statements: <span class="hljs-number">90</span>,
    },
</code></pre>
<blockquote>
<ul>
<li>cacheDirectory: './node_modules/.cache', //测试缓存数据的存储位置</li>
<li>setupFiles：配置文件，在运行测试案例代码之前，Jest 会先运行这里的配置文件来初始化指定的测试环境</li>
<li>testPathIgnorePatterns：用正则来匹配不用测试的文件</li>
<li>collectCoverage：是否生成测试覆盖报告，如果开启，会增加测试的时间</li>
<li>collectCoverageFrom：生成测试覆盖报告是检测的覆盖文件</li>
<li>coveragePathIgnorePatterns : 该路径下的测试，忽略在测试覆盖率上</li>
<li>moduleNameMapper：配置别名，代表需要被 Mock 的资源名称</li>
<li>transform：用 babel-jest 来编译文件，生成 ES6/7 的语法,</li>
<li>modulePaths ：测试路径</li>
<li>transformIgnorePatterns： //测试过程不改变满足配置的文件</li>
</ul>
</blockquote>
<h4 id="配置方式">配置方式</h4>
<pre><code class="lang-js"><span class="hljs-comment">// jest.config.js</span>
<span class="hljs-built_in">module</span>.exports = {
  testMatch: [<span class="hljs-string">'&lt;rootDir&gt;/test/**/*.js'</span>],
  testEnvironment: <span class="hljs-string">'jsdom'</span>,
  rootDir: <span class="hljs-string">''</span>,
  moduleFileExtensions: [<span class="hljs-string">'js'</span>, <span class="hljs-string">'json'</span>, <span class="hljs-string">'jsx'</span>, <span class="hljs-string">'node'</span>]
};
</code></pre>
<h2 id="语法">语法</h2>
<ol>
<li>分组（Test Group）：descripe(描述语,function)</li>
<li>测试用例（Test Case）：test(描述语,function)</li>
<li>测试用例（Test Case）：test.only(描述语,function) 仅仅执行当前测试用例</li>
<li>断言（Assert）：expect(运行需测试的方法并返回实际结果).toBe(预期结果)</li>
<li>.expect() :期望
expect (2 + 2) 返回一个"期望"的对象</li>
<li>.toBe(): 是匹配器</li>
<li>.not 修饰符允许你测试结果不等于某个值的情况</li>
<li>.toEqual() 匹配器会递归的检查对象所有属性和属性值是否相等，所以如果要进行应用类型的比较时，请使用.toEqual 匹配器而不是.toBe。</li>
<li>.toHaveLength 可以很方便的用来测试字符串和数组类型的长度是否满足预期。</li>
<li>.toThorw 可能够让我们测试被测试方法是否按照预期抛出异常，但是在使用时需要注意的是：我们必须使用一个函数将将被测试的函数做一个包装，正如上面 getIntArrayWrapFn 所做的那样，否则会因为函数抛出导致该断言失败。</li>
<li>.toMatch 传入一个正则表达式，它允许我们用来进行字符串类型的正则匹配。</li>
<li>assertions（1）代表的是在当前的测试中至少有一个断言是被调用的，否则判定为失败</li>
</ol>
<pre><code class="lang-js">expect({a:<span class="hljs-number">1</span>}).toBe({a:<span class="hljs-number">1</span>})<span class="hljs-comment">//判断两个对象是否相等</span>
expect(<span class="hljs-number">1</span>).not.toBe(<span class="hljs-number">2</span>)<span class="hljs-comment">//判断不等</span>
expect(n).toBeNull(); <span class="hljs-comment">//判断是否为null</span>
expect(n).toBeUndefined(); <span class="hljs-comment">//判断是否为undefined</span>
expect(n).toBeDefined(); <span class="hljs-comment">//判断结果与toBeUndefined相反</span>
expect(n).toBeTruthy(); <span class="hljs-comment">//判断结果为true</span>
expect(n).toBeFalsy(); <span class="hljs-comment">//判断结果为false</span>
expect(value).toBeGreaterThan(<span class="hljs-number">3</span>); <span class="hljs-comment">//大于3</span>
expect(value).toBeGreaterThanOrEqual(<span class="hljs-number">3.5</span>); <span class="hljs-comment">//大于等于3.5</span>
expect(value).toBeLessThan(<span class="hljs-number">5</span>); <span class="hljs-comment">//小于5</span>
expect(value).toBeLessThanOrEqual(<span class="hljs-number">4.5</span>); <span class="hljs-comment">//小于等于4.5</span>
expect(value).toBeCloseTo(<span class="hljs-number">0.3</span>); <span class="hljs-comment">// 浮点数判断相等</span>
expect(<span class="hljs-string">'Christoph'</span>).toMatch(<span class="hljs-regexp">/stop/</span>); <span class="hljs-comment">//正则表达式判断</span>
expect([<span class="hljs-string">'one'</span>,<span class="hljs-string">'two'</span>]).toContain(<span class="hljs-string">'one'</span>); <span class="hljs-comment">//是否包含对应的值，括号里写上数组、字符串</span>
expect(compileAndroidCode).toThrow(); <span class="hljs-comment">//抛错误</span>
toBeInstanceOf(<span class="hljs-class"><span class="hljs-keyword">class</span>)：判断是不是<span class="hljs-title">class</span>的实例
<span class="hljs-title">anything</span>(<span class="hljs-title">value</span>)：匹配除了<span class="hljs-title">null</span>和<span class="hljs-title">undefined</span>以外的所有值
<span class="hljs-title">toHaveBeenCalled</span>()：用来判断<span class="hljs-title">mock</span> <span class="hljs-title">function</span>是否被调用过
<span class="hljs-title">toHaveBeenCalledTimes</span>(<span class="hljs-title">number</span>)：用来判断<span class="hljs-title">mock</span> <span class="hljs-title">function</span>被调用的次数
<span class="hljs-title">extend</span>(<span class="hljs-title">matchers</span>)：自定义一些断言
</span></code></pre>
<h3 id="生命周期：">生命周期：</h3>
<ol>
<li>afterAll(fn, timeout): 当前文件中的所有测试执行完成后执行 fn, 如果 fn 是 promise，jest 会等待 timeout 毫秒，默认 5000</li>
<li>afterEach(fn, timeout): 每个 test 执行完后执行 fn，timeout 含义同上</li>
<li>beforeAll(fn, timeout): 同 afterAll，不同之处在于在所有测试开始前执行</li>
<li>beforeEach(fn, timeout): 同 afterEach，不同之处在于在每个测试开始前执行</li>
</ol>
<h3 id="jest-对象">jest 对象</h3>
<ol>
<li>jest.fn(implementation)：返回一个全新没有使用过的 mock function，这个 function 在被调用的时候会记录很多和函数调用有关的信息</li>
<li>jest.mock(moduleName, factory, options)：用来 mock 一些模块或者文件</li>
<li>jest.spyOn(object, methodName)：返回一个 mock function，和 jest.fn 相似，但是能够追踪 object[methodName]的调用信息，类似 Sinon</li>
</ol>
<h2 id="测试覆盖率">测试覆盖率</h2>
<p>Jest 内置了测试覆盖率工具 istanbul，要开启，可以直接在命令中添加 --coverage 参数，或者在 package.json 文件进行更详细的配置</p>
<pre><code class="lang-js">jest --coverage
</code></pre>
<h2 id="jest-stare-测试报告">jest-stare 测试报告</h2>
<p><a href="https://dkelosky.github.io/jest-stare/" target="_blank">jest-stare</a>: jest 测试结果生成 html 或者 json 格式测试报告</p>
<p><img src="img/jest02.png" alt=""></img></p>
<p>在 package.json 文件，添加配置：</p>
<pre><code class="lang-json">{
  <span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"test-reportone"</span>: <span class="hljs-string">"jest --testResultsProcessor=jest-stare "</span>
  },
  <span class="hljs-string">"jest-stare"</span>: {
    <span class="hljs-string">"resultDir"</span>: <span class="hljs-string">"testreport/report"</span>,
    <span class="hljs-string">"resultJson"</span>: <span class="hljs-string">"data.json"</span>,
    <span class="hljs-string">"resultHtml"</span>: <span class="hljs-string">"index.html"</span>,
    <span class="hljs-string">"coverageLink"</span>: <span class="hljs-string">"../lcov-report/index.html"</span>
  }
}
</code></pre>
<h3 id="参数">参数</h3>
<ol>
<li>resultDir：设置生成结果目录</li>
<li>resultJson：指示原始 JSON 结果文件名</li>
<li>resultHtml：表示根 html 文件名</li>
<li>log：指定 jest-stare 是否应该登录到控制台</li>
<li>jestStareConfigJson： 请求保存 jest-stare 配置原始 JSON 结果的文件名</li>
<li>report ：boolean 设置为 false 以禁止生成 HTML 报告（仅保留 JSON）</li>
<li>coverageLink ：链接到覆盖率报告（如果有）</li>
<li>disableCharts： 隐藏 HTML 报告中的圆环图</li>
<li>hideFailing ：在页面加载时隐藏报告中的失败测试</li>
</ol>
<h2 id="调试-jest-测试">调试 JEST 测试</h2>
<p>要调试(debug)一个 Jest 测试，比如说"index.test.js"，我们需要使用如下的 node 指令来实现：</p>
<pre><code class="lang-json">node debug --harmony .\node_modules\jest-cli\bin\jest.js --runInBand myView-test.js
</code></pre>
<blockquote>
<ul>
<li>"node debug"将会启动 node 自带的调试器。"debug"会调用一个 V8 引擎调试器的 wrapper。这个 wrapper 提供了一系列的指令，用于在代码中跳进跳出和跟踪，而这些指令都不会出现在 V8 的"node -debug"中。（我承认它们看起来很相似，一个"-"符号之差）</li>
<li>"-harmony"标志是为了让 Jest 正确地运行。</li>
<li>".\node_modules\jest-cli\bin\jest.js"就是 Jest 的入口。这个文件会在我调用"\node_modules.bin"里的"Jest"时被调用。</li>
<li>"-runInBand"告诉 Jest 在当前的进程中运行所有测试，而不是再启动一个进程。Jest 默认就会启动多个进程并行的运行测试。如下为源码中关于这个选项的描述的片段（在.\node_modules\jest-cli\bin\jest.js 中）</li>
<li>"--watchall"</li>
<li>--bail 或： -b. 只要一有测试不通过，立马退出测试套件。</li>
<li>--cache 是否使用缓存。 默认值为 true。 使用 --no-cache 来禁止缓存。 注意︰ 仅在遇到缓存相关的问题时禁用缓存。 一般来说，禁用缓存会令 Jest 运行至少慢两倍。</li>
<li>--debug 显示出你 Jest 配置的调试信息</li>
<li>--expand 别名︰ -e。使用该参数来对比完整的差异和错误，而非修复。</li>
<li>--forceExit 强制 Jest 在所有测试运行完后退出。 对于一些由测试所生成但无法充分清理的资源来说，这是很有用的。 注意︰ 此功能是 escape-hatch。 如果 Jest 在测试运行最后没有退出，那就意味着外部资源还是被占用，又或是计时器还尚在你的代码中待令。 为了确保 Jest 可以完全关闭，建议你在每个测试后都关闭用到的外部资源。</li>
<li>--lastCommit 将运行在上次提交文件更改后的所有测试。</li>
<li>--showConfig 输出 Jest 配置，然后退出。</li>
<li>--watchman 是否使用 watchman 进行文件抓取。默认值为 true。使用--no-watchman 来禁用。</li>
<li>--watchAll 监视文件的更改并在任何更改时重新运行所有测试。若果你是想要重新运行仅基于已更改文件的测试，那么请使用 --watch 选项。</li>
<li>--watch 监视文件更改，并重新运行与已更改的文件相关的测试。当文件发生更改时，如果你想要重新运行所有测试，可以使用 --watchAll 选项。</li>
<li>--verbose 层次显示测试套件中每个测试的结果。</li>
<li>--useStderr 转移所有输出到 stderr(标准错误输出).</li>
<li>--updateSnapshot 或: -u. 在运行测试中使用这个参数来重新录制每个失败测试的快照。 还可以和测试套件模式或 --testNamePattern 一起使用，从而重新录制的快照。</li>
<li>--silent 阻止所有测试通过控制台输出信息。</li>
<li>--notify 激活测试结果通知。特别是当你不想专心致志等待 JavaScript 测试结果时。</li>
<li>--onlyChanged 或: -o. 尝试确定根据当前存储库中哪些已经更改的文件来运行的测试。 只有在此刻 git/hg 存储库中运行测试，需要静态依赖关系图时有用（例如. 无动态要求）。</li>
<li>--noStackTrace 禁止栈跟踪信息在测试结果输出中。</li>
<li>--logHeapUsage 记录每个测试后的记录堆使用情况。 主要用来调试内存泄漏。 与 --runInBand 和 --expose-gc 一起使用.</li>
</ul>
</blockquote>
<pre><code>"index.test.js"就是我们想要 debug 的测试文件。像这样使用相对路径是没有问题的，因为 Jest 会把它转换为一段正则表达式。
</code></pre><pre><code class="lang-js">cont, c - 继续执行
next, n - 跳到下一步
step, s - 跳进
out, o - 跳出
pause - 暂停执行的代码 (就像开发工具中的暂停按钮)

setBreakpoint(), sb() - 在当前行设置断点
setBreakpoint(line), sb(line) - 特定行设置断点
setBreakpoint(<span class="hljs-string">'fn()'</span>), sb(...) - 在函数体内的第一段声明中设置断点
setBreakpoint(<span class="hljs-string">'script.js'</span>, <span class="hljs-number">1</span>), sb(...) - 在script.js的第一行设置断点
clearBreakpoint, cb(...) - 清楚断点

backtrace, bt - 打印当前执行帧的回溯
list(<span class="hljs-number">5</span>) - 列出脚本源代码的<span class="hljs-number">5</span>行内容（前面和后面<span class="hljs-number">5</span>行）
watch(expr) - 向观察列表中添加表达式
unwatch(expr) - 去掉观察列表中的表达式
watchers - 列出所有的watcher以及它们的值（在每段断点处自动列出）
repl - 在调试脚本的内容时打开调试器的repl用于评估

run - 运行脚本（在调试开始时自动运行）
restart - 重启脚本
kill - 结束脚本
</code></pre>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="test.html" class="navigation navigation-prev " aria-label="Previous page: 测试">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="xss.html" class="navigation navigation-next " aria-label="Next page: XSS">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Jest","level":"1.1.3","depth":2,"next":{"title":"XSS","level":"1.1.4","depth":2,"path":"xss.md","ref":"xss.md","articles":[]},"previous":{"title":"测试","level":"1.1.2","depth":2,"path":"test.md","ref":"test.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"jest.md","mtime":"2025-05-03T00:37:27.953Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-09T01:11:20.855Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

