
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>csa Chapter6 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="CoderFAN 资料库 CSA Java_Object_oriented_Programming">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch07.html" />
    
    
    <link rel="prev" href="ch05.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="ch01.html">
            
                <a href="ch01.html">
            
                    
                    csa Chapter1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="ch02.html">
            
                <a href="ch02.html">
            
                    
                    csa Chapter2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch03.html">
            
                <a href="ch03.html">
            
                    
                    csa Chapter3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch04.html">
            
                <a href="ch04.html">
            
                    
                    csa Chapter4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ch05.html">
            
                <a href="ch05.html">
            
                    
                    csa Chapter5
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.7" data-path="ch06.html">
            
                <a href="ch06.html">
            
                    
                    csa Chapter6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="ch07.html">
            
                <a href="ch07.html">
            
                    
                    csa Chapter7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="ch08.html">
            
                <a href="ch08.html">
            
                    
                    csa Chapter8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="ch09.html">
            
                <a href="ch09.html">
            
                    
                    csa Chapter9
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >csa Chapter6</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h2 id="接口">接口</h2>
<p>大家已经顺利完成了前几章的学习，Java最困难也是最核心的几章大家都已经克服啦。接下来，继续一往直前，开始探索接口王国吧！💖</p>
<h2 id="接口是什么">接口是什么</h2>
<p>很多时候，在开发软件的过程中，对于不同的组、甚至是不同机构组织的程序员群体，同意签署一份说明软件如何交互的“合同”是很重要。这样一来，各个组间的代码可以互相交互，而完全不需要知道如何其他组的代码具体是如何实现的，也就是"会用就好，不需要在意具体如何实现"。接口就是这样的"合同"。</p>
<p>想象一下，在一个未来的社会，电脑控制的自动驾驶汽车，在没有人类司机的情况下载着乘客穿过大街小巷。汽车制造商通过Java编写控制汽车停止，启动，加速，左转等等行为的软件。而另有专门的自动驾驶仪制造商B，为汽车制造商生产的自动驾驶汽车提供自动驾驶仪，通过GPS、陀螺仪提供的数据来自动驾驶汽车。相当于，汽车制造商制造了一具身体（汽车），以及声明了这一具身体如何能够被控制着移动（就好像人的肢干可以运动，汽车可以前进后退一样），而自动驾驶仪制造商为车辆提供了大脑。</p>
<p>那么，汽车制造商组成的商业联盟必须发布行业标准接口，详细说明可以调用哪些方法使汽车行驶。所有的汽车制造商都使用这一个公认的行业标准，然后指导自动驾驶仪制造商，如何调用接口中描述的方法来使得"大脑"——自动驾驶仪，去指挥"身体"——车辆的运动。其他的工业组织，例如自动驾驶仪制造商，都不需要知道汽车制造商的软件（汽车如何运动）具体是如何实施的。事实上，每个制造商（例如汽车制造商，自动驾驶仪制造商）都认为它的软件是高度专有的，他们各自提供了接口，给别的制造商进行对接，但具体实现这些方法的过程，则是各自不透露的。</p>
<p>在Java编程语言中，接口是一个引用类型，类似于一个类，它相当于是一类方法的集合（有点像抽象类）。在接口中，这些方法，就如同抽象类一样，可以是抽象的（只包含一个声明，却不包括具体实现），也可以是普通的实例方法或静态方法（包括具体方法的实现）。 也就是说，对于接口，方法体只存在于普通的实例方法或静态方法中。 接口不能被实例化 - 它们只能由类实现或由其他接口扩展。</p>
<p>在AP考试中，普通的实例方法或静态方法（带具体方法实现的）是不会被考察的。只有抽象的接口会被考察。这也是我们本章设计的范围。</p>
<h2 id="定义接口">定义接口</h2>
<p>就像我们定义一个类一样，我们也需要先去定义一个接口，才能够使用它。
当我们定义一个类时，我们使用的关键字是<code>class</code>。而对于接口，我们使用的关键字是<code>interface</code>。例如：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SwimmingObject</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">//method that simulates swimming of object</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSwimming</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//true if object is swimming, false otherwise</span>
}
</code></pre>
<p>在这个例子中，我们定义了两个抽象方法：没有返回值的<code>swim()</code>和返回值为布尔型的<code>isSwimming()</code>
<code>public</code>访问修饰符表明，这一个接口可以被所有包(package)中的所有类调用。如果我们没有显式地声明一个接口是<code>public</code>的，那么这个接口就只能这个接口所在的包中的类调用。</p>
<p>接口与接口间也可以存在继承关系，从而扩展其他的接口，就如同一个子类可以继承父类从而扩展父类的内容一样。
但是，一个类只能直接继承自一个父类，不可能出现一个类同时直接继承自很多个父类的情况。(单继承)
而一个接口可以扩展任意数量的接口，我们使用英文逗号<code>,</code>来分隔开继承自的多个接口。如:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExampleInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface2</span>, <span class="hljs-title">Interface3</span>
</span></code></pre>
<h2 id="实现接口">实现接口</h2>
<p>我们已经学会了如何定义接口，那么，我们如何让类去实现已经定义好的接口，或者说，我们如何把类"接上"这些接口呢？答案是：使用<code>implement</code>关键字。例如：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SwimmingObject</span></span>{
<span class="hljs-comment">//类的内容</span>
}
</code></pre>
<p>这样一来，我们的类<code>Fish</code>就使用了<code>SwimmingObject</code>接口，也就"接上了"这个接口所提供的所有方法。因此，我们的类中，无论是否有定义新的方法，都一定会带有<code>SwimmingObject</code>接口中的两个方法：<code>swim()</code>与<code>isSwimming</code>()。</p>
<p>注意，继承自类<code>Fish</code>的所有子类都会自动地与父类<code>Fish</code>一样，接入<code>SwimmingObject</code>接口。父类<code>Fish</code>中带有了来自接口<code>SwimmingObject</code>的两个方法：<code>`swim()</code>与<code>isSwimming</code>()， 继承自该类的子类也必然带有这样的两个方法。</p>
<p>假如父类没有接入一个接口，也可以单独为子类接入一个接口，例如：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sardine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fish</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SwimmingObject</span>
</span>{
<span class="hljs-comment">//类的内容</span>
}
</code></pre>
<p><strong>注意：在这样使用时，<code>extends</code>关键字必须出现在implement关键词之前。</strong></p>
<p>前面我们提到，一个类只能直接继承自一个父类，不可能出现一个类同时直接继承自很多个父类的情况。而一个接口可以扩展任意数量的接口。同样的，一个类只能直接继承自一个父类，却可以同时接上多
个不同的接口，例如：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface1</span>, <span class="hljs-title">Interface2</span>, ...
</span></code></pre>
<h2 id="抽象类与接口的区别">抽象类与接口的区别</h2>
<p>抽象类与接口相似。二者都不能被实例化，并可能都包含了一系列方法（或具体或抽象）（在接口中使用具体的方法是Java 8中的新特性，一般而言接口只提供抽象的方法，具体的方法AP不考察）。然而，在接口中是不可以定义实例变量的，而在抽象类中可以。并且，一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以接上多个接口。抽象类中的方法可以是各种类型的，而接口中的成员变量只能是<code>public static final</code>类型的。</p>
<p>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是针对类的行为（方法）进行抽象，而不包括属性（接口中不能定义实例变量）。</p>
<p>当一种方法，对于正在编写的程序来说是非常适用的，但这种方法同时对其他的程序也同样适用时，我们就可以考虑使用接口。</p>
<h2 id="小练习">小练习</h2>
<p>1.Which statement about abstract classes and interfaces is false?</p>
<p>(A) An interface cannot implement any non-default instance methods, whereas
an abstract class can.</p>
<p>(B) A class can implement many interfaces but can have only one superclass.</p>
<p>(C) An unlimited number of unrelated classes can implement the same interface.</p>
<p>(D) It is not possible to construct either an abstract class object or an interface
object.</p>
<p>(E) All of the methods in both an abstract class and an interface are public.</p>
<cr type="hidden">E</cr>

<p>2.【2014年AP CS 第14题】Consider the following interface and class declarations.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Vehicle</span>
</span>{
<span class="hljs-comment">/** ©return the mileage traveled by this Vehicle */</span>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getMileage</span><span class="hljs-params">()</span></span>;
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fleet</span>
</span>{
<span class="hljs-keyword">private</span> ArrayList&lt;Vehicle&gt; myVehicles;
<span class="hljs-comment">/** ©return the mileage traveled by all vehicles in this Fleet
*/</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getTotalMileage</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;
<span class="hljs-keyword">for</span> (Vehicle v : myVehicles)
{
sum += <span class="hljs-comment">/* expression */</span> ;
}
<span class="hljs-keyword">return</span> sum;
}
/ / There may be instance variables, constructors, and methods that are not shown.
</code></pre>
<p>Which of the following can be used to replace /<em> expression </em>/ so that getTotalMileage returns the total of the miles traveled for all vehicles in the fleet?</p>
<p>(A) getMileage(v)</p>
<p>(B) myVehicles[v].getMileage()</p>
<p>(C) Vehicle.get(v).getMileage()</p>
<p>(D) myVehicles.get(v) .getMileage()</p>
<p>(E) v.getMileage()</p>
<cr type="hidden">E</cr>

<p>3.【2014年AP CS第25题】
A rectangular box fits inside another rectangular box if and only if the height, width, and depth of the smaller box are each less than the corresponding values of the larger box. Consider the following three interface declarations that are intended to represent information necessary for rectangular boxes.</p>
<p>I.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RBox</span>
</span>{
/ * * ©<span class="hljs-keyword">return</span> the height of <span class="hljs-keyword">this</span> RBox * / <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span></span>;
<span class="hljs-comment">/** ©return the width of this RBox */</span> <span class="hljs-keyword">double</span> getWidthO;
<span class="hljs-comment">/** ©return the depth of this RBox */</span> <span class="hljs-keyword">double</span> getDepthO;
}
</code></pre>
<p>II.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RBox</span>
</span>{
/ * * ©<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">if</span> the height of <span class="hljs-keyword">this</span> RBox is less than the height of other;
* <span class="hljs-keyword">false</span> otherwise
*/
<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">smallerHeight</span><span class="hljs-params">(RBox other)</span></span>;
<span class="hljs-comment">/** ©return true if the width of this RBox is less than the width of other;
* false otherwise
*/</span>
<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">smallerWidth</span><span class="hljs-params">(RBox other)</span></span>;
/ * * ©<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">if</span> the depth of <span class="hljs-keyword">this</span> RBox is less than the depth of other;
* <span class="hljs-keyword">false</span> otherwise
*/
<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">smallerDepth</span><span class="hljs-params">(RBox other)</span></span>;
}
</code></pre>
<p>III.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RBox</span>
</span>{
/ * * ©<span class="hljs-keyword">return</span> the surface area of <span class="hljs-keyword">this</span> RBox * / <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getSurfaceArea</span><span class="hljs-params">()</span></span>;
/ * * ©<span class="hljs-keyword">return</span> the volume of <span class="hljs-keyword">this</span> RBox * / <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getVolume</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p>Which of the interfaces, if correctly implemented by a Box class, would be sufficient functionality for a user of the Box class to determine if one Box can fit inside another?</p>
<p>(A) I only</p>
<p>(B) II only</p>
<p>(C) III only</p>
<p>(D) I and II only</p>
<p>(E) I, II, and III</p>
<cr type="hidden">D</cr>

<p>4.【2015年AP CS第33题】</p>
<p>Which of the following statements regarding interfaces is FALSE?</p>
<p>(A) All methods in an interface are public.</p>
<p>(B) An interface cannot be instantiated.</p>
<p>(C) An interface can declare an instance variable.</p>
<p>(D) A non-abstract class can implement an interface.</p>
<p>(E) An abstract class can implement an interface.</p>
<cr type="hidden">C</cr>

<p>5.【2015年AP CS第10题】
Consider the following interface and class declarations.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Student</span> </span>{ / * implementation not shown * / }
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Athlete</span> </span>{ / * implementation not shown * / }
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TennisPlayer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Athlete</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Student</span> </span>{ / * implementation not shown * / }
</code></pre>
<p>Assume that each class has a zero-parameter constructor. Which of the following is NOT a valid declaration?</p>
<p>(A) Student a = new TennisPlayer();</p>
<p>(B) TennisPlayer b = new TennisPlayer();</p>
<p>(C) Athlete c = new TennisPlayer();</p>
<p>(D) Student d = new Athlete();</p>
<p>(E) Athlete e = new Athlete();</p>
<p><cr type="hidden">D</cr>### 实验室</p>
<p>在这里练习吧：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
   public static void main(String[] args) {
     // 在这里添加你的代码
   }
}
&lt;/lab&gt;
</code></pre>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch05.html" class="navigation navigation-prev " aria-label="Previous page: csa Chapter5">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch07.html" class="navigation navigation-next " aria-label="Next page: csa Chapter7">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"CoderFAN 资料库 CSA Java_Object_oriented_Programming","title":"csa Chapter6","level":"1.7","depth":1,"next":{"title":"csa Chapter7","level":"1.8","depth":1,"path":"ch07.md","ref":"ch07.md","articles":[]},"previous":{"title":"csa Chapter5","level":"1.6","depth":1,"path":"ch05.md","ref":"ch05.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*","description":"CoderFAN 资料库 CSA Java_Object_oriented_Programming"},"file":{"path":"ch06.md","mtime":"2025-05-12T03:21:13.395Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-12T03:28:20.940Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

