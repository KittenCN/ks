
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>csa Chapter2 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch03.html" />
    
    
    <link rel="prev" href="ch01.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="ch01.html">
            
                <a href="ch01.html">
            
                    
                    csa Chapter1
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="ch02.html">
            
                <a href="ch02.html">
            
                    
                    csa Chapter2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch03.html">
            
                <a href="ch03.html">
            
                    
                    csa Chapter3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch04.html">
            
                <a href="ch04.html">
            
                    
                    csa Chapter4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ch05.html">
            
                <a href="ch05.html">
            
                    
                    csa Chapter5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="ch06.html">
            
                <a href="ch06.html">
            
                    
                    csa Chapter6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="ch07.html">
            
                <a href="ch07.html">
            
                    
                    csa Chapter7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="ch08.html">
            
                <a href="ch08.html">
            
                    
                    csa Chapter8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="ch09.html">
            
                <a href="ch09.html">
            
                    
                    csa Chapter9
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >csa Chapter2</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h2 id="构造方法">构造方法</h2>
<p>接下来介绍的是“构造方法”这一个概念。</p>
<p>每个类都有构造方法。如果没有专门为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<p>下面，让我们再来看一段Java代码，来看看在Java中，类、对象、方法三者的体现：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Dog.java"&gt;
public class Dog {
  String name;
  String sex;
  int age;
  public void bark(){
    System.out.println("I'm barking!!!");
  }
  public void eat(){
    System.out.println("I'm eating!!!");
  }
  public void showInfo(){
    System.out.println("My name is " + name + ", and my sex is " + sex + ". I'm " + age + " years old.");
  }
  public static void main(String[] args) {
    Dog myPuppy = new Dog();
    myPuppy.name = "CoolmyPuppy";
    myPuppy.age = 2;
    myPuppy.sex = "male";
    myPuppy.bark();
    myPuppy.eat();
    myPuppy.showInfo();
  }
}
&lt;/lab&gt;
</code></pre>
<p>让我们从上面这段Java代码中，分析其中类、对象，以及行为。</p>
<p>首先，我们新建了一个Dog类。这就好比自然界中，“狗”这个物种的统称。我们为这一个Dog类，赋予了name、sex、age，这三种属性。而这，就是Dog类中所有的对象（具体的狗）所共同具有的属性。我们还为这个类定义了四种行为：bark()、eat()，showInfo()，main()，前三种行为是这个类中，每一个具体的对象（具体的狗）所能够具有的行为。而main()行为则是Java程序执行的入口方法，也就是说，Java程序首先从main()方法开始执行。</p>
<p>在main()方法中，我们通过</p>
<pre><code class="lang-java">Dog myPuppy = <span class="hljs-keyword">new</span> Dog();
</code></pre>
<p>语句新建了一个对象，名叫myPuppy。也就是说，在“狗”这个大类中，诞生了一只名为“myPuppy”的狗。 这只myPuppy，由于它是一条狗，它自然而然继承了其所在的“狗”这一物种，所具有的所有属性与行为。也就是说，myPuppy具有name、sex、age三种属性，myPuppy能够bark、eat、showInfo。我们随即通过</p>
<pre><code class="lang-Java">myPuppy.name = <span class="hljs-string">"CoolmyPuppy"</span>;
myPuppy.age = <span class="hljs-number">2</span>;
myPuppy.sex = <span class="hljs-string">"male"</span>;
</code></pre>
<p>三行语句来设置myPuppy的三个属性。并通过</p>
<pre><code class="lang-Java">myPuppy.bark();
myPuppy.eat();
myPuppy.showInfo();
</code></pre>
<p>三行语句来调用myPuppy的三种行为。</p>
<p>可这样写的话，每一次都需要定义myPuppy的行为。让我们来改写上面那段代码，看看“构造方法(constructor)”究竟是什么。</p>
<pre><code class="lang-Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name, String sex, <span class="hljs-keyword">int</span> age)</span></span>{
        System.out.println(<span class="hljs-string">"My name is "</span> + name + <span class="hljs-string">", and my sex is "</span> + sex + <span class="hljs-string">". I'm "</span> + age + <span class="hljs-string">" years old."</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"I'm barking!"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"I'm eating!"</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Dog myPuppy = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">"CoolmyPuppy"</span>,<span class="hljs-string">"male"</span>, <span class="hljs-number">2</span>);
        myPuppy.bark();
        myPuppy.eat();
    }
}
</code></pre>
<p>对比上下两段代码，你发现了什么？  火眼金睛的你一定发现了：这里少掉了三行对<code>name</code>、<code>sex</code>和<code>age</code>的定义，转而新建了一个形如<code>public Dog(){}</code>的方法：</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name, String sex, <span class="hljs-keyword">int</span> age)</span></span>{
    System.out.println(<span class="hljs-string">"My name is "</span> + name + <span class="hljs-string">", and my sex is "</span> + sex + <span class="hljs-string">". I'm "</span> + age + <span class="hljs-string">" years old."</span>);
}
</code></pre>
<p>这个方法，就是一个构造方法。这里的“构造”是“方法”的定语。通过这个方法，我们定义了<code>Dog</code>这一个类所具有的三个属性：<code>name</code>、<code>sex</code>和<code>age</code>。这三个属性作为这个“构造方法” 的传入参数。在这个方法体中，我们使用<code>System.out.println()</code>方法，向屏幕输出一行信息。然后，在<code>main()</code>方法中，我们和前面一样，新建了一个<code>Dog</code>类的对象：<code>myPuppy</code>。区别之处在于，这一次，我们用于新建对象的语句</p>
<pre><code class="lang-Java">Dog myPuppy = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">"CoolmyPuppy"</span>,<span class="hljs-string">"male"</span>, <span class="hljs-number">2</span>);
</code></pre>
<p>在括号中传入了三个参数，这三个参数就依次对应着构造方法中的三个传入参数。原先的showInfo()方法实现的功能，在这里也并入了构造方法中如下这一行语句。</p>
<pre><code class="lang-Java">System.out.println(<span class="hljs-string">"My name is "</span> + name + <span class="hljs-string">", and my sex is "</span> + sex + <span class="hljs-string">". I'm "</span> + age + <span class="hljs-string">" years old."</span>);
</code></pre>
<p>在我们原先的程序中，我们没有显式地定义一个构造方法，但Java编译器实际上已经为我们定义了一个。</p>
<p>在我们刚才定义的这个构造方法中，我们写的是：</p>
<pre><code class="lang-Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name, String sex, <span class="hljs-keyword">int</span> age)</span></span>{
    System.out.println(<span class="hljs-string">"My name is "</span> + name + <span class="hljs-string">", and my sex is "</span> + sex + <span class="hljs-string">". I'm "</span> + age + <span class="hljs-string">" years old."</span>);
}
</code></pre>
<p>这个方法中，并没有返回值类型、返回值。也就是说，构造方法是没有返回值的，并且构造方法的名称必须与类名相同。</p>
<p>那这个构造器到底有什么用呢？请看下面这段代码：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Dog.java"&gt;
public class Dog {
    public Dog(String name, String sex, int age){
        System.out.println("My name is " + name + ", and my sex is " + sex + ". I'm " + age + " years old.");
    }
    public static void main(String[] args){
        Dog myDog1 = new Dog("Tom", "Male", 2);
        Dog myDog2 = new Dog("Sam", "Male",3);
        Dog myDog3 = new Dog("Lily","Female",4);
        Dog myDog4 = new Dog("Sally","Female",5);
    }
}
&lt;/lab&gt;
</code></pre>
<p>在这个例子中，我们需要一次性new出许许多多个属于<code>Dog</code>这个类的对象（具体的一条条狗）。所有的狗都具有名称、性别、年龄这三个属性。因此，我们在<code>public Dog()</code>这个构造方法中，提前定义了这三个属性，这三个属性，就作为整个类所有的是对象都共有的属性。这样一来，我们在<code>main</code>方法中<code>new</code>对象时，就无需在一个一个地定义这三个属性了。这为我们提高了非常多的效率。因此，“构造方法”就相当于，提前“构造”出了一个框架，这个框架每个对象都可以用，只需要在这个框架上赋予不同的内容即可。</p>
<h2 id="访问器和更改器">访问器和更改器</h2>
<p>接下来，我们看看如何更加方便地读取和设置Java属性值。习惯上，我们使用getter与setter方法来存取Java属性值。这两种方法分别叫“访问器（Accessor）”与“更改器(Mutator)”——（人们总喜欢给简单的事物赋予复杂高级的名称）。使用这两种方法，能够为我们提供一个访问、修改、读取属性值的中间层，可以提高程序的安全性，避免数据被恶意篡改，也是面向对象编程的核心思想之一。习惯上，getter方法与setter方法的命名为：getXXX,setXXX.</p>
<p>在下面这段代码中，setName()就是更改器(Mutator)，而getName()就是访问器(Accessor)。</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>{
    String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String inName)</span></span>{
        name = inName;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">( )</span></span>{
        System.out.println(<span class="hljs-string">"Dog name is: "</span> + name );
        <span class="hljs-keyword">return</span> name;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span></span>{
        <span class="hljs-comment">/* 创建对象 */</span>
        Dog myDog = <span class="hljs-keyword">new</span> Dog();
        <span class="hljs-comment">/* 通过方法来设定name */</span>
        myDog.setName(<span class="hljs-string">"myPuppy"</span>);
        <span class="hljs-comment">/* 调用另一个方法获取name */</span>
        myDog.getName();
        <span class="hljs-comment">/*你也可以像下面这样访问成员变量 */</span>
        System.out.println(<span class="hljs-string">"name值 : "</span> + myDog.getName() );
    }
}
</code></pre>
<p>我们在前一章节学到了<code>this</code>关键字。我们知道，如果在某个变量前面加上一个<code>this</code>关键字，其指的就是这个对象的成员变量或者方法，而不是指成员方法的形式参数或者局部变量。简单地说，当出现了一个局部变量与一个全局变量都使用了同一个名字时，<code>this</code>关键字将指明其紧跟的变量为全局变量，而非局部变量，避免混淆。</p>
<p>因此，我们的更改器和访问器还可以这么写：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span></span>{
    String name;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>{
        <span class="hljs-keyword">this</span>.name = name;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">( )</span></span>{
        System.out.println(<span class="hljs-string">"Dog name is: "</span> + name );
        <span class="hljs-keyword">return</span> name;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String []args)</span></span>{
        <span class="hljs-comment">/* 创建对象 */</span>
        Dog myDog = <span class="hljs-keyword">new</span> Dog();
        <span class="hljs-comment">/* 通过方法来设定name */</span>
        myDog.setName(<span class="hljs-string">"myPuppy"</span>);
        <span class="hljs-comment">/* 调用另一个方法获取name */</span>
        myDog.getName();
        <span class="hljs-comment">/*你也可以像下面这样访问成员变量 */</span>
        System.out.println(<span class="hljs-string">"name值 : "</span> + myDog.getName() );
    }
}
</code></pre>
<p>来试试看编译运行结果吧！</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Dog.java"&gt;
public class Dog{
    String name;
    public void setName(String inName){
        name = inName;
    }
    //或者你也可以这样写：
    //public void setName(String name){
    //    this.name = name;
    //}
    public String getName( ){
        System.out.println("Dog name is: " + name );
        return name;
    }
    public static void main(String []args){
        Dog myDog = new Dog();
        myDog.setName("myPuppy");
        myDog.getName();
        System.out.println("name值 : " + myDog.getName() );
    }
}
&lt;/lab&gt;
</code></pre>
<h2 id="方法重载">方法重载</h2>
<p>方法重载指的是，多个方法有同样的名字，却有不同的传入参数列表。看下面这段代码：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">cat</span> </span>{
    String name;
    String type;
    <span class="hljs-keyword">double</span> weight;
    <span class="hljs-keyword">int</span> age;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">cat</span><span class="hljs-params">()</span></span>{
        name = <span class="hljs-string">" "</span>;
        weight = <span class="hljs-number">0</span>;
        type = <span class="hljs-string">" "</span>;
        System.out.println(<span class="hljs-string">"I am an undefined cat."</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">cat</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> weight, String type)</span></span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.weight = weight;
        <span class="hljs-keyword">this</span>.type = type;
        System.out.println(<span class="hljs-string">"My name is "</span> + name + <span class="hljs-string">" and my weight is "</span> + weight + <span class="hljs-string">" and I am a "</span> + type + <span class="hljs-string">" cat."</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">cat</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> weight, String type, <span class="hljs-keyword">int</span> age)</span></span>{
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.weight = weight;
        <span class="hljs-keyword">this</span>.type = type;
        <span class="hljs-keyword">this</span>.age = age;
        System.out.println(<span class="hljs-string">"My name is "</span> + name + <span class="hljs-string">" and my weight is "</span> + weight + <span class="hljs-string">" and I am a "</span> + type + <span class="hljs-string">" cat who is "</span> + age + <span class="hljs-string">" years old."</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{
        cat cat1 = <span class="hljs-keyword">new</span> cat();
        cat cat2 = <span class="hljs-keyword">new</span> cat(<span class="hljs-string">"Kitty"</span>, <span class="hljs-number">2</span>, <span class="hljs-string">"Garfield"</span>);
        cat cat3 = <span class="hljs-keyword">new</span> cat(<span class="hljs-string">"Mew"</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"Garfield"</span>, <span class="hljs-number">3</span>);
    }
}
</code></pre>
<p>其中，我们有三个同名的<code>cat</code>方法。 它们的区别在于，前者的传入参数列表为空，后者则定义了三个传入参数，再后者则定义了四个。程序在执行的时候，会根据用户给其的传入参数不同，自动给出它所要调用的方法。对象<code>cat1</code>的传入参数列表为空，故<code>cat1</code>自动对应的是第一个<code>cat()</code>方法；对象<code>cat2</code>有三个传入参数，故<code>cat2</code>自动对应的是第二个<code>cat</code>方法；对象<code>cat3</code>有四个传入参数，故<code>cat3</code>自动对应的是第三个<code>cat</code>方法。</p>
<p>来试试看编译运行结果吧！</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=cat.java"&gt;
public class cat {
    String name;
    String type;
    double weight;
    int age;
    public cat(){
        name = " ";
        weight = 0;
        type = " ";
        System.out.println("I am an undefined cat.");
    }
    public cat(String name, double weight, String type){
        this.name = name;
        this.weight = weight;
        this.type = type;
        System.out.println("My name is " + name + " and my weight is " + weight + " and I am a " + type + " cat.");
    }
    public cat(String name, double weight, String type, int age){
        this.name = name;
        this.weight = weight;
        this.type = type;
        this.age = age;
        System.out.println("My name is " + name + " and my weight is " + weight + " and I am a " + type + " cat who is " + age + " years old.");
    }
    public static void main(String[] args){
        cat cat1 = new cat();
        cat cat2 = new cat("Kitty", 2, "Garfield");
        cat cat3 = new cat("Mew", 3, "Garfield", 3);
    }
}
&lt;/lab&gt;
</code></pre>
<h2 id="javadoc注释">Javadoc注释</h2>
<p>注释我们已经在[Java入门教程的“注释”一节]里面说过了，其目的主要是为了让读代码的人知道代码的用途。在Java里有一种特殊的注释——Javadoc注释，是用来描述一个方法的信息，一般放在方法定义前。</p>
<pre><code class="lang-java"><span class="hljs-comment">/** Puts obj at location loc in this grid, and returns
* the object previously at this location.
* Returns null if loc was previously unoccupied.
* Precondition: obj is not null, and loc is valid in this grid.
* <span class="hljs-doctag">@param</span> loc the location where the object will be placed
* <span class="hljs-doctag">@param</span> obj the object to be placed
* <span class="hljs-doctag">@return</span> the object previously at the specified location
* <span class="hljs-doctag">@throws</span> NullPointerException if the object is null */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">put</span><span class="hljs-params">(Location loc, E obj)</span> </span>{ <span class="hljs-comment">// 这是方法定义</span>
...
</code></pre>
<p>首先最前面的部分是这个方法功能和用法的文字描述，之后的<code>@param</code>代表这后面的是描述参数的，<code>loc</code>和<code>obj</code>是参数名，之后的是参数说明。<code>@return</code>是对返回值的说明，<code>@throws NullPointerException</code>代表可能抛出<code>NullPointerException</code>，后面是抛出的条件。<code>Precondition</code>指的是函数运行之前需要有的条件。而<code>Postcondition</code>（这个函数没有用到）指的是函数运行之后的状态，也就是函数的效果。</p>
<h2 id="小练习">小练习</h2>
<ol>
<li>Consider the following code segment.</li>
</ol>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tester</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">someMethod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>{
     <span class="hljs-keyword">int</span> temp = a;
     a = b;
     b = temp;
  }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TesterMain</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{
     <span class="hljs-keyword">int</span> x = <span class="hljs-number">6</span>, y = <span class="hljs-number">8</span>;
     Tester tester = <span class="hljs-keyword">new</span> Tester();
     tester.someMethod(x, y);
  }
}
</code></pre>
<p>Just before the end of execution of this program, what are the values of x, y, and
temp, respectively?</p>
<p>(A) 6, 8, 6</p>
<p>(B) 8, 6, 6</p>
<p>(C) 6, 8, ?, where ? means undefined</p>
<p>(D) 8, 6, ?, where ? means undefined</p>
<p>(E) 8, 6, 8</p>
<cr type="hidden">C</cr>

<p>   2.Consider the following code segment.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>
</span>{
  <span class="hljs-keyword">private</span> String myName; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> myYearOfBirth;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> yearOfBirth)</span>
  </span>{
    myName = name;
    myYearOfBirth = yearOfBirth;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span>
  </span>{ <span class="hljs-keyword">return</span> myName; }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span>
  </span>{ myName = name; }
<span class="hljs-comment">//There may be instance variables, constructors, and methods that are not shown.</span>
}
</code></pre>
<p>Assume that the following declaration has been made.</p>
<pre><code class="lang-java">Person student = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Thomas"</span>, <span class="hljs-number">1995</span>);
</code></pre>
<p>Which of the following statements is the most appropriate for changing the name of student from "Thomas" to "Tom" ?</p>
<p>(A) student = new Person("Tom", 1995);</p>
<p>(B) student.myName = "Tom";</p>
<p>(C) student.getName("Tom");</p>
<p>(D) student.setName("Tom");</p>
<p>(E) Person.setName("Tom");</p>
<cr type="hidden">D</cr>

<p>3.Consider the following class declaration.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>
</span>{
  <span class="hljs-keyword">private</span> String myName; 
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> myAge;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span>)
  </span>{ <span class="hljs-comment">/* implementation not shown */</span> }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span>
  </span>{ <span class="hljs-comment">/* implementation not shown */</span> }

  <span class="hljs-comment">// No other constructors</span>
}
</code></pre>
<p>Which of the following declarations will compile without error?</p>
<p>I.Student a = new Student();</p>
<p>II.Student b = new Student("Juan", 15);</p>
<p>III.Student c = new Student("Juan", "15");</p>
<p>(A) I only</p>
<p>(B) II only</p>
<p>(C) I and II only</p>
<p>(D) I and III only</p>
<p>(E) I, II, and III</p>
<cr type="hidden">C</cr>



<h3 id="实验室">实验室</h3>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
   public static void main(String[] args) {
     // 在这里添加你的代码
   }
}
&lt;/lab&gt;
</code></pre>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch01.html" class="navigation navigation-prev " aria-label="Previous page: csa Chapter1">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch03.html" class="navigation navigation-next " aria-label="Next page: csa Chapter3">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"csa Chapter2","level":"1.3","depth":1,"next":{"title":"csa Chapter3","level":"1.4","depth":1,"path":"ch03.md","ref":"ch03.md","articles":[]},"previous":{"title":"csa Chapter1","level":"1.2","depth":1,"path":"ch01.md","ref":"ch01.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"ch02.md","mtime":"2024-01-02T09:07:45.446Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T05:23:53.832Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

