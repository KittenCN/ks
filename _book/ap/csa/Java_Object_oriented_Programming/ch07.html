
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>csa Chapter7 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch08.html" />
    
    
    <link rel="prev" href="ch06.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="ch01.html">
            
                <a href="ch01.html">
            
                    
                    csa Chapter1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="ch02.html">
            
                <a href="ch02.html">
            
                    
                    csa Chapter2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch03.html">
            
                <a href="ch03.html">
            
                    
                    csa Chapter3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch04.html">
            
                <a href="ch04.html">
            
                    
                    csa Chapter4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ch05.html">
            
                <a href="ch05.html">
            
                    
                    csa Chapter5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="ch06.html">
            
                <a href="ch06.html">
            
                    
                    csa Chapter6
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.8" data-path="ch07.html">
            
                <a href="ch07.html">
            
                    
                    csa Chapter7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="ch08.html">
            
                <a href="ch08.html">
            
                    
                    csa Chapter8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="ch09.html">
            
                <a href="ch09.html">
            
                    
                    csa Chapter9
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >csa Chapter7</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="最终超类——object类">最终超类——Object类</h1>
<p>哈哈，祝贺大家！在前几个章节中我们已经攻克了AP所涉及的Java面向对象编程中，最难啃的几个概念。这一章节与下一章节，我们将进行收尾。请大家不要急躁，马上，我们就完成所有章节的攻克啦！</p>
<h2 id="object类是什么">Object类是什么</h2>
<p>我们在<code>继承</code>章节中讲过，在Java中，除了最终超类：<code>Object</code>类，所有的类都有且仅有一个直接的父类（这被称为单继承）。当没有明确在程序中声明某些类所属的父类时，这些类都是最终超类：<code>Object</code>类的（隐式）子类。</p>
<p>那么，<code>Object</code>类，就是Java世界中，处在类继承层次结构上的最高层次的那一个类，也叫作最终超类(ultimate superclass)。<code>Object</code>类是一个普通的类，而非抽象类。</p>
<p>在Java中，所有的类都被规定为继承自<code>Object</code>类，也就是说，<code>Object</code>类是所有类的直接或间接父类。</p>
<p><img src="ch07_Pic3.gif" alt="继承树"></img></p>
<h2 id="object类里的方法">Object类里的方法</h2>
<p>在<code>Object</code>类中有许多内置的方法。这些方法都被所有其他的类自动继承。<code>Object</code>类是一个普通的类，而非抽象类。因此，<code>Object</code>类中所有的方法都是带有具体实现的实例方法。在写程序时，你完全可以选择不去使用<code>Object</code>类中的任何内置方法。但是，如果你选择去使用它们，你可能会需要在子类中带有特定目的性地重写这些方法，使得这些方法更贴合你的子类。</p>
<p>在AP考试中，我们需要掌握两个<code>Object</code>类中的内置方法：<code>toString()</code>方法，以及<code>equals()</code>方法。</p>
<h3 id="tostring-方法"><code>toString()</code> 方法</h3>
<p><code>toString()</code>方法的具体实现语句如下：</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span>
</span></code></pre>
<p>这是一个<code>public</code>的，返回值为<code>String</code>型的方法。</p>
<p>这个方法的作用是，以<code>String</code>类型，返回调用这个方法"想要返回的"信息，这个信息作为<code>toString()</code>方法的返回值，也作为调用这个方法的对象的一个<code>String</code>类型的属性，最后，我们通常使用<code>System.out.println(对象名)</code>来打印出<code>toString()</code>方法返回的信息。也就是说，当你编写一段程序时，在一段方法的行为执行过程中，你可能会希望这个方法以字符串的形式返回一个信息（比如一句话）。例如，在一个改变银行账户余额的行为中，你可能会想让这个方法返回一个当前账户余额的信息。这个时候，你就可以使用<code>toString()</code>方法。也就是说，想让<code>toString()</code>方法返回什么样的信息，完全取决于编程者的意愿，完全取决于是什么样的一个具体对象调用了这个方法，取决于这一个调用它的对象想要返回什么信息。而，每一段程序，每一个对象想要做的事情都迥然不同，而<code>toString()</code>方法却是所有类都继承的、处在最终超类<code>Object</code>中的一个方法。显然，如果直接继承使用（而不加重写）这一个方法，根本不能满足每一个特定的类中的特定的对象的特定要求。因此，我们应该总是考虑在每一个需要使用<code>toString()</code>的方法中重写<code>toString()</code>方法。</p>
<p>如果我们直接使用<code>Object</code>类中的<code>toString()</code>而未进行重写，我们将得到<code>toString()</code>方法所在的类名加上一串数字（调用<code>toString()</code>类的对象的内存地址）。例如：</p>
<pre><code class="lang-Java">ExampleClass o = <span class="hljs-keyword">new</span> ExampleClass;
System.out.println(o);
</code></pre>
<p>调用了继承自<code>Object</code>类的<code>toString()</code>方法，其结果可能为</p>
<pre><code>ExampleClass@bbf326d7
</code></pre><p>这通常不是我们想要的结果（除非你的目的是知道对象的内存地址）。因此我们应该总是考虑在具体的类中重写<code>toString()</code>方法。</p>
<p>例如，我们想让一个方法能够返回一句话，来表述库存的书的数目：</p>
<pre><code class="lang-Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>{
    <span class="hljs-keyword">int</span> BookVolume = <span class="hljs-number">500</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"The number of book is "</span> + BookVolume + <span class="hljs-string">"."</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{
        Book b = <span class="hljs-keyword">new</span> Book();
        System.out.println(b);
    }
}
</code></pre>
<p>会如我们所愿地输出结果:</p>
<pre><code>The number of book is 500.
</code></pre><p>注意：
<code>toString()</code>方法是不适用于数组对象(array object)的。 若要打印出数组的元素，我们必须遍历数组的每一个元素，并明确地一个一个打印出这些元素的信息。</p>
<h3 id="equals-方法"><code>equals()</code> 方法</h3>
<p>相等的意义要视对象的类型而定。</p>
<p>举例来说，如果两个不同的作为原始数据类型的<code>String</code>类型的变量带有相同的字符，它们在涵义上是相等的，因为<code>String</code>作为原始类型，也只与涵义有关，不存在引用的概念，因此，这两个<code>String</code>类型的变量就可以说是完全相等了。</p>
<p>很多时候，我们想要知道两个原始数据类型(primitive type)是否相等。这个时候很简单，只要使用<code>==</code>这个运算符就可以。例如：</p>
<pre><code class="lang-java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;
<span class="hljs-keyword">byte</span> b = <span class="hljs-number">3</span>;
System.out.println(<span class="hljs-keyword">if</span>(a==b));
</code></pre>
<p>返回<code>true</code></p>
<p>有时你想要知道两个引用类型的变量（比如类）在是否引用到（指向）同一个对象。这也很容易，也是使用<code>==</code>运算符。例如：</p>
<pre><code class="lang-java">Date d1 = <span class="hljs-keyword">new</span> Date(<span class="hljs-string">"March"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2018</span>);
Date d2 = d1;
Date d3 = <span class="hljs-keyword">new</span> Date(<span class="hljs-string">"March"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2018</span>);
System.out.println(<span class="hljs-keyword">if</span>(d1==d3));
</code></pre>
<p>将会返回<code>false</code>，因为<code>d1</code>与<code>d3</code>并非指向同一个对象：一个叫<code>d1</code>，一个叫<code>d2</code>，这是内存上占用两个不同内存地址的两个独立对象。</p>
<p>也就是说，对于原始数据类型的变量，<code>==</code>仅仅比较两个变量是否具有相同的字节。对于引用数据类型的变量，<code>==</code>仅仅比较两个变量是否指向同一个对象。</p>
<p>但是，有时，你会需要知道两个对象在实际意义上（也就是对象所包含的值）是否真的相等。此时你就得使用<code>equals()</code>这个方法。例如：</p>
<pre><code class="lang-java">Date d1 = <span class="hljs-keyword">new</span> Date(<span class="hljs-string">"March"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2018</span>);
Date d2 = d1;
Date d3 = <span class="hljs-keyword">new</span> Date(<span class="hljs-string">"March"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2018</span>);
System.out.println(d1.equals(d3));
</code></pre>
<p>将返回<code>true</code>，因为，尽管<code>d1</code>与<code>d2</code>在引用上不相同（二者指向不同的对象，一个是<code>d1</code>，一个是<code>d2</code>），但二者的<strong>内容</strong>是一样的，都是同一个日期。</p>
<h2 id="小练习">小练习</h2>
<p>Consider the code fragment</p>
<pre><code class="lang-java">Object intObj = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">9</span>);
System.out.println((String) intObj);
</code></pre>
<p>What will be output as a result of running the fragment?</p>
<p>(A) No output. A ClassCastExceptionwill be thrown.</p>
<p>(B) No output. An ArithmeticExceptionwill be thrown.</p>
<p>(C) 9</p>
<p>(D) "9"</p>
<p>(E) nine</p>
<p><cr type="hidden">A</cr></p>
<h3 id="实验室">实验室</h3>
<p>在这里练习吧：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
   public static void main(String[] args) {
     // 在这里添加你的代码
   }
}
&lt;/lab&gt;
</code></pre>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch06.html" class="navigation navigation-prev " aria-label="Previous page: csa Chapter6">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch08.html" class="navigation navigation-next " aria-label="Next page: csa Chapter8">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"csa Chapter7","level":"1.8","depth":1,"next":{"title":"csa Chapter8","level":"1.9","depth":1,"path":"ch08.md","ref":"ch08.md","articles":[]},"previous":{"title":"csa Chapter6","level":"1.7","depth":1,"path":"ch06.md","ref":"ch06.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"ch07.md","mtime":"2024-01-02T09:07:45.454Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T05:23:53.832Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

