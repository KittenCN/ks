
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>csa Chapter5 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch06.html" />
    
    
    <link rel="prev" href="ch04.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="ch01.html">
            
                <a href="ch01.html">
            
                    
                    csa Chapter1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="ch02.html">
            
                <a href="ch02.html">
            
                    
                    csa Chapter2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch03.html">
            
                <a href="ch03.html">
            
                    
                    csa Chapter3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch04.html">
            
                <a href="ch04.html">
            
                    
                    csa Chapter4
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.6" data-path="ch05.html">
            
                <a href="ch05.html">
            
                    
                    csa Chapter5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="ch06.html">
            
                <a href="ch06.html">
            
                    
                    csa Chapter6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="ch07.html">
            
                <a href="ch07.html">
            
                    
                    csa Chapter7
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="ch08.html">
            
                <a href="ch08.html">
            
                    
                    csa Chapter8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="ch09.html">
            
                <a href="ch09.html">
            
                    
                    csa Chapter9
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >csa Chapter5</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="多态">多态</h1>
<p>接下来，开始探索多态王国吧！💖</p>
<h2 id="初识多态">初识多态</h2>
<p>这一小节中，我们将阐述多态的概念。若大家觉得有些晦涩，也没有关系，可以边看边思考。在有了这一小节的初步印象后，下一小节将会帮助大家更好地理解多态的概念。</p>
<p>多态(Polymorphism)是Java面向对象编程中非常重要的一个概念。多态，原本指的是在生物学中，一个生物体或物种，可以有不同的形态或发育阶段（例如蝴蝶的变态）。<strong>在Java中，多态指的是，同一个方法具有多个不同表现形式或形态的能力。</strong>
多态的好处是，可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
<p>多态的概念，与前一节我们讲过的<code>方法重写</code>有着紧密的关联。一个至少在一个子类中被重写过的方法，就被称为是多态的方法。</p>
<p>对于被重写过的方法，它们都具有相同的方法名。那么Java在运行的时候，该如何是好？Java是依靠什么机制，来选择具体要执行哪一个方法的呢？</p>
<p><strong>在Java中，方法调用总是由调用这一方法的对象实际指向的对象类型（也就是在<code>new</code>语句后紧跟着的类型），而不是由这一对象引用的对象类型（也就是在<code>new</code>语句中，实际对象前面的那个类型）来决定的。</strong></p>
<p>例如，在语句</p>
<pre><code class="lang-javav">Animal puppy = new Dog();
</code></pre>
<p>中，实例对象<code>puppy</code>所引用的类型是<code>Animal</code>，而其实际指向的类型则是<code>Dog</code>。</p>
<p>这个机制，就叫做多态。</p>
<p><strong>多态是一个为处在类继承层次结构中的特定对象，选择适当的方法的机制。</strong></p>
<p>来给大家举一个例子。这个例子比较长，但在其后有详细的解释，不要慌！</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bicycle</span> </span>{

    <span class="hljs-comment">// 这个自行车有三个属性</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> cadence;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> gear;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> speed;

    <span class="hljs-comment">// 这个自行车类有一个构造方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bicycle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startCadence, <span class="hljs-keyword">int</span> startSpeed, <span class="hljs-keyword">int</span> startGear)</span> </span>{
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDescription</span><span class="hljs-params">()</span></span>{
        System.out.println(<span class="hljs-string">"\nBike is "</span> + <span class="hljs-string">"in gear "</span> + <span class="hljs-keyword">this</span>.gear
        + <span class="hljs-string">" with a cadence of "</span> + <span class="hljs-keyword">this</span>.cadence +
        <span class="hljs-string">" and travelling at a speed of "</span> + <span class="hljs-keyword">this</span>.speed + <span class="hljs-string">". "</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MountainBike</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bicycle</span> </span>{
    <span class="hljs-keyword">private</span> String suspension;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MountainBike</span><span class="hljs-params">(
               <span class="hljs-keyword">int</span> startCadence,
               <span class="hljs-keyword">int</span> startSpeed,
               <span class="hljs-keyword">int</span> startGear,
               String suspensionType)</span></span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDescription</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.printDescription();
        System.out.println(<span class="hljs-string">"The "</span> + <span class="hljs-string">"MountainBike has a"</span> +
            getSuspension() + <span class="hljs-string">" suspension."</span>);
    }
}


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoadBike</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bicycle</span></span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tireWidth;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoadBike</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startCadence,
                    <span class="hljs-keyword">int</span> startSpeed,
                    <span class="hljs-keyword">int</span> startGear,
                    <span class="hljs-keyword">int</span> newTireWidth)</span></span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDescription</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">super</span>.printDescription();
        System.out.println(<span class="hljs-string">"The RoadBike"</span> + <span class="hljs-string">" has "</span> + getTireWidth() +
            <span class="hljs-string">" MM tires."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBikes</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{
    Bicycle bike01, bike02, bike03;

    bike01 = <span class="hljs-keyword">new</span> Bicycle(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>);
    bike02 = <span class="hljs-keyword">new</span> MountainBike(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"Dual"</span>);
    bike03 = <span class="hljs-keyword">new</span> RoadBike(<span class="hljs-number">40</span>, <span class="hljs-number">20</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>);

    bike01.printDescription();
    bike02.printDescription();
    bike03.printDescription();
  }
}
</code></pre>
<p>下面进行拆分解释。首先，如下是我们在上一节中见过的Bicycle类，为了展示多态，我们引入一个方法<code>printDescription</code>，来展示一个对象（自行车）的所有当前属性。最终<code>Bicycle</code>类为如下：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bicycle</span> </span>{

    <span class="hljs-comment">// 这个自行车有三个属性</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> cadence;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> gear;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> speed;

    <span class="hljs-comment">// 这个自行车类有一个构造方法</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bicycle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startCadence, <span class="hljs-keyword">int</span> startSpeed, <span class="hljs-keyword">int</span> startGear)</span> </span>{
        gear = startGear;
        cadence = startCadence;
        speed = startSpeed;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDescription</span><span class="hljs-params">()</span></span>{
        System.out.println(<span class="hljs-string">"\nBike is "</span> + <span class="hljs-string">"in gear "</span> + <span class="hljs-keyword">this</span>.gear
        + <span class="hljs-string">" with a cadence of "</span> + <span class="hljs-keyword">this</span>.cadence +
        <span class="hljs-string">" and travelling at a speed of "</span> + <span class="hljs-keyword">this</span>.speed + <span class="hljs-string">". "</span>);
}
}
</code></pre>
<p>为了展示多态，我们由<code>Bicycle</code>类派生出<code>MountainBike</code>类与<code>RoadBike</code>类，并在二者中重写<code>printDescription</code>方法。</p>
<p>在<code>MountainBike</code>类中，我们引入一个新的属性：<code>suspension</code>，来描述山地自行车的悬挂缓冲系统（描述这辆车是否有一个前缓冲系统<code>Front</code>，或有一个前缓冲系统和一个后缓冲系统<code>Dual</code>）.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MountainBike</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bicycle</span> </span>{
    <span class="hljs-keyword">private</span> String suspension;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MountainBike</span><span class="hljs-params">(
               <span class="hljs-keyword">int</span> startCadence,
               <span class="hljs-keyword">int</span> startSpeed,
               <span class="hljs-keyword">int</span> startGear,
               String suspensionType)</span></span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDescription</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.printDescription();
        System.out.println(<span class="hljs-string">"The "</span> + <span class="hljs-string">"MountainBike has a"</span> +
            getSuspension() + <span class="hljs-string">" suspension."</span>);
    }
}
</code></pre>
<p>请注意重写的<code>printDescription</code>方法。 除了之前提供的信息之外，输出中还包括有关悬挂缓冲系统的其他信息。</p>
<p>接下来，创建<code>RoadBike</code>类。 由于公路赛车或赛车有较细窄的轮胎，因此我们添加一个属性<code>tireWidth</code>来描述轮胎宽度。</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoadBike</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bicycle</span></span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> tireWidth;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoadBike</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startCadence,
                    <span class="hljs-keyword">int</span> startSpeed,
                    <span class="hljs-keyword">int</span> startGear,
                    <span class="hljs-keyword">int</span> newTireWidth)</span></span>{
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printDescription</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">super</span>.printDescription();
        System.out.println(<span class="hljs-string">"The RoadBike"</span> + <span class="hljs-string">" has "</span> + getTireWidth() +
            <span class="hljs-string">" MM tires."</span>);
    }
}
</code></pre>
<p>请注意，<code>printDescription</code>方法再次被重写。 除了<code>Bicycle</code>具有的属性外，这里还显示有关轮胎宽度的信息。</p>
<p>总而言之，我们有三类：父类<code>Bicycle</code>，以及并列的子类<code>MountainBike</code>和<code>RoadBike</code>。 这两个子类重写<code>printDescription</code>方法并打印各自不同的信息。</p>
<p>接着，我们写一个<code>TestBikes</code>类进行测试。</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBikes</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{
    Bicycle bike01, bike02, bike03;

    bike01 = <span class="hljs-keyword">new</span> Bicycle(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>);
    bike02 = <span class="hljs-keyword">new</span> MountainBike(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"Dual"</span>);
    bike03 = <span class="hljs-keyword">new</span> RoadBike(<span class="hljs-number">40</span>, <span class="hljs-number">20</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>);

    bike01.printDescription();
    bike02.printDescription();
    bike03.printDescription();
  }
}
</code></pre>
<p>则运行结果为：</p>
<pre><code>Bike is in gear 1 with a cadence of 20 and travelling at a speed of 10.

Bike is in gear 5 with a cadence of 20 and travelling at a speed of 10.
The MountainBike has a Dual suspension.

Bike is in gear 8 with a cadence of 40 and travelling at a speed of 20.
The RoadBike has 23 MM tires.
</code></pre><p><strong>如前所述，在Java中，方法调用总是由实际对象的类型决定的，而不是由对象引用的类型决定的。</strong></p>
<p><strong>在这个例子中，对象<code>bike01</code>, <code>bike02</code>, <code>bike03</code>所引用的类型都是<code>Bicycle</code>类，但他们实际所指的对象类型，则分别是<code>Bicycle</code>, <code>MountainBike</code>, <code>RoadBike</code>。</strong></p>
<p>可见，虽然我们有多个<code>printDescription</code>方法，但Java虚拟机（JVM）会为每个对象调用适当的方法。</p>
<p>是不是还是有点晕乎乎的呢？接下来的讲解会让大家更为明晰。💖</p>
<h2 id="再谈多态">再谈多态</h2>
<p>我们前文讲到</p>
<pre><code>在Java中，方法调用总是由实际对象指向的类型决定的，而不是由对象引用的类型决定的。

对象bike01, bike02, bike03所引用的类型都是Bicycle类，但他们实际所指的对象类型，则分别是Bicycle, MountainBike, RoadBike。
</code></pre><p>还记得吗？多态指的是一种，为，处在类继承层次结构（也就是一层一层的，从高到低的这种继承关系，一级一级的结构）中的具体对象（一个特定对象，处在类继承层次结构中特定的某一级别、某一层次）选择适当的方法的机制。比如我们在前面的例子中，我们的三个bike对象，分别处在三个不同的层次（一个在父类，两个在子类），然后，我们分别让这三个bike对象，调用了同一个方法名的方法<code>printDescription</code>。但是，同一个方法名的方法<code>printDescription</code>，实际上有三种不同的形态：<code>普通自行车(Bicycle)</code>形态，<code>山地自行车(MountainBike)</code>形态，以及<code>公路自行车(RoadBike)</code>形态。也就是说，这个<code>printDescription</code>方法，是具有多种形态的！<code>printDescription</code>这一个被两次重写过的方法，就被称为是多态的方法。</p>
<p>那么，当Java程序在执行时，具体执行<code>printDescription</code>这一多态方法的哪一种形态，则取决于，调用这一方法的对象，实际<strong>指向</strong>的对象类型（也就是在<code>new</code>语句后紧跟着的类型），而不是这一对象<strong>引用</strong>的对象类型（也就是在<code>new</code>语句中，实际对象前面的那个类型
）。例如，在语句</p>
<pre><code class="lang-java">Animal puppy = <span class="hljs-keyword">new</span> Dog();
</code></pre>
<p>中，实例对象<code>puppy</code>所引用的类型是<code>Animal</code>，而其实际指向的类型则是<code>Dog</code>。</p>
<p>再拿<code>代欧奇希斯</code>这只神奇宝贝来作个比喻：这是一种长得像外星人的两足神奇宝贝，拥有四种形态，各自注重不同的能力。但，这四种形都态具有共同特征，其躯体都为橘红色，面部都为蓝绿色，背部都有三个蓝绿色的点。</p>
<p><img src="ch05_1.png" alt="代欧奇希斯"></img></p>
<p>方法的多态性也就像这样，同一个行为具有多个不同表现形式或形态的能力。就如同蝴蝶拥有许多不同的发展形态一样。</p>
<p>让我们回到我们的自行车例子（不要跑偏到神奇宝贝了），来说明多态的存在，所需要的三个前提：</p>
<p><strong>1. 存在继承关系</strong></p>
<pre><code>`MountainBike`类与`RoadBike`类继承了`Bicycle`类。
</code></pre><p><strong>2. 子类要重写父类的方法</strong></p>
<pre><code>子类重写（Override)了父类的实例方法`printDescription`
</code></pre><p><strong>3. 对父类的引用指向子类对象</strong></p>
<p>测试类<code>TestBikes</code>中，语句</p>
<pre><code class="lang-java">Bicycle bike01, bike02, bike03;

bike01 = <span class="hljs-keyword">new</span> Bicycle(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>);
bike02 = <span class="hljs-keyword">new</span> MountainBike(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-string">"Dual"</span>);
bike03 = <span class="hljs-keyword">new</span> RoadBike(<span class="hljs-number">40</span>, <span class="hljs-number">20</span>, <span class="hljs-number">8</span>, <span class="hljs-number">23</span>);
</code></pre>
<p>将对于父类<code>Bicycle</code>的引用，指向了<code>Bicycle</code>, <code>MountainBike</code>, <code>RoadBike</code>这三个子类对象。</p>
<h2 id="类型转换">类型转换</h2>
<p>在AP CS A中，我们只需要掌握 <strong>向下转型（downcasting）</strong> 的概念。</p>
<p>考虑如下代码：</p>
<pre><code class="lang-java"><span class="hljs-comment">//假设getID()方法是GradStudent类中特有的一个public实例方法，没有在Student类中被定义，GradStudent类继承自Student类。</span>
Student student = <span class="hljs-keyword">new</span> GradStudent();
GradStudent gradstudent = <span class="hljs-keyword">new</span> GradStudent();
<span class="hljs-keyword">int</span> x = student.getID(); <span class="hljs-comment">//编译时错误</span>
<span class="hljs-keyword">int</span> y = gradstudent.getID(); <span class="hljs-comment">//正确</span>
</code></pre>
<p>我们可以看到，<code>student</code>与<code>gradstudent</code>两个实例对象，明明都指向着<code>GradStudent</code>这个类，为何</p>
<pre><code class="lang-java">student.getID()
</code></pre>
<p>会报错呢？</p>
<p>这是因为，尽管实例对象<code>student</code>实际指向的是<code>GradStudent</code>这个类，但其引用类型仍然为<code>Student</code>类，而<code>Student</code>类是没有定义一个<code>getID()</code>方法的。在编译时，只有<code>Student</code>类的非<code>private</code>类型的方法，才能使用点号运算符<code>.</code>应用于<code>student</code>对象。注意，这和我们之前提到的<code>多态</code>无关，因为它不满足我们讲过的，<code>多态</code>所应该具备的条件：我们没有为子类<code>GradStudent</code>重写过getID()方法。因此，这里的<code>getID()</code>方法，我们没有赋予它多态性。是故，其只能被用于<code>GradStudent</code>类中的实例对象。</p>
<p>那么，如果我们很需要为<code>student</code>对象使用<code>getID()</code>方法，怎么办呢？</p>
<p>我们可以对<code>student</code>对象进行<code>转型(casting)</code>，将其强行转为正确的引用类型：</p>
<pre><code class="lang-java"> <span class="hljs-keyword">int</span> x = ((GradStudent) student).getID();
</code></pre>
<p>因为<code>student</code>本已是一个指向<code>GradStudent</code>类的对象，只不过其引用对象仍为<code>Student</code>，我们的转型可以顺利完成。</p>
<p>像这样的，把一个子类引用指向父类对象的转型过程，称作<code>向下转型</code>。</p>
<p>在这个例子中，子类引用就是子类<code>GradStudent</code>中的引用方法<code>getID()</code>，我们将其强行指向父类对象<code>student</code>，使之能够被<code>student</code>对象合法地调用。</p>
<h2 id="动态绑定">动态绑定</h2>
<p>动态绑定（Dynamic bonding)，指的是，当存在方法重写时，关于调用哪一个实例方法的决定，是在Java程序运行时(run-time)（Java虚拟机JVM实时解析运行Java字节码时）才实时作出的。也就是说，这一个决定是在程序运行时，才实时、动态地作出的。</p>
<p>与之相对的是，当存在方法重载时，关于调用哪一个实例方法的决定，是在Java程序编译时(compile-time)就已经做好的、固化了的，一成不变的的决定，这一种类型被称为静态绑定(Static bonding)。</p>
<p>在静态绑定中，编译器会通过分析比较实例方法的签名特点、逻辑层次归属等等，来选择正确的方法重载，并且一旦选择完毕，就在编译时将这样的绑定关系定死了，不可能再改变了。</p>
<p>而在多态的实现中，当遭遇到方法重写，最终哪一个实例方法会被调用这个决定，不是由编译器在编译时决定的。</p>
<p>在动态绑定的过程中，编译器所做的事情是，判断一个方法能否被合法地调用。而，运行时环境（Java虚拟机JVM）才是最终作出关于究竟要调用被重写的方法中的哪一个实例方法的决定的那个角色。
来看下面这个例子：</p>
<p><img src="ch05_2.png" alt="DB"></img></p>
<p>当这一段代码在运行的时候，<code>speak()</code>方法的具体选择，会根据调用该方法的具体对象类型而定。</p>
<p>再来看巴朗教材中的一段例子：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentTest</span>
</span>{
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeAllGrades</span><span class="hljs-params">(Student[] studentList)</span>
</span>{
<span class="hljs-keyword">for</span> (Student s : studentList)
<span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)
s.computeGrade();
}
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>
</span>{
Student[] stu = <span class="hljs-keyword">new</span> Student[<span class="hljs-number">5</span>];
stu[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Brian Lorenzen"</span>,
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {<span class="hljs-number">90</span>,<span class="hljs-number">94</span>,<span class="hljs-number">99</span>}, <span class="hljs-string">"none"</span>);
stu[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> UnderGrad(<span class="hljs-string">"Tim Broder"</span>,
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {<span class="hljs-number">90</span>,<span class="hljs-number">90</span>,<span class="hljs-number">100</span>}, <span class="hljs-string">"none"</span>);
stu[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> GradStudent(<span class="hljs-string">"Kevin Cristella"</span>,
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] {<span class="hljs-number">85</span>,<span class="hljs-number">70</span>,<span class="hljs-number">90</span>}, <span class="hljs-string">"none"</span>, <span class="hljs-number">1234</span>);
computeAllGrades(stu);
}
}
</code></pre>
<p>这里我们创建了一个包含长度为<code>5</code>的<code>Student</code>数组，它们最初都是都是空的。 其中的三个数组对象<code>stu[0]</code>, <code>stu[1]</code>, <code>stu[2]</code>，接着被指向三个具体的实例对象。</p>
<p><code>computeAllGrades</code>方法遍历数组，为每个对象调用相应的<code>computeGrade</code>方法，在每种情况下都使用动态绑定。 对<code>computeAllGrades</code>方法进行空测试是必需的，因为某些数组引用可能为空。</p>
<h2 id="使用super调用父类">使用“super”调用父类</h2>
<p>使用<code>super</code>关键字，我们能够使得一个子类，调用处在其父类中的一个方法。大家可能会感到疑惑，我们前面不是讲到，一个子类继承了父类以后，这个子类就继承分享了，其父类的属性和方法了吗？比如，</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mammal</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>{
        System.out.println(<span class="hljs-string">"I can eat!"</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mammal</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>{
        Dog puppy = <span class="hljs-keyword">new</span> Dog();
        puppy.eat();
    }
}
</code></pre>
<p>在上述代码中，我们不用<code>super</code>关键字，就可以使用父类中的<code>eat()</code>方法。那么，<code>super</code>关键字在什么时候会派上用场呢？</p>
<p>答案是：当出现方法重写时。</p>
<p><strong>如果在子类中，我们对一个方法进行了重写，则重写过的方法默认覆盖过了父类中的同名方法，但若我们就是想使用父类中的，被重写过的，那一个原本的方法，那我们就可以通过使用关键字<code>super</code>来调用被重写过(Overridden)的方法。</strong></p>
<p>比方说：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superclass</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMethod</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Printed in Superclass."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subclass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Superclass</span> </span>{

    <span class="hljs-comment">// overrides printMethod in Superclass</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMethod</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.printMethod();
        System.out.println(<span class="hljs-string">"Printed in Subclass."</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Subclass s = <span class="hljs-keyword">new</span> Subclass();
        s.printMethod();    
    }
}
</code></pre>
<p>在这个例子中，我们的<code>printMethod</code>在子类<code>Subclass</code>中被重写过了一次。如果我们像前面<code>Dog</code>类那个例子一样，仅仅使用点号运算符<code>.</code>在子类中去调用这个，则根据我们在<code>方法重写</code>那一章节讲的规则，Java程序默认会选择使用重写过的方法，也就是子类中的那一个<code>printMethod</code>方法，而非父类中原本的<code>printMethod</code>方法。因此，若我们想要在子类中使用父类中的<code>printMethod</code>方法，而非子类中的<code>printMethod</code>方法，我们必须使用<code>super</code>进行强行声明。</p>
<p>上述程序的运行结果为:</p>
<pre><code>Printed in Superclass.
Printed in Subclass.
</code></pre><p>原因是，Java程序首先从子类<code>Subclass</code>中的<code>main()</code>方法开始执行，实例对象<code>s</code>将会优先调用子类中的<code>printMethod()</code>方法，在这个方法中有两行语句。第一行语句</p>
<pre><code class="lang-java"><span class="hljs-keyword">super</span>.printMethod();
</code></pre>
<p>中的<code>super</code>关键字，将会强行声明，我们这里要使用的是父类中的<code>printMethod</code>方法，于是Java运行环境（Java虚拟机JVM）将会去试图寻找并执行类继承层次结构上，这个子类上一级别的父类中的<code>printMethod</code>方法，于是，这一行语句调用了父类<code>Superclass</code>中的<code>printMethod</code>方法，打印出第一行结果：</p>
<pre><code>Printed in Superclass.
</code></pre><p>注意，这里其实是在执行子类中的<code>printMethod()</code>方法，只不过在执行的过程中，<code>super</code>关键字使得程序流程"灵魂出窍"一样，暂时去了更高一个类，执行完这一行语句后，Java虚拟机JVM紧接着执行的仍然是子类中的<code>printMethod()</code>方法  的下一行语句</p>
<pre><code class="lang-java">System.out.println(<span class="hljs-string">"Printed in Subclass."</span>);
</code></pre>
<p>打印出第二行结果：</p>
<pre><code>Printed in Subclass.
</code></pre><h2 id="super与构造方法">“super”与构造方法</h2>
<p>构造方法是永远不会被继承的！ 如果我们没有显式地为子类编写构造函数，Java虚拟机JVM会为子类自动生成不带参数的默认构造函数。</p>
<p><code>super</code>关键字还可以被用于在子类中调用(invoke)父类中的构造方法(constructor)。回想一下我们前面提过的<code>Bicycle</code>类的例子，在那个例子中，<code>MountainBike</code>类是<code>Bicycle</code>类的子类。</p>
<p>下面这段代码展示的是在那个例子中，子类<code>MountainBike</code>中的构造方法，通过<code>super</code>关键字，调用了父类的构造方法。</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MountainBike</span><span class="hljs-params">(<span class="hljs-keyword">int</span> startHeight, <span class="hljs-keyword">int</span> startCadence, <span class="hljs-keyword">int</span> startSpeed, <span class="hljs-keyword">int</span> startGear)</span>
</span>{
    <span class="hljs-keyword">super</span>(startCadence, startSpeed, startGear);
}
</code></pre>
<p>在子类中使用<code>super</code>调用父类中的构造方法的语法是:</p>
<pre><code class="lang-java"><span class="hljs-keyword">super</span>();
</code></pre>
<p>或：</p>
<pre><code class="lang-java"><span class="hljs-keyword">super</span>(parameter1, parameter2, ...）;
</code></pre>
<p>若使用<code>super();</code>, 父类中不带传入参数列表的构造方法将会被调用。当使用带传入参数的 <code>super</code>关键字，例如</p>
<pre><code class="lang-java"><span class="hljs-keyword">super</span>(parameter1, parameter2, ...);
</code></pre>
<p>则父类中具有匹配的传入参数列表的构造函数将会被调用。</p>
<p><strong>注意：</strong>Java里有一个特殊要求，就是我们在构造器里面调用<code>super()</code>的时候，<code>super()</code>必须要<strong>在构造器里的第一行</strong>。比如这个类里面的构造器是可以编译的：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SavingsAccount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BankAccount</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> interestRate;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavingsAccount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>();
        interestRate = <span class="hljs-number">0</span>;
    }
}
</code></pre>
<p>而这个类里的构造器不行：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SavingsAccount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BankAccount</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> interestRate;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavingsAccount</span><span class="hljs-params">()</span> </span>{
        interestRate = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">super</span>();
    }
}
</code></pre>
<h2 id="考试技巧">考试技巧</h2>
<p>ClassCastException出现情况&amp;Downcasting类型转化可以发生的情况。</p>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">a</span></span>{
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">b</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">a</span></span>{
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">c</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">b</span></span>{
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">e</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">b</span></span>{
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">d</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">c</span></span>{
}

a x =<span class="hljs-keyword">new</span> d()
<span class="hljs-comment">//(b)x,(c)x,(d)x 都可以</span>
<span class="hljs-comment">//(e)x 会出现ClassCastException错误 </span>
b x = <span class="hljs-keyword">new</span> c()
<span class="hljs-comment">// (d)x, (a)x 会出现ClassCastException错误</span>
a x = <span class="hljs-keyword">new</span> e()
<span class="hljs-comment">//(b)x,(e)x 都可以</span>
<span class="hljs-comment">//其他如(d)x会出现ClassCastException错误</span>
</code></pre>
<p>也就是说在转换类型的时候, 继承关系是 a &lt;- b &lt;- c &lt;- d &amp; b &lt;- e
<img src="ch05_3.png" alt="继承关系"></img>
(下面的O,P,I 都代表一个不同的类名)</p>
<p>那么 在使用 <code>O x = new P();</code> (O,P 是a到d那一条继承关系链中的一种(e不能包括,因为d没有继承e) 且 O&gt;=P)</p>
<p>downcasting向下转换 <code>(I) x;</code> 只有在 P &lt;= I &lt;= O 时不会出错，反之会抛出 ClassCastException 错误。</p>
<h2 id="小练习">小练习</h2>
<p><strong>Answering question 1 requires you to read the following code:</strong></p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BankAccount</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> balance;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BankAccount</span><span class="hljs-params">()</span> </span>{
        balance = <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BankAccount</span><span class="hljs-params">(<span class="hljs-keyword">double</span> acctBalance)</span> </span>{
        balance = acctBalance;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deposit</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span> </span>{
        balance += amount;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(<span class="hljs-keyword">double</span> amount)</span> </span>{
        balance -= amount;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> balance;
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SavingsAccount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BankAccount</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> interestRate;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavingsAccount</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">/* implementation not shown */</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SavingsAccount</span><span class="hljs-params">(<span class="hljs-keyword">double</span> acctBalance, <span class="hljs-keyword">double</span> rate)</span> </span>{
        <span class="hljs-comment">/* implementation not shown */</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterest</span><span class="hljs-params">()</span> <span class="hljs-comment">//Add interest to balance</span>
    </span>{
        <span class="hljs-comment">/* implementation not shown */</span>
    }
}
</code></pre>
<p>1.Which of the following correctly implements the default constructor of the <code>SavingsAccount</code> class?</p>
<p>I interestRate = 0;
super();</p>
<p>II super();
interestRate = 0;</p>
<p>III super();</p>
<p>(A) II</p>
<p>(B) I and II only</p>
<p>(C) II and III only</p>
<p>(D) III only</p>
<p>(E) I, II, and III</p>
<cr type="hidden">C

解析：这道题的考点是一个特殊情况，就是`super()`无论如何要在构造器的第一行，因此I是不行的，III看起来不行（没有初始化`interestRate`），但实际上，因为`interestRate`是一个`double`类型的变量，它会有默认值`0.0`，因此不初始化也可以的（如果这个变量是引用类型，这个变量的值就会是`null`）。</cr>

<p>2.【2014年AP CS第22题】</p>
<p>Consider the following Book and AudioBook classes.</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>
</span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numPages;
  <span class="hljs-keyword">private</span> String bookTitle;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pages. String title)</span>
  </span>{
  numPages = pages;
  bookTitle = title;
  }

  <span class="hljs-keyword">public</span> String toStringO
  {
    <span class="hljs-keyword">return</span> bookTitle + <span class="hljs-string">" "</span> + numPages;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-keyword">return</span> numPages;
  }
}


<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AudioBook</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Book</span>
</span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numMinutes;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AudioBook</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minutes, <span class="hljs-keyword">int</span> pages. String title)</span>
  </span>{
    <span class="hljs-keyword">super</span>(pages, title); numMinutes = minutes;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-keyword">return</span> numMinutes;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">pagesPerMinute</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">double</span>) <span class="hljs-keyword">super</span>.length()) / numMinutes;
  }
}
</code></pre>
<p>Consider the following code segment that appears in a class other than Book or AudioBook.</p>
<pre><code class="lang-java">Line1: Book[] books = <span class="hljs-keyword">new</span> Book[<span class="hljs-number">2</span>];
Line2: books[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> AudioBook(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>, <span class="hljs-string">"the Jungle"</span>);
Line3: books[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Book(<span class="hljs-number">400</span>, <span class="hljs-string">"Captains Courageous"</span>);
Line4: System.out.println(books[<span class="hljs-number">0</span>].pagesPerMinute());
Line5: System.out.println(books[<span class="hljs-number">0</span>].toString());
Line6: System.out.println(books[<span class="hljs-number">0</span>].length());
Line7: System.out.println(books[<span class="hljs-number">1</span>].toString());
</code></pre>
<p>Which of the following best explains why the code segment will not compile?</p>
<p>(A) Line 2 will not compile because variables of type Book may not refer to variables of type AudioBook</p>
<p>(B) Line 4 will not compile because variables of type Book may only call methods in the Book cl</p>
<p>(C) Line 5 will not compile because the AudioBook class does not have a method named toString declared or implemented.</p>
<p>(D) Line 6 will not compile because the statement is ambiguous. The compiler cannot determine which
length method should be called.</p>
<p>(E) Line 7 will not compile because the element at index 1 in the array named books may not have been
initialized.</p>
<cr type="hidden">B</cr>

<p>A program to test the BankAccount, SavingsAccount, and CheckingAccount classes has
these declarations:</p>
<pre><code class="lang-java">BankAccount b = <span class="hljs-keyword">new</span> BankAccount(<span class="hljs-number">1400</span>);

BankAccount s = <span class="hljs-keyword">new</span> SavingsAccount(<span class="hljs-number">1000</span>, <span class="hljs-number">0.04</span>);

BankAccount c = <span class="hljs-keyword">new</span> CheckingAccount(<span class="hljs-number">500</span>);
</code></pre>
<p>3.Which method call will cause an error?</p>
<p>(A) b.deposit(200);</p>
<p>(B) s.withdraw(500);</p>
<p>(C) c.withdraw(500);</p>
<p>(D) s.deposit(10000);</p>
<p>(E) s.addInterest();</p>
<p>4.In order to test polymorphism, which method must be used in the program?</p>
<p>(A) Either a SavingsAccount constructor or a CheckingAccount constructor</p>
<p>(B) addInterest</p>
<p>(C) deposit</p>
<p>(D) withdraw</p>
<p>(E) getBalance</p>
<p>Multiple-Choice Questions on Inheritance and Polymorphism 153</p>
<p>5.Which of the following will not cause a ClassCastException to be thrown?</p>
<p>(A) ((SavingsAccount) b).addInterest();</p>
<p>(B) ((CheckingAccount) b).withdraw(200);</p>
<p>(C) ((CheckingAccount) c).deposit(800);</p>
<p>(D) ((CheckingAccount) s).withdraw(150);</p>
<p>(E) ((SavingsAccount) c).addInterest();</p>
<p><cr type="hidden">E, D, C</cr></p>
<h3 id="实验室">实验室</h3>
<p>在这里练习吧：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
   public static void main(String[] args) {
     // 在这里添加你的代码
   }
}
&lt;/lab&gt;
</code></pre>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch04.html" class="navigation navigation-prev " aria-label="Previous page: csa Chapter4">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch06.html" class="navigation navigation-next " aria-label="Next page: csa Chapter6">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"csa Chapter5","level":"1.6","depth":1,"next":{"title":"csa Chapter6","level":"1.7","depth":1,"path":"ch06.md","ref":"ch06.md","articles":[]},"previous":{"title":"csa Chapter4","level":"1.5","depth":1,"path":"ch04.md","ref":"ch04.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"ch05.md","mtime":"2024-01-02T10:19:23.802Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:24:44.418Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

