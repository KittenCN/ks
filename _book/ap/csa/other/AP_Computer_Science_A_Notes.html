
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>AP_Computer_Science_A_Notes · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="AP_Computer_Science_A_Subset.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="AP_Computer_Science_A_Quick_Reference.html">
            
                <a href="AP_Computer_Science_A_Quick_Reference.html">
            
                    
                    AP_Computer_Science_A_Quick_Reference
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="AP_Computer_Science_A_Subset.html">
            
                <a href="AP_Computer_Science_A_Subset.html">
            
                    
                    AP_Computer_Science_A_Subset
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4" data-path="AP_Computer_Science_A_Notes.html">
            
                <a href="AP_Computer_Science_A_Notes.html">
            
                    
                    AP_Computer_Science_A_Notes
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >AP_Computer_Science_A_Notes</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="ap-computer-science-a-学习笔记">AP Computer Science A 学习笔记</h1>
<h2 id="java-语法">Java 语法</h2>
<p>(1) 布尔值叫 <code>boolean</code>，只能是 <code>true</code> 或 <code>false</code>，没有非 <code>0</code> 即 <code>true</code> 的概念。<code>boolean</code> 不能强转 <code>int</code>，实在要转可以用三目运算符。<code>if (...)</code> 里面只能是布尔值。  </p>
<p>(2) <code>int</code> 可以自动转 <code>double</code>，<code>double</code> 不能自动转 <code>int</code>，如：  </p>
<pre><code class="lang-java"><span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>;  
<span class="hljs-keyword">double</span> d = x; <span class="hljs-comment">// 可以  </span>
x = d; <span class="hljs-comment">// ERROR  </span>
x = (<span class="hljs-keyword">int</span>)d; <span class="hljs-comment">// 可以。强转：丢弃小数部分</span>
</code></pre>
<p>(3) <code>int</code> 型的范围是$[-2^{31}, 2^{31} - 1]​$ 。可以用 <code>Integer.MIN_VALUE</code>$-2^{31}​$ 和 <code>Integer.MAX_VALUE</code>$2^{31} - 1​$ 来查看。  </p>
<p>(4) 常量叫 <code>final</code>，类似于 C++的 <code>const</code>。  </p>
<p>(5) 可以小数模小数。如：<code>4.2 % 1.5</code> 结果是 <code>1.2</code>。  </p>
<h2 id="类与对象（classes-and-objects）">类与对象（Classes and Objects）</h2>
<p>(1) AP 中，类全部都是 <code>public</code> 的。  </p>
<p>(2) AP 中，类里只有两种变量，一种是 <code>private</code>，一种是 <code>public static</code>。常量一般是 <code>public static final</code>。<code>public</code> 的数据都可以在类外面直接访问，<code>private</code> 的数据只能借助类里的方法（method）访问。<code>static</code> 的数据只会被创建一次，是所有实例（instances）<strong>共用</strong>的，例如可以当计数器来用，记录这个类一共被创建过多少个实例。  </p>
<p>(3) AP 中，类里只有三种方法：<code>private</code>，<code>public</code>，和 <code>public static</code>。<code>public static</code> 方法不针对任何实例，不能访问任何非 <code>static</code> 的变量（因为你不知道访问哪个对象的），也不能调用任何非 <code>static</code> 的方法（instance method）。如果有 <code>main</code> 函数，它必须是 <code>static</code> 的，且它所在类里的所有方法也必须是 <code>static</code> 的。AP 中认为 <code>static</code> 的方法只能用 <code>类名.方法名</code> 的形式访问，<strong>不能用 **</strong>实例名.方法名<strong>** 的形式访问</strong>。  </p>
<p>(4) constructor 前面必须写 <code>public</code>，如：  </p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> </span>{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cat</span><span class="hljs-params">()</span> </span>{}  
}
</code></pre>
<p>(5) method overloading：同一个类中，多个方法名字相同，参数不同。注意，必须是参数不同，而不是返回值不同。事实上返回值可以相同也可以不同，与此处无关。  </p>
<p>(6) <code>this</code> 表示当前对象。在非 <code>static</code> 的方法（包括 constructor）里，非 <code>static</code> 的数据和方法前都可以加 <code>this.</code>。如：  </p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rational</span> </span>{  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> denom;  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rational</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> denom)</span> </span>{  
        <span class="hljs-keyword">this</span>.num = num;  
        <span class="hljs-keyword">this</span>.denom = denom; <span class="hljs-comment">// 变量重名时，可以用 this 来区分局部变量和类的数据  </span>
    }  
}
</code></pre>
<p>(7) <code>int</code>, <code>double</code>, <code>boolean</code> 是基本类型，其他的对象和数组都是 reference 类型，如：<code>String</code>, <code>int[]</code>, <code>String[][]</code>, <code>Cat</code>（我们自己定义的）等。  </p>
<p>(8) 局部变量没有初始化会<strong>在编译时就报错</strong>（compile-time error）。类和数组里的数据如果不初始化，JavaJava 会自动将其赋为默认值，<code>int</code> 等的默认值是 <code>0</code>，<code>boolean</code> 的默认值是 <code>false</code>，reference 的默认值是 <code>null</code>（注意：<code>String</code> 的默认值也是 <code>null</code>，而不是空串）。  </p>
<p>(9) 传参时，如果传的是基本类型，则是一份传过去，无论方法里如何操作，外面的实参不会改变。如果传的是 reference 类型，则把指针一份，此时是<strong>两根指针指向同一个对象</strong>。实参的地址不变，内容有可能改变。  </p>
<h2 id="继承与多态（inheritance-and-polymorphism）">继承与多态（Inheritance and Polymorphism）</h2>
<p>(1) 每个类只能有一个父类。多个类可以有同一个父类。可以多层继承，最后形成一个树形结构。  </p>
<p>(2) A 继承 B（A 是 subclass，B 是 superclass），则逻辑上需要满足“A <strong>is a</strong> B”的关系。比如：an <code>Employee</code> is a <code>Person</code>，a <code>Student</code> is a <code>Person</code>，a <code>GradStudent</code> is a <code>Student</code>。否则即使有这种需要，在 AP 考试里也认为不能用继承，比如说下面这段代码就被认为是错的：  </p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tire</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Circle</span> </span>{  
    ...  
    <span class="hljs-comment">// inherits methods that compute circumference and center point  </span>
}
</code></pre>
<p>官方答案说，tire 是一个汽车部件，而 circle 是一个几何图形，所以不能说 tire is a circle。  </p>
<p>(3) 子类继承父类的所有 <code>public</code> 的变量和方法，<strong>不继承</strong> <code>private</code> 的变量和方法，但可以通过父类的 <code>public</code> 方法间接访问。（AP 中不考虑 <code>protected</code>）。  </p>
<p>(4) 子类的变量如果和从父类继承的变量重名，则在子类里默认该名字指子类里的变量，如果要访问父类的变量可以用 <code>super.xxx</code>。子类里这个变量是 <code>public</code> 还是 <code>private</code> 都没关系。  </p>
<p>(5) 子类可以重写从父类继承的方法，称为 method overriding（区分于 method overloading）。在重写时可以调用父类的同一方法，用法是 <code>super.xxx()</code>，称为 partial overriding。父类的 <code>private</code> 方法是不能被 overridden 的，因为它们根本没有被继承。所以总结来说就是：进行 overriding 时，<strong>父类和子类里的这个方法都必须是 **</strong>public<strong>** 的</strong>。此外，在 overriding 中，子类方法和父类方法的<strong>返回值类型必须相同</strong>，否则就不是 overriding。如果子类里有一个方法，和父类继承来的方法名字相同、参数类型相同，但返回值类型不同，会发生编译错误。  </p>
<p>(6) constructor 不继承。子类的 constructor 里，第一句话应先写 <code>super(...);</code>，即调用父类的 constructor。**<code>super</code> 只能写在第一句话里**。如果不写，JavaJava 默认帮你写一个 <code>super();</code>，此时如果父类里没有 default constructor（不带变量的 constructor），会发生编译错误。如果父类一个 consturctor 都没有，JavaJava 会帮你写一个 default constructor，那么此时还是可以调用 <code>super();</code> 的。如果子类一个 consturctor 都没有，JavaJava​ 会帮你写一个 default constructor，里面只有一句话，就是：<code>super();</code>。也就是说，如果父类和子类都没有 constructor，不会发生编译错误。  </p>
<p>(7) <strong>父类 reference 可以指向子类对象</strong>，反过来不可以。例如：  </p>
<pre><code class="lang-java"><span class="hljs-comment">// Student 是父类，GradStudent 和 UnderGrad 是子类。  </span>
Student s = <span class="hljs-keyword">new</span> Student();     <span class="hljs-comment">// 正确  </span>
Student g = <span class="hljs-keyword">new</span> GradStudent(); <span class="hljs-comment">// 正确  </span>
Student u = <span class="hljs-keyword">new</span> UnderGrad();   <span class="hljs-comment">// 正确  </span>
GradStudent g = <span class="hljs-keyword">new</span> Student(); <span class="hljs-comment">// 错误</span>
</code></pre>
<p>当父类 reference 指向子类对象时，这个对象（这个 reference）<strong>只能调用父类里有的方法</strong>。但是<strong>如果这个方法被重写过，调用的是重写后的版本</strong>（也就是子类里的版本）。也就是说，某个方法能不能调用，取决于 the type of object reference（左边的），这是在编译时决定的；调用的具体是什么，取决于 the type of actual object（右边的），这是在运行时决定的。这种特性就被称为多态。注意，只有 overriding 会导致多态，也就是在运行是决定用哪个（也叫 dynamic binding 或 late binding）；overloading 不是多态，因为在编译时就决定好了（也叫 static binding 或 early binding）。  </p>
<p>关于多态有什么用，可以看下面这份代码：  </p>
<pre><code class="lang-java">Student s = <span class="hljs-keyword">null</span>;  
Student u = <span class="hljs-keyword">new</span> UnderGrad(...);  
Student g = <span class="hljs-keyword">new</span> GradStudent(...);  
String str = ...; <span class="hljs-comment">// read user input  </span>
<span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">"G"</span>)) {  
    s = g;  
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">"U"</span>)) {  
    s = u;  
} <span class="hljs-keyword">else</span> {  
    s = <span class="hljs-keyword">new</span> Student();  
}  
s.computeGrade(); <span class="hljs-comment">// 在运行时才知道具体调用的是哪个</span>
</code></pre>
<p>(8) 如果子类对象调用了某个被 partial overridden 的函数，通过函数里的 <code>super.xxx();</code> 回到了父类，在父类的这个函数里继续调用另一个被 overridden 过的函数，此时调用的还是子类里的。如：  </p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dancer</span> </span>{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">act</span><span class="hljs-params">()</span> </span>{  
        System.out.println(<span class="hljs-string">"spin"</span>);  
        doTrick();  
    }  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTrick</span><span class="hljs-params">()</span> </span>{  
        System.out.println(<span class="hljs-string">"float"</span>);  
    }  
}  
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Acrobat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dancer</span> </span>{  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">act</span><span class="hljs-params">()</span> </span>{  
        <span class="hljs-keyword">super</span>.act(); <span class="hljs-comment">// partial overriding  </span>
        System.out.println(<span class="hljs-string">"flip"</span>);  
    }  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doTrick</span><span class="hljs-params">()</span> </span>{  
        System.out.println(<span class="hljs-string">"somersault"</span>);  
    }  
}  

---main()---  
Dancer a = <span class="hljs-keyword">new</span> Acrobat();  
a.act();
</code></pre>
<p>该程序输出的结果是：  </p>
<pre><code class="lang-java">spin  
somersault  
flip
</code></pre>
<p>(9) 在父类 reference 指向子类对象时，不能调用只在子类里有的方法，如果非要调用，则需要进行 casting。具体写法如下：  </p>
<pre><code class="lang-java"><span class="hljs-comment">// getID() 是一个只在 GradStudent 里有的方法，父类 Student 里没有  </span>
Student s = <span class="hljs-keyword">new</span> GradStudent();  
<span class="hljs-keyword">int</span> x = s.getID(); <span class="hljs-comment">// 错误  </span>
<span class="hljs-keyword">int</span> x = ((GradStudent)s).getID(); <span class="hljs-comment">// casting，正确的  </span>
<span class="hljs-keyword">int</span> x = (GradStudent)s.getID(); <span class="hljs-comment">// 错误，点的优先级比 casting 高</span>
</code></pre>
<p>(10) 向方法传参时，规则和赋值是类似的。必须满足“实参 is a 形参”的关系。如果形参是父类，直接传就可以；如果形参是子类，实参是父类 reference 指向子类对象，那么需要 casting。  </p>
<h2 id="一些标准类">一些标准类</h2>
<h3 id="object-类"><code>Object</code> 类</h3>
<p>(1) JavaJava​ 中，如果没有定义父类，则默认继承 <code>Object</code>。也就是说，所有继承关系是一棵树（而不是一个森林），<code>Object</code> 是这棵树的根节点。  </p>
<p>(2) <code>public String toString()</code> 是 <code>Object</code> 类的一个方法，它返回一个形如 <code>类名@地址</code> 的字符串，其中地址看上去就是一串无规则的字符。需要时，可以自己 override <code>toString</code> 方法。使用 <code>System.out.print(xxx)</code> 时，会调用该对象 <code>xxx</code> 的 <code>toString</code> 方法。当某个对象和字符串拼接时，也会调用该对象的 <code>toString</code> 方法，如 <code>"abc" + xxx</code> 就相当于 <code>"abc" + xxx.toString()</code>。当然，也可以自己主动调用 <code>toString</code>。  </p>
<p>(3) <code>public boolean equals(Object other)</code> 是 <code>Object</code> 类的一个方法。它判断 <code>other</code> 和当前对象是否是<strong>同一个对象</strong>。注意，“同一个对象”指的是指向同一块内存区域，而不仅仅是内容相同。JavaJava 中 <code>==</code> 也是判断两者是否是同一个对象。所以未被 overridden 时，<code>equals</code> 和 <code>==</code> 意思一样。例如：  </p>
<pre><code class="lang-java">Date d1 = <span class="hljs-keyword">new</span> Date(<span class="hljs-string">"June"</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1989</span>);  
Date d2 = d1; <span class="hljs-comment">// 两个 reference 指向同一个对象  </span>
Date d3 = <span class="hljs-keyword">new</span> Date(<span class="hljs-string">"June"</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1989</span>);  

<span class="hljs-keyword">boolean</span> b1 = d1.equals(d2); <span class="hljs-comment">// true  </span>
<span class="hljs-keyword">boolean</span> b2 = d1.equals(d3); <span class="hljs-comment">// false，虽然内容相同，但不是同一个对象  </span>
<span class="hljs-keyword">boolean</span> b3 = (d1 == d2);    <span class="hljs-comment">// true  </span>
<span class="hljs-keyword">boolean</span> b4 = (d1 == d3);    <span class="hljs-comment">// false</span>
</code></pre>
<h3 id="string-类"><code>String</code> 类</h3>
<p>(1) <code>String</code> 是 JavaJava​ 自带的类。直接在代码里打出来的字符串，如 <code>"AvavaAva"</code>，被称为 string literals，它们都是 <code>String</code> 的实例。<code>String s = "abc";</code> 等价于 <code>String s = new String("abc");</code>。  </p>
<p>(2) <code>String</code> 对象是 <strong>immutable</strong> 的，也就是说一旦被创建，就不能更改。但是可以 <strong>reassign a **</strong>String<strong>** reference</strong>，如：  </p>
<pre><code class="lang-java">String s = <span class="hljs-string">"Diana"</span>;  
s = <span class="hljs-string">"Ava"</span>;  
s = s + <span class="hljs-string">" is your father?!"</span>;  
System.out.print(s); <span class="hljs-comment">// Ava is your father?!</span>
</code></pre>
<p>注意，上面的代码中，<code>"Diana"</code> 和 <code>"Ava"</code> 没有被改变，它们只是被直接丢弃了。  </p>
<p>因为 <code>String</code> 是 immutable 的，所以 <code>String.xxx()</code> 这种方法都不会改变原串，只是返回一个新串。考试时可能给你一个你没见过的方法，比如 <code>s.toUpperCase();</code>，此时你要知道 <code>s</code> 里的内容没有被改变。只有 <code>s = s.toUpperCase();</code> 这样才会把 <code>s</code> 换掉。  </p>
<p>(3) 注意区分空指针（<code>null</code>）和空串（<code>""</code>）。如果 <code>String s</code> 是某个类的数据且未被初始化，那么默认是空指针，等价于初始化 <code>s = null;</code>。<code>s = new String();</code> 得到的是空串，等价于 <code>s = "";</code>。<strong>空指针也是可以被打印的</strong>，<code>s = null; System.out.print(s);</code> 会输出 <code>null</code>。  </p>
<p>(4) 字符串 <code>+</code>：<code>+</code> 左右两边只要有任意一边是 <code>String</code> 类型的，就会自动调用另一边的 <code>toString</code> 方法。如：  </p>
<pre><code class="lang-java"><span class="hljs-keyword">int</span> x = <span class="hljs-number">3</span>, y = <span class="hljs-number">4</span>;  
String s1 = x + y + <span class="hljs-string">"abc"</span>; <span class="hljs-comment">// 7abc  </span>
String s2 = x + (y + <span class="hljs-string">"abc"</span>); <span class="hljs-comment">// 34abc  </span>
String s3 = x + y; <span class="hljs-comment">// ERROR，不能把 int 赋给 String</span>
</code></pre>
<p>(5) <code>String</code> 类的 <code>equals</code> 方法被 overridden 过，比较两个串内容是否一样。<code>==</code> 仍然是判断是否是同一个对象。<code>s1.compareTo(s2)</code> 返回一个 <code>int</code>，若 <code>s1</code> 字典序较小则返回负数，若 <code>s1</code> 字典序较大则返回正数，若两串相等返回 <code>0</code>。ASCII 码的大小顺序是<strong>数字 &lt;&lt; 大写字母 &lt;&lt;​ 小写字母</strong>。假设 <code>s1</code> 不为空指针，<code>s2</code> 为空指针，那么 <code>s1.equals(s2)</code> 和 <code>s1 == s2</code> 能正常执行并返回 <code>false</code>，<code>s1.compareTo(s2)</code> 则会发生 <code>NullPointerException</code>。  </p>
<p>(6) <strong>所有相同的 string literals 是同一个对象</strong>，所以用 <code>==</code> 比较时也是相同的。例如：  </p>
<pre><code class="lang-java">String s1 = <span class="hljs-string">"ray"</span>;  
String s2 = <span class="hljs-string">"ray"</span>;  
String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"ray"</span>);  

<span class="hljs-keyword">boolean</span> b1 = (s1 == s2);    <span class="hljs-comment">// true  </span>
<span class="hljs-keyword">boolean</span> b2 = (s1 == s3);    <span class="hljs-comment">// false  </span>
<span class="hljs-keyword">boolean</span> b3 = s1.equals(s3); <span class="hljs-comment">// true</span>
</code></pre>
<p>(7) <code>length()</code>：返回字符串长度。  </p>
<p>(8) <code>substring(l, r)</code>：返回左闭右开区间 $[l, r)$ 的子串，要求$0\leq l\leq r \leq \texttt{s.length()}$  。其中$l = r$   时返回空串。也可以只传一个参数 <code>l</code>，此时默认 <code>r = s.length()</code>。  </p>
<p>(9) <code>indexOf(s)</code>：传进去一个字符串 <code>s</code>，返回该串里 <code>s</code> 第一次出现的位置（开头位置）。若该串里没有 <code>s</code> 则返回 <code>-1</code>。  </p>
<h3 id="封装类（wrapper-classes）">封装类（Wrapper Classes）</h3>
<p>(1) 把基本类型 <code>int</code>, <code>double</code> 封装成对象类型 <code>Integer</code> 和 <code>Double</code>。示意代码如下：  </p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> </span>{  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_VALUE = <span class="hljs-number">2147483647</span>;  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_VALUE = -<span class="hljs-number">2147483648</span>;  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _x)</span> </span>{ x = _x; }  <span class="hljs-comment">// boxing  </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">intValue</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> x; } <span class="hljs-comment">// unboxing  </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">""</span> + x; }  
    <span class="hljs-comment">// ... 还有很多其他方法 AP 中不考  </span>
}  

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Double</span> </span>{  
    <span class="hljs-keyword">double</span> x;  
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Double</span><span class="hljs-params">(<span class="hljs-keyword">double</span> _x)</span> </span>{ x = _x; }      <span class="hljs-comment">// boxing  </span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">doubleValue</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> x; } <span class="hljs-comment">// unboxing  </span>
    <span class="hljs-comment">// ...  </span>
}
</code></pre>
<p>(2) <code>Integer</code> 和 <code>Double</code> 都是 immutable 的。也就是说，这两个类都没有提供 <code>public void setValue(int x)</code> 这样的方法。同时，因为它是 immutable 的，如果直接赋值，它会被存在常量池里，<strong>相同的值只创建一个对象</strong>，类似于 string literals。  </p>
<p>(3) autoboxing and unboxing。需要注意的是，<strong>当 **</strong>==<strong>** 两边都是封装类时，不发生 auto unboxing</strong>。看例子：  </p>
<pre><code class="lang-java">Integer x = <span class="hljs-number">3</span>; <span class="hljs-comment">// autoboxing  </span>

...f(Integer x) { ... }  
f(<span class="hljs-number">5</span>); <span class="hljs-comment">// autoboxing  </span>

Integer x = <span class="hljs-number">5</span>;  
<span class="hljs-keyword">int</span> y = x; <span class="hljs-comment">// auto unboxing  </span>

...f(<span class="hljs-keyword">int</span> x) { ... }  
f(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">5</span>)); <span class="hljs-comment">// auto unboxing  </span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">giveMeFive</span><span class="hljs-params">()</span> </span>{  
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">5</span>); <span class="hljs-comment">// auto unboxing  </span>
}  

<span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;  
Integer A = <span class="hljs-number">3</span>;  
Integer B = <span class="hljs-number">3</span>;  
Integer C = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>);  
Integer D = <span class="hljs-number">4</span>;  
<span class="hljs-keyword">boolean</span> b1 = (a == A); <span class="hljs-comment">// true，auto unboxing，相当于 (a == A.intValue())  </span>
<span class="hljs-keyword">boolean</span> b2 = (A == B); <span class="hljs-comment">// true，并没有发生 auto unboxing，而是因为相同的值在常量池里只创建一个对象，所以 A 和 B 就是一个对象  </span>
<span class="hljs-keyword">boolean</span> b3 = (A == C); <span class="hljs-comment">// false，没有发生 auto unboxing，A 和 C 不是同一个对象  </span>
<span class="hljs-keyword">boolean</span> b4 = (A.intValue() == C.intValue()); <span class="hljs-comment">// true，手动 unboxing  </span>
<span class="hljs-keyword">boolean</span> b5 = (A &lt; D); <span class="hljs-comment">// true，auto unboxing</span>
</code></pre>
<p>(4) 在 Java 里 <code>int</code> 可以自动被转成 <code>double</code>。如 <code>int x = 1; double y = x;</code> 是可以通过编译的。同时，<code>double</code> 可以自动被转成 <code>Double</code>，也就是所谓的 autoboxing，例如 <code>Double x = 23.33;</code>。但是，<code>int</code> 不能被自动转成 <code>Double</code>。如 <code>Double x = 1;</code> 就会编译错误，必须改成 <code>Double x = 1.0;</code>。  </p>
<h3 id="math-类"><code>Math</code> 类</h3>
<p>(1) <code>static int abs(int x)</code> 和 <code>static double abs(double x)</code>：绝对值。  </p>
<p>(2) <code>static double pow(double base, double exp)</code>：求 $\texttt{base} ^ {\texttt{exp} }$。  </p>
<p>(3) <code>static double sqrt(double x)</code>：开根。  </p>
<p>(4) <code>static double random()</code>：返回一个 $[0, 1)$ 的随机小数。一般地，如果需要一个 $[l, r]$ 之间的整数，则调用 <code>(int)(Math.random() * (r - l + 1)) + l</code>。  </p>
<h2 id="数组，array-list，和二维数组">数组，Array List，和二维数组</h2>
<h3 id="数组（array">数组（Array)</h3>
<p>(1) 数组的定义：<code>int[] a = new int[10];</code>，或者 <code>int[] a; a = new int[10]</code>。也可以同时定义多个 Array：<code>int[] a = new int[10], b = new int[20];</code>。你可以理解成，<code>int[]</code> 是一种特殊的类型（不过，还有一种语法：<code>int a[] = new int[10];</code>，它是不符合我们的理解的，所以也不推荐使用）。<code>a</code> 是一个 reference，指向一个 <code>int[]</code> 类型的对象，也就是一个数组。数组可以静态初始化，例如：<code>int[] a = {2, 3, 3};</code>。数组长度不能变，里面的内容可以变。  </p>
<p>(2) 和其他 reference 一样，数组无论是在哪里定义的，都会被默认初始化。需要注意的是，如果数组里装的是 reference 类型（比如 <code>String</code> 或其他自己定义的类），那么每个位置上被初始化为了 <code>null</code>，此时还是不能直接使用的，需要逐个 <code>new</code> 出来。  </p>
<p>(3) 通过 <code>a.length</code> 获得数组长度。注意，数组中 <code>length</code> 是数据，不是方法，不加括号。  </p>
<p>(4) 有一种不通过下标遍历数组的方法，叫 foreach。以 <code>int</code> 类型的数组 <code>a</code> 为例：<code>for(int x: a) { ... }</code>，就相当于 <code>for(int i = 0; i &lt; a.length; ++i) {int x = a[i]; ... }</code>。这里 <code>x</code> 相当于一个局部变量，<strong>对 **</strong>x<strong>** 做的所有改变不会影响到数组</strong>。如果数组里装的是 reference，用 foreach 时<strong>可以通过调用这个对象的方法对它进行修改（数组里的对象会同时被修改），但如果令这个 reference 指向另一个对象，则不会影响数组</strong>（简称数组里的对象能读，能改，不能换）。  </p>
<pre><code class="lang-java">ArrayList
</code></pre>
<p>(1) 可以变长的数组。  </p>
<p>(2) <strong>只能装对象</strong>。例如 <code>ArrayList&lt;int&gt;</code> 是错的，需改成 <code>ArrayList&lt;Integer&gt;</code>。使用时会发生 autoboxing 和 auto unboxing，因此效率不如数组。  </p>
<p>(3) 定义：<code>ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();</code>。其中 <code>&lt;String&gt;</code> 这个用法被称为泛型（generic），其实就是 C++中的模板。  </p>
<p>(4) 下标范围和数组一样，foreach 用法和数组一样。  </p>
<p>(5) 通过 <code>a.size()</code> 获得长度，相当于数组的 <code>.length</code>。  </p>
<p>总结一下：  </p>
<pre><code class="lang-java">String s = ...;  
<span class="hljs-keyword">int</span> n = s.length();  

<span class="hljs-keyword">int</span>[] a = ...;  
<span class="hljs-keyword">int</span> n = a.length;  

ArrayList&lt;Integer&gt; a = ...;  
<span class="hljs-keyword">int</span> n = a.size();
</code></pre>
<p>(6) 如果要按下标访问，那么不能用 <code>[i]</code>，而需要调用方法：<code>get(i)</code> 或者 <code>set(i, obj)</code>。<code>set</code> 会返回原来该位置上的元素。  </p>
<p>(7) <code>boolean add(T obj)</code>：在最后加入一个元素 <code>obj</code>（<code>T</code> 表示元素类型，下同），返回 <code>true</code>。  </p>
<p>(8) <code>void add(int i, T obj)</code>：把元素 <code>obj</code> 插入到下标 <code>i</code>，后面的元素依次右移。$0\leq i\leq \texttt{a.size()}$ ，注意 <code>i</code> 可以等于 <code>a.size()</code>，也就是插入到最后。  </p>
<p>(9) <code>T remove(int i)</code> 把位置 <code>i</code> 上的元素删除并将它返回。  </p>
<p>(10) 数组没有 override <code>toString()</code> 方法，<code>ArrayList</code> override 过。所以只有 <code>ArrayList</code> 可以用 <code>System.out.print()</code> 打印出来，形如 <code>[2, 3, 3]</code>。  </p>
<h3 id="二维数组">二维数组</h3>
<p>(1) 定义：<code>int[][] a = new int[10][10]</code>。也可以先 <code>int[][] a = new int [10][]</code>，再逐行定义。每一行长度可以不一样。<strong>每一行是一个独立的数组</strong>（<code>a[i]</code> 里存的是这个数组的 reference），不同行之间内存不连续，可以通过对 reference 操作，对某两行进行交换，或者对某一行进行整体替换。  </p>
<p>(2) 对第一维用 foreach：<code>for(int[] row: a)</code>。此时的 <code>row</code> 是一个 reference，满足前面说过的“能读，能改，不能换”。至于二维数组里的每个对象能不能换，只取决于内层循环是不是 foreach，和外层循环无关。  </p>
<h2 id="算法">算法</h2>
<p>(1) random shuffle：  </p>
<pre><code class="lang-java"><span class="hljs-keyword">int</span>[] a = ...;  
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = a.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {  
    <span class="hljs-keyword">int</span> j = (<span class="hljs-keyword">int</span>)(Math.random() * (i + <span class="hljs-number">1</span>)); <span class="hljs-comment">// [0, i]。注意，包括 i  </span>
    <span class="hljs-comment">// swap(a[i], a[j])  </span>
    <span class="hljs-keyword">int</span> tmp = a[i];  
    a[i] = a[j];  
    a[j] = tmp;  
}
</code></pre>
<p>(2) AP 里的选择排序，是不额外开一个答案数组的，而是<strong>直接在原数组上 **</strong>swap<strong><strong>。所以它是不稳定的（例如你考虑数组 </strong></strong>{2, 2, 1}<strong><strong>）。AP 不考察排序算法的稳定性，但是要理解后面元素的顺序是会被打乱的，考试时问你第 k​ 轮以后的序列，最好手动模拟一下。另外，AP 里每轮一般是先找好最小的位置再最后 </strong></strong>swap<strong>** 一次</strong>，而不是每找到一个更小的元素就 <code>swap</code> 一下。  </p>
<p>(3) AP 里的插入排序也是不额外开数组的，通过把当前元素向前依次交换来实现（有点像冒泡）。当然，归并排序还是必须额外开数组的。  </p>
<p>(4) 选择排序的比较次数和交换次数都是一定的$\frac{n(n - 1)}{2}$  和 $n - 1$ 。插入排序不一定，顺序时最优$（n−1 和 0）$ ，恰好反序时最差（$\frac{n(n - 1)}{2}$  和 $\frac{n(n - 1)}{2}$ ）。在数组较为有序时，插入排序的比较次数小于选择排序，交换次数不一定。  </p>
<p>(5) 二分查找（找到某一元素或告知不存在，假设该元素唯一）的最坏情况比较次数：$\lfloor\log_2(n)\rfloor + 1$ 。其中 +1 是因为即使在只剩一个元素时，也要比较一下是不是要找的元素。有些题目保证要找的元素一定存在（比如猜数游戏），就不需要这个 +1了。可以用归纳法证明该结论。  </p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="AP_Computer_Science_A_Subset.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: AP_Computer_Science_A_Subset">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"AP_Computer_Science_A_Notes","level":"1.4","depth":1,"previous":{"title":"AP_Computer_Science_A_Subset","level":"1.3","depth":1,"path":"AP_Computer_Science_A_Subset.md","ref":"AP_Computer_Science_A_Subset.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"AP_Computer_Science_A_Notes.md","mtime":"2025-04-25T11:47:00.222Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:24:44.575Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

