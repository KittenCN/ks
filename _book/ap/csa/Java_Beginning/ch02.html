
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>csa Chapter2 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch03.html" />
    
    
    <link rel="prev" href="ch01.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="ch01.html">
            
                <a href="ch01.html">
            
                    
                    csa Chapter1
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="ch02.html">
            
                <a href="ch02.html">
            
                    
                    csa Chapter2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch03.html">
            
                <a href="ch03.html">
            
                    
                    csa Chapter3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch04.html">
            
                <a href="ch04.html">
            
                    
                    csa Chapter4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ch05.html">
            
                <a href="ch05.html">
            
                    
                    csa Chapter5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="ch06.html">
            
                <a href="ch06.html">
            
                    
                    csa Chapter6
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >csa Chapter2</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h2 id="变量的定义、赋值和读取">变量的定义、赋值和读取</h2>
<p>变量(variable)，就是可以改变的量，例如在程序运行的一开始这个量是1，后面可以变为2，到程序运行结束的时候可以变为100。在计算机中，我们可以把各种类型的数据（如一个数字、一个字符串）存储在变量中。我们就需要知道变量的几个最基本的用法——定义、赋值、读取和操作。</p>
<p>定义主要是为了明确这个变量在哪里可以被访问到（作用域）和变量的类型。而赋值就是给变量存一个值，比如我们把100存入一个变量（称为<code>a</code>），那么<code>a</code>里面就存着100这个数字。读取（或说取值）相当于把这个值从变量里面取出来，如果我们取刚才所存的<code>a</code>变量，会得到一个100。</p>
<p>定义一个字符串类型变量a的语句如下：</p>
<pre><code class="lang-java">String text;
</code></pre>
<p>定义其他类型的变量也一样，写法为：</p>
<pre><code class="lang-java">变量类型 变量名;
</code></pre>
<p>变量的类型在本章中稍后会具体介绍。</p>
<p>给一个字符串变量赋值<code>"Hello Java!"</code>的语句如下：</p>
<pre><code class="lang-java">text = <span class="hljs-string">"Hello Java!"</span>;
</code></pre>
<p>前面的这两个语句可以合起来，成为：</p>
<pre><code class="lang-java">String text = <span class="hljs-string">"Hello Java!"</span>;
</code></pre>
<p>最后读取一个变量的方式就是直接写这个变量的名字，比如下面这条语句可以把<code>text</code>读取出来赋值给<code>abc</code>：</p>
<pre><code class="lang-java">String abc = text;
</code></pre>
<p>如果我们定义了变量而没有对其进行赋值（也叫初始化，initialization），那么会发生几种情况，这要看变量定义的位置和类型分类而定，具体我们会在面向对象型编程教程里面讲到。</p>
<p>像在第一章的例子，我们就可以先把字符串存入一个变量，再通过读取这个变量的方式把字符串输出出来，就像下面这样：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      String text = "Hello Java!"; // 定义变量text并赋值
      System.out.println(text); // 读取并输出变量text
  }
}
&lt;/lab&gt;
</code></pre>
<p>操作也同样简单，例如对于字符串，最简单的操作就是连接两个字符串了，我们使用连接运算符（<code>+</code>）来做到这点：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      String str1 = "Hello ";
      String str2 = "Java!";
      System.out.println(str1 + str2); // 连接str1和str2并输出
  }
}
&lt;/lab&gt;
</code></pre>
<h2 id="给变量起名字">给变量起名字</h2>
<p>无论是在考试还是在实际操作中，变量的命名都是很重要的。一般我们用这4条规则来给变量起名：</p>
<ol>
<li>变量名称需要有描述性，比如（<code>string</code>这种变量名就没有准确描述存储的内容）</li>
<li>如果要描述内容的名称只有一个单词，那么这个变量名可以用这个单词的全小写形式（如<code>number</code>），如果名称由两个或两个以上个单词组成，那么变量名为第一个单词首字母小写，剩下的单词紧跟着第一个单词，但第一个字母大写（如学生数量为<code>studentNumber</code>）</li>
<li>在变量名中，第一个位置不能是数字（如不能以<code>1Hello</code>作为变量名），同时变量名不能有空格，不能有“-”、“/”等对计算机来说有歧义的符号（如<code>abc*def</code>会被计算机理解成abc乘以def）</li>
<li>在Java中，变量不能是系统保留用的关键字（比如<code>class</code>、<code>static</code>）</li>
</ol>
<h2 id="类型及储存方式">类型及储存方式</h2>
<h3 id="整数类型（简称整型-int）">整数类型（简称整型, int）</h3>
<p>在计算机中，整数是以二进制形式储存的，也就是说当我们往Java里储存十进制的<code>2</code>时，Java实际上存储的是二进制的<code>10</code>。一个二进制的<code>0</code>或<code>1</code>称为一个比特（bit），8个比特为一个字节（byte）。而Java的<code>int</code>由32个bit组成，所以可以有<code>2^32</code>（2的32次方）种状态，因为还需要存储负数，因此可以存储<code>-2^31</code>到<code>2^31-1</code>之间的数。</p>
<!-- TODO: 补充进制转换 -->
<h3 id="浮点类型-（double）">浮点类型 （double）</h3>
<p>浮点类型可以对应我们一般称的“小数”，同样也是通过二进制储存的，只不过并不是像整数那样直接储存，而是使用了科学计数法。</p>
<p><code>符号 * 有效位数 * 2 ^ 指数</code></p>
<p>比如如果储存的是正号、有效位数转换为十进制是11，指数是-1，那么经过计算我们可以发现这样表现的数字是5.5。</p>
<p>浮点类型除了可以表示小数以外，还可以表示数字无效（<code>NaN</code>, Not a Number），或者正负无穷（<code>Infinity</code>和<code>-Infinity</code>）。比如如下的运算会产生一个<code>NaN</code>：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      System.out.println(0.0/0.0);
  }
}
&lt;/lab&gt;
</code></pre>
<p>注意到使用的<code>0.0/0.0</code>了吗，为什么不使用<code>0/0</code>呢，看了在下面的“运算和操作符”，你就明白了。</p>
<p>使用浮点类型要注意的一点是要小心精度错误，因为不是所有数字都可以用浮点类型精确表示的，比如如下操作：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      System.out.println(0.1+0.1+0.1);
  }
}
&lt;/lab&gt;
</code></pre>
<p>我们会发现这个运算的结果不是<code>0.3</code>，而是<code>0.30000000000000004</code>，这是因为在运算中出现了精度取舍错误（round-off error），如果我们把这个运算和<code>0.3</code>比较的话，计算机会告诉我们这两个数字不相等，这在一些操作中是会出现错误的，因此如果我们需要比较两个浮点数是否相等，可以比较两个数的差的绝对值，如果这个绝对值很小（如小于<code>0.000000001</code>），就认为这两个数是相等的。</p>
<p>在Java里，double本身的意思是双精度浮点类型，当然也有精度低一些的单精度浮点类型float，在AP考试中，只有双精度浮点类型会被考到，而在实际生活中，可以根据需要使用这两个类型。</p>
<h3 id="字符串类型-（string）">字符串类型 （String）</h3>
<p>字符串类型储存的是一串文字，之前提到的<code>"Hello Java!"</code>本质上就属于字符串类型。字符串的储存方式是把每个字符通过一张叫ASCII码表的转换表对应成数字，再把数字一个一个地按顺序储存起来。</p>
<p>ASCII码表长这样：
<img src="ch02_Pic1.jpg" alt="ASCII码表 图片来自网络"></img></p>
<h3 id="布尔类型-（boolean）">布尔类型 （boolean）</h3>
<p>布尔类型是一种特殊的类型，只有两种取值，一种是真（<code>true</code>），一种是假（<code>false</code>）。它主要有两种用途：</p>
<ol>
<li>用来记录一个属性的是或者不是，例如记录一个人是不是会员，就可以用布尔型变量<code>isVIP</code>来记录</li>
<li>布尔是几个操作符的结果类型，比如比较变量<code>a</code>是不是等于变量<code>b</code>，结果就是一个布尔类型的值，它有可能为真（相等），也有可能为假（不相等）</li>
</ol>
<h2 id="运算和操作符">运算和操作符</h2>
<p>说了这么多种类型，那么现在我们来看一下怎么用它们来运算。</p>
<h3 id="整数运算">整数运算</h3>
<p>整数运算比较容易理解，像加减乘除都属于整数运算。</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      // 在这里输入代码
      System.out.println(888+999);
      System.out.println(888*999);
      System.out.println(888-999);
      System.out.println(10/2);
      System.out.println(888/999);
      System.out.println(10%3);
      System.out.println(0/0);
  }
}
&lt;/lab&gt;
</code></pre>
<p><strong>注意</strong>：在Java里乘方不是<code>^</code>符号，而是需要通过<code>Math.pow</code>来使用，<code>^</code>是位运算的异或，比较少用到</p>
<p>你可能会奇怪，<code>10/2</code>是5没错，可为什么<code>888/999</code>的结果会是0呢？这是因为计算机看到888是整数，而999也是整数，那么就对此进行整数运算，整数的加法、减法和乘法都体现不出来，只有除法会有差别，整数除法后的结果可以理解为算数除法舍去小数点后的部分的结果。</p>
<p>最后的<code>10%3</code>进行的是除余运算，10除以3等于3余1，因此这个运算的结果为1。</p>
<p>最后的<code>0/0</code>运算会报一个<code>java.lang.ArithmeticException</code>的错误，<strong>因为一个数除以<code>0</code>没有定义，而整数下不能表示<code>NaN</code></strong>，这种运行时报错叫做“异常（exception）”，在[“异常”]一章中我们会讲到。不过需要注意的是，浮点数可以表示<code>NaN</code>（参见[类型及储存方式]），因此<code>0.0/0.0</code>结果会是<code>NaN</code>而不会报错。</p>
<h3 id="浮点运算">浮点运算</h3>
<p>浮点运算同样也是用类似的方法调用：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      // 在这里输入代码
      System.out.println(99.1+0.9);
      System.out.println(99.1*99.9);
      System.out.println(100-0.9);
      System.out.println(888.0/999);
      System.out.println(10.2%5);
  }
}
&lt;/lab&gt;
</code></pre>
<p>这里和上面的差别在于，两个操作数（可以理解为参与运算的数字）至少有一个是浮点类型的。最后一个操作和前面的<code>888/999</code>不同，我们在<code>888</code>后面加了一个<code>.0</code>，使其变成了一个浮点数。因为<code>888.0</code>是浮点类型，尽管<code>999</code>是整型，计算机也会使用浮点运算，结果自然就是一个浮点数了。</p>
<p>你可能会问，计算机为什么不都用浮点类型进行运算呢，这是因为很多时候程序不需要浮点运算的结果，而进行整型运算会比浮点运算快得多。</p>
<p>浮点的除余运算，除了用<code>10.2-2*5</code>理解方式（其中的2是<code>10.2/5</code>的整数部分），还可以理解为用<code>10.2</code>去反复减去<code>5</code>，直到得到一个小于5的数为止（<code>10.2-5=5.2 5.2-5=0.2</code>），因此结果为0.2。</p>
<p>整数运算和浮点运算统称算术运算。</p>
<p><strong>注意</strong>：别忘了浮点运算可能有精度取舍错误。</p>
<h3 id="类型转换">类型转换</h3>
<p>如果我们有两个<code>int</code>类型的变量，想要让他们进行浮点运算，要怎么做呢？毕竟变量可不能在后面加<code>.0</code>。这时候就需要用到类型转换了。就像下面这样：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      // 在这里输入代码
      System.out.println((double)888/999);
  }
}
&lt;/lab&gt;
</code></pre>
<p>在整型前面加上<code>(double)</code>，我们就成功把它转化为了一个浮点类型的数字。当然把浮点类型转化为整型也是一样，只需要在前面加上<code>(int)</code>即可，不过要小心丢失小数点后面的内容：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      // 在这里输入代码
      System.out.println((int)888.9);
  }
}
&lt;/lab&gt;
</code></pre>
<p><strong>注意</strong>：这里的转化，和整数除法的结果一样，是直接丢失小数点后面的内容而不是进行四舍五入。</p>
<p>类型转换本质上也是一种运算，只不过运算的结果和输入给运算的值类型不同而已。</p>
<h3 id="关系运算">关系运算</h3>
<p>关系运算判断的是两个操作数的关系，主要有：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>==</code></td>
<td>是否等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>是否不等于</td>
</tr>
</tbody>
</table>
<p>这里的<code>==</code>和前面提到的赋值运算符<code>=</code>不一样，前者是判断是否相等，后者是把一个值赋给变量用的。关系运算符返回一个布尔类型的数值，如果关系是正确的（比如<code>5==5</code>），那么返回真（<code>true</code>），如果关系是错误的（比如<code>5==6</code>），那么返回假（<code>false</code>）。</p>
<h3 id="逻辑运算">逻辑运算</h3>
<p>关系运算判断的是布尔值本身或者布尔值之间的关系，主要有：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
</tr>
<tr>
<td>!</td>
<td>非</td>
</tr>
</tbody>
</table>
<p>与需要左右两边都为真才返回真，或只需要一边为真即可，非只需要右边的一个操作数，会反过来输出（操作数为真输出假，操作数为假输出真）。</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      // 在这里输入代码
      System.out.println(true&amp;&amp;true);
      System.out.println(false||true);
      System.out.println(!false);
  }
}
&lt;/lab&gt;
</code></pre>
<p>逻辑运算符常常和关系运算符一起用：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      // 在这里输入代码
      System.out.println((3&gt;2)&amp;&amp;(2&gt;1));
  }
}
&lt;/lab&gt;
</code></pre>
<h3 id="赋值运算和增减量运算">赋值运算和增减量运算</h3>
<p>赋值运算符由最基本的<code>=</code>运算符和复合赋值运算符组成：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>=</code></td>
<td>赋值</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加上</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减去</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘上</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除去</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>进行除余赋值运算</td>
</tr>
<tr>
<td><code>++</code></td>
<td>增量运算，与<code>+=1</code>等价</td>
</tr>
<tr>
<td><code>--</code></td>
<td>减量运算，与<code>-=1</code>等价</td>
</tr>
</tbody>
</table>
<p>一个复合运算符可以看成算术运算符加上赋值运算符，如下面的<code>a+=1</code>运算等价于<code>a=a+1</code>：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      // 在这里输入代码
      int a = 1;
      a+=1;
      System.out.println(a);
  }
}
&lt;/lab&gt;
</code></pre>
<h3 id="其他运算">其他运算</h3>
<p>在Java里还有很多其他的运算符，例如位运算是用来处理位与位的关系的，日常用途中比较少用，<code>.</code>运算符在讲到类的时候会说到，再其他的运算符就更少用到了。</p>
<h3 id="优先级">优先级</h3>
<p>有这么多的的运算关系，该怎么确定它们之间的优先级就是一个非常重要的问题。Java中的算数优先级和数学大抵相同，先乘除后加减：</p>
<ol>
<li>算数运算的优先级如下，优先级从高往低排列：
```
a) 括号，从内层开始</li>
</ol>
<p>b) * , /, %</p>
<p>c) + , -</p>
<pre><code>2. 总体优先级如下，优先级从高往低排列
</code></pre><p>a) ()</p>
<p>b) ! , ++ , -</p>
<p>c) * , / , %</p>
<p>d) + , -</p>
<p>e) &lt; , &gt; , &lt;= , &gt;=</p>
<p>f) == , !=</p>
<p>g) &amp;&amp;</p>
<p>h) ||</p>
<p>i) = , += , -= *= , /= , %=</p>
<pre><code>这些看起来很复杂，实际上是比较符合我们的数学常识的。大家可以在理解中记忆，练习时不确定来查即可。

标识符
------
通俗地说，标识符其实就是变量、方法和类等的名字。在同一个作用域（可以调用的范围）内，不允许有两个变量有同样的标识符。像这样就是不行的：
```java
&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      int a = 1;
      int a = 2;
  }
}
&lt;/lab&gt;
</code></pre><p>注意：对于标识符的概念，不要简单地理解成重名就一定不能共存，比如这样是可以的：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  int a = 1;
  public static void main(String[] args) {
      int a = 2;
  }
}
&lt;/lab&gt;
</code></pre>
<p>主要原因是他们的作用域不一样，具体在我们学类的时候会详细说明。</p>
<p>方法的标识符的概念和变量又有一些区别，我们之后会提到。</p>
<h2 id="final变量">final变量</h2>
<p>有的时候，我们需要设定一个值，而这个值会被很多地方引用（比如学生数量），如果直接用数字写在代码里，一旦这个数字需要修改，工程师们就需要查遍所有有可能出现这个数字的地方去改它。而且麻烦在于不能直接用查找和替换，毕竟同一个数字可能有不同的用途（比如我们想改的是学生数量的50，却把一节课的时间50也一起改了）。</p>
<p>有一种替代方法是在开头声明一个变量（如前面说的studentNum），之后在需要用到这个数字的时候都引用这个变量而不是直接写数字，比如我们需要两倍于学生数量的笔：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      int studentNum = 50;
      System.out.print("Number of pens: ");
      System.out.println(studentNum * 2);
      // 而不是 System.out.println(50 * 2);
  }
}
&lt;/lab&gt;
</code></pre>
<p>但这样有一个问题，Java不知道我们是不是要修改这个变量，因此很难做优化，并且要是我们操作出错修改了这个变量，那整个程序都会出现严重的问题：</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      int studentNum = 50;
      studentNum = 30; // 一个错误的操作
      System.out.print("Number of pens: ");
      System.out.println(studentNum * 2);
      // 100 才应该是正确的结果
  }
}
&lt;/lab&gt;
</code></pre>
<p>因此Java给我们提供了<code>final</code>这个关键字（注意关键字是不能当变量名的），用来定义<code>final</code>变量（final variable， 也叫用户定义常量，即user-defined constant）。</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      final int STUDENT_NUM = 50;
      // STUDENT_NUM = 30;
      System.out.print("Number of pens: ");
      System.out.println(STUDENT_NUM * 2);
      // 100是正确的结果
  }
}
&lt;/lab&gt;
</code></pre>
<p>与变量的命名惯例不同，常量一般都需要大写，并且词和词之间多用<code>_</code>连接。</p>
<p>去除注释以后，我们会发现出现了以下错误：</p>
<pre><code class="lang-java">Hello.java:<span class="hljs-number">5</span>: error: cannot assign a value to <span class="hljs-keyword">final</span> variable STUDENT_NUM
</code></pre>
<p>这就防止了我们无意中对final变量进行修改。</p>
<p><strong>注意</strong>：<code>final</code>变量并不一定要在定义的时候赋值，你也可以把上面的<code>final int STUDENT_NUM = 50;</code>拆成<code>final int STUDENT_NUM;</code>和 <code>STUDENT_NUM = 50;</code>，甚至可以把赋值语句放在条件语句里（下一章会学到）有条件地执行，但一定要注意不能第二次赋值，也不能不赋值就读取。</p>
<h2 id="小练习">小练习</h2>
<p>让我们来练习一下我们刚学习的知识吧。</p>
<pre><code class="lang-java">&lt;lab lang="java" parameters="filename=Hello.java"&gt;
public class Hello {
  public static void main(String[] args) {
      // 在这里输入代码
  }
}
&lt;/lab&gt;
</code></pre>
<p>试试做出如下的效果：</p>
<ol>
<li>计算100+998/12（要保留小数位后的数字，答案为183.16666666666669）</li>
<li>判断100/10是否等于10</li>
<li>建立一个整型变量<code>a</code>并赋值为10，对其加一，然后输出<code>a</code>。</li>
</ol>
<p>学到这里，你就已经把第二章全部学完啦，给你鼓鼓掌👏👏👏~</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch01.html" class="navigation navigation-prev " aria-label="Previous page: csa Chapter1">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch03.html" class="navigation navigation-next " aria-label="Next page: csa Chapter3">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"csa Chapter2","level":"1.3","depth":1,"next":{"title":"csa Chapter3","level":"1.4","depth":1,"path":"ch03.md","ref":"ch03.md","articles":[]},"previous":{"title":"csa Chapter1","level":"1.2","depth":1,"path":"ch01.md","ref":"ch01.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"ch02.md","mtime":"2024-01-02T10:10:25.929Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:24:38.828Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

