
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>csa Chapter2 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="CoderFAN 资料库 CSA AP_Reference">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ch03.html" />
    
    
    <link rel="prev" href="ch01.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="ch01.html">
            
                <a href="ch01.html">
            
                    
                    csa Chapter1
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="ch02.html">
            
                <a href="ch02.html">
            
                    
                    csa Chapter2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="ch03.html">
            
                <a href="ch03.html">
            
                    
                    csa Chapter3
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="ch04.html">
            
                <a href="ch04.html">
            
                    
                    csa Chapter4
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="ch05.html">
            
                <a href="ch05.html">
            
                    
                    csa Chapter5
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="ch06.html">
            
                <a href="ch06.html">
            
                    
                    csa Chapter6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="ch07.html">
            
                <a href="ch07.html">
            
                    
                    csa Chapter7
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >csa Chapter2</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h2 id="类、对象、属性和方法">类、对象、属性和方法</h2>
<h3 id="类（class）、对象（object）、属性（property）和方法（method）、对象、属性和方法三者的概念与运用。类是一个模板，它描述一类对象的行为和状态。对象的状态就是属性，而方法就是对象行为的体现。方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。">[类（class）、对象（object）、属性（property）和方法（method）]、[对象]、[属性和方法]三者的概念与运用。类是一个模板，它描述一类对象的行为和状态。对象的状态就是属性，而方法就是对象行为的体现。方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成。</h3>
<p>我们还可以用过参数来告诉这个函数具体的内容，比如setSpeed(double newSpeed)这个函数就可以让我们给一个浮点参数newSpeed，让我们告诉它要设定的车的具体速度，这里的newSpeed写在函数定义里，称为形式参数（parameter），形式参数一定是要是一个合法的变量名，参数与参数用逗号隔开，每一个参数前面都需要有一个参数类型。</p>
<p>Java的方法以如下格式呈现：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> + 可能有 <span class="hljs-keyword">static</span> 关键字 + 返回值类型 + 方法名(形式参数列表){
  方法体
}
</code></pre>
<h3 id="作用域">[作用域]</h3>
<p>作用域其实就是访问范围。在函数内定义的变量，作用域是在变量定义后到函数结束。在更内部（比如for循环的初始化内）定义的变量，作用域就仅限于那一个部分，到大括号结束为止。</p>
<p><code>public</code>关键字说明的是这个变量或者方法在类外是可见的，不仅可以在类本身里面调用，而且可以在类外通过.运算符调用。<code>private</code>修饰符所修饰的方法、属性仅能在本类中使用。</p>
<p><code>static</code>关键字定义的方法被称为静态方法（static method）实际上也被称为类方法（class method）。相反，不带有<code>static</code>方法的就被称为实例方法（instance method）了。静态方法并不随着我们的对象的创建才能使用，静态方法是与对象无关的。静态方法能够直接通过类的调用来使用。换句话说，实例方法是面向实例，也就是对象的（对象就是类的实例），而静态方法是面向类的。</p>
<p><code>this</code>这个关键字代表的就是对象中的成员变量或者方法。也就是说，如果在某个变量前面加上一个this关键字，其指的就是这个对象的成员变量或者方法，而不是指成员方法的形式参数或者局部变量。</p>
<h3 id="构造方法">[构造方法]</h3>
<p>每个类都有构造方法。如果没有专门为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。在创建一个对象的时候，至少要调用一个构造方法。构造方法是没有返回值的，并且构造方法的名称必须与类名相同，一个类可以有多个构造方法。</p>
<p>例如：</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dog</span><span class="hljs-params">(String name, String sex, <span class="hljs-keyword">int</span> age)</span></span>{
    System.out.println(<span class="hljs-string">"My name is "</span> + name + 
        <span class="hljs-string">", and my sex is "</span> + sex + <span class="hljs-string">". I'm "</span> + 
        age + <span class="hljs-string">" years old."</span>);
}
</code></pre>
<p>就是<code>Dog</code>类的构造方法。</p>
<h3 id="访问器和更改器">[访问器和更改器]</h3>
<p>习惯上，我们使用getter与setter方法来访问与修改Java属性值。这两种方法分别叫“访问器（Accessor）”与“更改器(Mutator)”</p>
<h3 id="方法重载">[方法重载]</h3>
<p>方法重载指的是，多个方法有同样的名字，却有不同的传入参数列表。</p>
<h2 id="引用">引用</h2>
<h3 id="原始类型和引用类型">[原始类型和引用类型]</h3>
<p>在Java里面的类型有分两种，原始类型（primitive types）和引用类型（reference types）。Java自带的类型中，凡是首字母为小写的都是原始类型（如int，bool，double），凡是首字母为大写的都是引用类型（如String，Object），自己定义的类的类型（比如之前说的Car）也都是引用类型。</p>
<p>这两种类型的主要区别在于储存方式。原始类型的数据是直接储存的，而引用类型是按引用（reference）储存，就是变量只是记下了这个对象真正的位置，而并不是储存了整个对象。</p>
<h3 id="空引用">[空引用]</h3>
<p>空引用指的是，引用的对象没有被初始化（initialize），也就是没有被赋值。</p>
<h2 id="继承和多态">继承和多态</h2>
<h3 id="继承">[继承]</h3>
<p>继承说的是，"子类"可以继承"父类"的属性，或者是方法。一个由其他的类派生出来的类，叫做子类(subclass)，而派生出子类的类，则叫做父类（superclass或parent class)。子类包含着父类的所有属性和方法，同时，子类还可以具有自己独有的属性和方法，因此，子类可以包含着比父类更多的属性和方法！</p>
<p>假如有两个类，A与B，而A派生出B，换句话说，B继承自A，则：</p>
<pre><code class="lang-java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>{
<span class="hljs-comment">//类的内容</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span></span>{
<span class="hljs-comment">//类的内容</span>
}
</code></pre>
<h3 id="方法重写">[方法重写]</h3>
<p>方法重写(Method override)指的是，如果一个类继承了其父类的方法，那么我们可以通过方法重写，用同名的方法，来"覆盖"掉所继承的父类的对应方法。相当于，在子类中我们"重新写了"一次，父类中该名称的方法，并用此方法来替代所继承的同名方法。</p>
<h3 id="抽象类">[抽象类]</h3>
<p>"抽象"这一概念的引入，是面向对象编程的一个重要思想：从高层次的抽象、模糊概念开始，逐步细化化。也就是由抽象到具体，由概念到实现，首先关注的是解决一个问题的总体概念，再逐步逐步把这个总体概念拆分、细化、具体落实下去。</p>
<p>我们可以用"abstract"这个关键字对一个类进行修饰，把这个类定义成抽象的类。同样，我们也可以用"abstract"这个关键字对一个方法进行修饰，把这个方法定义成抽象方法。如：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">roam</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<h3 id="多态（polymorphism）">[多态（polymorphism）]</h3>
<p>在Java中，方法调用总是由调用这一方法的对象实际指向的对象类型（也就是在new语句后紧跟着的类型），而不是由这一对象引用的对象类型（也就是在new语句中，实际对象前面的那个类型）来决定的。</p>
<p>例如，在语句<code>Animal puppy = new Dog();</code>中，实例对象puppy所引用的类型是Animal，而其实际指向的类型则是Dog。这个机制就叫做多态。  </p>
<h3 id="向下转型（down-casting）">[向下转型（down casting）]</h3>
<p>把一个子类引用指向父类对象的转型过程，称作向下转型。</p>
<p>在下面这个例子里，我们假设getID()方法是GradStudent类中特有的一个public实例方法，没有在Student类中被定义，GradStudent类继承自Student类。</p>
<pre><code class="lang-java">Student student = <span class="hljs-keyword">new</span> GradStudent();
GradStudent gradstudent = <span class="hljs-keyword">new</span> GradStudent();
<span class="hljs-keyword">int</span> x = ((GradStudent) student).getID(); <span class="hljs-comment">//这里用到了向下转型</span>
</code></pre>
<h3 id="动态绑定（dynamic-bonding">[动态绑定（dynamic bonding)]</h3>
<p>动态绑定，指的是，当存在方法重写时，关于调用哪一个实例方法的决定，是在Java程序运行时(run-time)（Java虚拟机JVM实时解析运行Java字节码时）才实时作出的。</p>
<h3 id="使用super调用父类方法">[使用<code>super</code>调用父类方法]</h3>
<p>如果在子类中，我们对一个方法进行了重写，则重写过的方法默认覆盖过了父类中的同名方法，但若我们就是想使用父类中的，被重写过的，那一个原本的方法，那我们就可以通过使用关键字super来调用被重写过(overridden)的方法。</p>
<p>比方说：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Superclass</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMethod</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">"Printed in Superclass."</span>);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subclass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Superclass</span> </span>{
    <span class="hljs-comment">// overrides printMethod in Superclass</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMethod</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">super</span>.printMethod();
        System.out.println(<span class="hljs-string">"Printed in Subclass."</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Subclass s = <span class="hljs-keyword">new</span> Subclass();
        s.printMethod();    
    }
}
</code></pre>
<p>上述代码的运行结果为：</p>
<pre><code class="lang-java">Printed in Superclass.
Printed in Subclass.
</code></pre>
<h3 id="super与构造方法">[<code>super</code>与构造方法]</h3>
<p>在子类中使用super调用父类中的构造方法的语法是<code>super()</code>或<code>super(parameter1, parameter2, ...)</code>
若使用<code>super()</code>, 父类中不带传入参数列表的构造方法将会被调用。当使用带传入参数的 super关键字，则父类中具有匹配的传入参数列表的构造函数将会被调用。</p>
<h2 id="接口">[接口]</h2>
<p>在Java编程语言中，接口（interface）是一个引用类型，类似于一个类，它相当于是一类方法的集合（有点像抽象类）。在接口中，这些方法，就如同抽象类一样，可以是抽象的（只包含一个声明，却不包括具体实现），也可以是普通的实例方法或静态方法（包括具体方法的实现）。 也就是说，对于接口，方法体只存在于普通的实例方法或静态方法中。 接口不能被实例化 - 它们只能由类实现或由其他接口扩展。</p>
<h3 id="实现（implement）接口">[实现（implement）接口]</h3>
<p>我们可以使用<code>implement</code>关键字让类去使用已经定义好的接口。例如：</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fish</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SwimmingObject</span></span>{
<span class="hljs-comment">//类的内容</span>
}
</code></pre>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="ch01.html" class="navigation navigation-prev " aria-label="Previous page: csa Chapter1">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ch03.html" class="navigation navigation-next " aria-label="Next page: csa Chapter3">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"CoderFAN 资料库 CSA AP_Reference","title":"csa Chapter2","level":"1.3","depth":1,"next":{"title":"csa Chapter3","level":"1.4","depth":1,"path":"ch03.md","ref":"ch03.md","articles":[]},"previous":{"title":"csa Chapter1","level":"1.2","depth":1,"path":"ch01.md","ref":"ch01.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*","description":"CoderFAN 资料库 CSA AP_Reference"},"file":{"path":"ch02.md","mtime":"2025-05-12T03:21:13.359Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-12T03:28:18.752Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

