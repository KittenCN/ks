
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>STL常用函数 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="stl容器.html" />
    
    
    <link rel="prev" href="ACM常用算法.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    ACM算法指南
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="数据结构/基础数据结构.html">
            
                <a href="数据结构/基础数据结构.html">
            
                    
                    基础数据结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="搜索算法/搜索算法概述.html">
            
                <a href="搜索算法/搜索算法概述.html">
            
                    
                    搜索算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="图论算法/图论概述.html">
            
                <a href="图论算法/图论概述.html">
            
                    
                    图论算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="动态规划/动态规划概述.html">
            
                <a href="动态规划/动态规划概述.html">
            
                    
                    动态规划
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="字符串算法/字符串算法概述.html">
            
                <a href="字符串算法/字符串算法概述.html">
            
                    
                    字符串算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="数学算法/数学算法概述.html">
            
                <a href="数学算法/数学算法概述.html">
            
                    
                    数学算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="技巧与优化/技巧与优化概述.html">
            
                <a href="技巧与优化/技巧与优化概述.html">
            
                    
                    技巧与优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="实战练习指导/实战练习概述.html">
            
                <a href="实战练习指导/实战练习概述.html">
            
                    
                    实战练习指导
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="算法函数.html">
            
                <a href="算法函数.html">
            
                    
                    算法函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="ACM常用算法.html">
            
                <a href="ACM常用算法.html">
            
                    
                    ACM常用算法
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.11" data-path="STL常用函数.html">
            
                <a href="STL常用函数.html">
            
                    
                    STL常用函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="stl容器.html">
            
                <a href="stl容器.html">
            
                    
                    stl容器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="string.html">
            
                <a href="string.html">
            
                    
                    string
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >STL常用函数</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="stl常用函数指南---acm竞赛（c11）">STL常用函数指南 - ACM竞赛（C++11）</h1>
<p>本文档系统地介绍了ACM竞赛中最常用的STL函数，按功能类别整理，附带详细用法说明、复杂度分析和实例。所有内容均与C++11标准兼容。</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#算法相关函数">算法相关函数</a><ul>
<li><a href="#排序与查找">排序与查找</a></li>
<li><a href="#集合操作">集合操作</a></li>
<li><a href="#数值算法">数值算法</a></li>
<li><a href="#修改序列">修改序列</a></li>
<li><a href="#排列组合">排列组合</a></li>
<li><a href="#堆操作">堆操作</a></li>
</ul>
</li>
<li><a href="#迭代器相关函数">迭代器相关函数</a></li>
<li><a href="#函数对象">函数对象</a></li>
<li><a href="#数值处理函数">数值处理函数</a></li>
<li><a href="#字符串处理函数">字符串处理函数</a></li>
<li><a href="#时间复杂度总结">时间复杂度总结</a></li>
<li><a href="#实用技巧与最佳实践">实用技巧与最佳实践</a></li>
</ul>
<h2 id="算法相关函数">算法相关函数</h2>
<blockquote>
<p>使用前需要包含头文件 <code>#include &lt;algorithm&gt;</code></p>
</blockquote>
<h3 id="排序与查找">排序与查找</h3>
<h4 id="sort"><code>sort</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 对容器内的元素进行排序</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first: 指向要排序范围首元素的迭代器</span>
<span class="hljs-comment">// - last: 指向要排序范围末尾的下一个元素的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选），接收两个元素并返回bool值，表示第一个参数是否应排在第二个参数前面</span>
sort(first, last, comp);
</code></pre>
<p>参数详解：</p>
<ul>
<li><code>first</code>：指向要排序范围首元素的迭代器。必须是随机访问迭代器</li>
<li><code>last</code>：指向要排序范围末尾的下一个元素的迭代器（即排序区间为[first, last)）</li>
<li><code>comp</code>：比较函数（可选），是一个返回bool值的二元谓词，形式为<code>bool cmp(const Type1 &amp;a, const Type2 &amp;b)</code><ul>
<li>当<code>comp(a, b)</code>返回true时，a会排在b前面</li>
<li>如果不提供，默认使用<code>operator&lt;</code>进行升序排序</li>
<li>可以是函数指针、函数对象或Lambda表达式</li>
</ul>
</li>
</ul>
<p>返回值：无。排序会直接修改原容器中的元素顺序。</p>
<p>时间复杂度：O(N log N)，其中N为排序元素的个数。实际实现通常使用快速排序、堆排序和插入排序的混合算法，在最坏情况下保证O(N log N)。</p>
<p>空间复杂度：O(log N)，用于递归调用栈。</p>
<p>使用场景：</p>
<ul>
<li>需要对数组、vector等随机访问容器进行快速排序</li>
<li>可以用于基本数据类型和自定义类型的排序</li>
<li>当需要稳定排序（保持相等元素的相对顺序）时，应使用<code>stable_sort</code>而非<code>sort</code></li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>};
<span class="hljs-comment">// 升序排序 - sort将v中的元素按从小到大排序</span>
<span class="hljs-comment">// 调用后v中的元素会被重新排列为{1, 2, 5, 8, 9}</span>
sort(v.begin(), v.end());
<span class="hljs-comment">// 结果: {1, 2, 5, 8, 9}</span>

<span class="hljs-comment">// 降序排序 - 使用greater&lt;int&gt;()作为比较函数</span>
<span class="hljs-comment">// greater&lt;int&gt;()是一个函数对象，当a&gt;b时返回true，实现从大到小排序</span>
sort(v.begin(), v.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: {9, 8, 5, 2, 1}</span>

<span class="hljs-comment">// 使用自定义比较函数 - lambda表达式实现降序排序</span>
<span class="hljs-comment">// [](int a, int b) { return a &gt; b; } 定义了一个匿名函数，当a&gt;b时返回true</span>
<span class="hljs-comment">// 这使得排序算法将较大的元素放在前面，实现降序排序</span>
sort(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
    <span class="hljs-keyword">return</span> a &gt; b;  <span class="hljs-comment">// 降序排序：当a&gt;b时返回true，表示a应排在b前面</span>
});

<span class="hljs-comment">// 结构体排序 - 根据Person的age字段升序排序</span>
<span class="hljs-keyword">struct</span> Person {
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> age;
};
<span class="hljs-built_in">vector</span>&lt;Person&gt; people = { {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">25</span>}, {<span class="hljs-string">"Bob"</span>, <span class="hljs-number">20</span>}, {<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">30</span>} };
<span class="hljs-comment">// 使用Lambda表达式作为比较函数，比较两个Person对象的age字段</span>
<span class="hljs-comment">// 当a.age &lt; b.age时返回true，这样年龄小的Person将排在前面</span>
sort(people.begin(), people.end(), [](<span class="hljs-keyword">const</span> Person&amp; a, <span class="hljs-keyword">const</span> Person&amp; b) {
    <span class="hljs-keyword">return</span> a.age &lt; b.age;  <span class="hljs-comment">// 按年龄升序排序</span>
});

<span class="hljs-comment">// 多字段排序 - 先按年龄升序，年龄相同时按姓名字母顺序排序</span>
sort(people.begin(), people.end(), [](<span class="hljs-keyword">const</span> Person&amp; a, <span class="hljs-keyword">const</span> Person&amp; b) {
    <span class="hljs-keyword">if</span> (a.age != b.age) <span class="hljs-keyword">return</span> a.age &lt; b.age;  <span class="hljs-comment">// 主要排序键：年龄</span>
    <span class="hljs-keyword">return</span> a.name &lt; b.name;  <span class="hljs-comment">// 次要排序键：姓名</span>
});
</code></pre>
<p>错误处理：</p>
<ul>
<li>如果提供的迭代器不是随机访问迭代器，将导致编译错误</li>
<li>比较函数必须提供严格弱序关系，否则行为未定义</li>
<li>使用有问题的比较函数（如不满足传递性）可能导致排序结果不确定</li>
</ul>
<p>注意事项：</p>
<ul>
<li><code>sort</code>是不稳定的排序算法，不保证相等元素的相对顺序</li>
<li>比较函数必须定义<strong>严格弱序</strong>关系，即满足以下性质：<ul>
<li>非自反性：对于任意x，不能有x&lt;x为真</li>
<li>非对称性：如果x&lt;y为真，则y&lt;x为假</li>
<li>传递性：如果x&lt;y为真且y&lt;z为真，则x&lt;z为真</li>
</ul>
</li>
<li>只适用于随机访问迭代器的容器，如vector、array、deque等</li>
<li>对于list等非随机访问的容器，应使用其成员函数sort</li>
<li>在处理大型对象时，尽量使用引用作为比较函数的参数类型，避免不必要的拷贝</li>
</ul>
<h4 id="stablesort"><code>stable_sort</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 稳定排序，保持相等元素的相对顺序</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first: 指向要排序范围首元素的迭代器</span>
<span class="hljs-comment">// - last: 指向要排序范围末尾的下一个元素的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选），接收两个元素并返回bool值</span>
stable_sort(first, last, comp);
</code></pre>
<p>参数和用法同 <code>sort</code>，但保证相等元素的相对顺序不变。</p>
<p>时间复杂度：</p>
<ul>
<li>O(N log N)（如果有足够额外内存）</li>
<li>O(N (log N)²)（在最坏情况下）</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">struct</span> Student {
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> grade;
};
<span class="hljs-built_in">vector</span>&lt;Student&gt; students = {
    {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">90</span>}, {<span class="hljs-string">"Bob"</span>, <span class="hljs-number">85</span>}, {<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">90</span>}, {<span class="hljs-string">"David"</span>, <span class="hljs-number">85</span>}
};

<span class="hljs-comment">// 按成绩降序排序，成绩相同时保持原有顺序</span>
<span class="hljs-comment">// 当grade相同时，stable_sort保证了元素的相对顺序不变</span>
<span class="hljs-comment">// 例如，Alice和Charlie的grade都是90，排序后Alice仍在Charlie之前</span>
stable_sort(students.begin(), students.end(), [](<span class="hljs-keyword">const</span> Student&amp; a, <span class="hljs-keyword">const</span> Student&amp; b) {
    <span class="hljs-keyword">return</span> a.grade &gt; b.grade;
});
<span class="hljs-comment">// 结果: [{"Alice", 90}, {"Charlie", 90}, {"Bob", 85}, {"David", 85}]</span>
</code></pre>
<h4 id="partialsort"><code>partial_sort</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将范围中最小的N个元素排序放在开头</span>
<span class="hljs-comment">// 返回值：指向排好序部分末尾的迭代器（即middle）</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first: 范围起始迭代器</span>
<span class="hljs-comment">// - middle: 部分排序结束位置（排序[first,middle)区间）</span>
<span class="hljs-comment">// - last: 范围结束迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
partial_sort(first, middle, last, comp);
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>first</code>：范围起始迭代器</li>
<li><code>middle</code>：部分排序结束位置（排序[first,middle)区间）</li>
<li><code>last</code>：范围结束迭代器</li>
<li><code>comp</code>：比较函数（可选）</li>
</ul>
<p>时间复杂度：O(N log M)，其中N是范围大小，M是要排序的元素个数</p>
<p>使用场景：当只需要前k小/大元素时，比完全排序更高效</p>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>};
<span class="hljs-comment">// 对前5个最小元素排序</span>
<span class="hljs-comment">// 此操作将v中最小的5个元素（即1,2,3,4,5）排序并放在v的前5个位置</span>
<span class="hljs-comment">// v.begin() + 5表示排序截止的位置，v.end()表示要考虑的全部元素范围</span>
partial_sort(v.begin(), v.begin() + <span class="hljs-number">5</span>, v.end());
<span class="hljs-comment">// 可能结果: {1, 2, 3, 4, 5, ?, ?, ?, ?}，其中?表示未排序的元素</span>
<span class="hljs-comment">// 注意：后面的元素不保证任何特定顺序，只确保它们都大于或等于前5个元素</span>
</code></pre>
<h4 id="nthelement"><code>nth_element</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将第n小的元素放在正确位置，并将小于它的元素放在它前面，大于它的放在后面</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first: 范围起始迭代器</span>
<span class="hljs-comment">// - nth: 指向要定位的元素的迭代器</span>
<span class="hljs-comment">// - last: 范围结束迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
nth_element(first, nth, last, comp);
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>first</code>：范围起始迭代器</li>
<li><code>nth</code>：指向要定位的元素的迭代器</li>
<li><code>last</code>：范围结束迭代器</li>
<li><code>comp</code>：比较函数（可选）</li>
</ul>
<p>时间复杂度：平均O(N)，最坏O(N²)</p>
<p>使用场景：</p>
<ul>
<li>查找中位数、分位数</li>
<li>需要将数组划分为两部分，但不需要完全排序</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>};
<span class="hljs-comment">// 找出第5小的元素（索引为4）</span>
<span class="hljs-comment">// 此操作将把第5小的元素（值为5）放在v[4]的位置</span>
<span class="hljs-comment">// 保证v[0]到v[3]的所有元素都小于等于v[4]，v[5]到v[8]的所有元素都大于等于v[4]</span>
nth_element(v.begin(), v.begin() + <span class="hljs-number">4</span>, v.end());
<span class="hljs-comment">// v[4]是第5小的元素，前面的元素都小于等于它，后面的元素都大于等于它</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"第5小的元素是: "</span> &lt;&lt; v[<span class="hljs-number">4</span>] &lt;&lt; endl;

<span class="hljs-comment">// 找中位数</span>
<span class="hljs-comment">// 将v.size()/2位置的元素（即中位数）放在正确的位置</span>
<span class="hljs-comment">// 对于含有9个元素的v，中位数索引为4，值为5</span>
nth_element(v.begin(), v.begin() + v.size()/<span class="hljs-number">2</span>, v.end());
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"中位数是: "</span> &lt;&lt; v[v.size()/<span class="hljs-number">2</span>] &lt;&lt; endl;
</code></pre>
<h4 id="binarysearch"><code>binary_search</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 二分查找，返回元素是否存在</span>
<span class="hljs-comment">// 返回值：bool值，表示值是否在有序区间中</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 指定查找范围的迭代器</span>
<span class="hljs-comment">// - value: 要查找的值</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(first, last, value, comp)</span></span>;
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>first</code>、<code>last</code>：指定查找范围的迭代器</li>
<li><code>value</code>：要查找的值</li>
<li><code>comp</code>：比较函数（可选）</li>
</ul>
<p>时间复杂度：O(log N)</p>
<p>前提条件：</p>
<ul>
<li>区间必须已经排序</li>
<li>对于自定义比较函数，区间必须按照该函数规定的顺序排序</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>};
<span class="hljs-comment">// 在已排序的vector中查找值5</span>
<span class="hljs-comment">// binary_search返回true，因为5存在于v中</span>
<span class="hljs-keyword">bool</span> found = binary_search(v.begin(), v.end(), <span class="hljs-number">5</span>); <span class="hljs-comment">// 返回 true</span>
<span class="hljs-comment">// 查找不存在的值6</span>
<span class="hljs-comment">// binary_search返回false，因为6不存在于v中</span>
found = binary_search(v.begin(), v.end(), <span class="hljs-number">6</span>);     <span class="hljs-comment">// 返回 false</span>

<span class="hljs-comment">// 使用自定义比较函数进行查找</span>
<span class="hljs-comment">// 这里使用lambda表达式定义比较函数，当a&lt;b时返回true</span>
<span class="hljs-keyword">bool</span> found_custom = binary_search(v.begin(), v.end(), <span class="hljs-number">5</span>, [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
    <span class="hljs-keyword">return</span> a &lt; b;  <span class="hljs-comment">// 升序排序下的查找</span>
});
</code></pre>
<p>注意事项：</p>
<ul>
<li>仅返回是否存在，不返回元素位置</li>
<li>如果需要获取位置，应使用<code>lower_bound</code>或<code>upper_bound</code></li>
</ul>
<h4 id="lowerbound"><code>lower_bound</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 返回指向不小于指定值的第一个元素的迭代器</span>
<span class="hljs-comment">// 返回值：迭代器，指向第一个大于等于value的元素；如果所有元素都小于value，则返回last</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 指定查找范围的迭代器</span>
<span class="hljs-comment">// - value: 查找的值</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> it = lower_bound(first, last, value, comp);
</code></pre>
<p>时间复杂度：O(log N)</p>
<p>使用场景：</p>
<ul>
<li>查找第一个大于等于某值的元素</li>
<li>在有序数组中查找插入位置</li>
<li>处理有重复元素的有序区间</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 查找第一个大于等于3的元素</span>
<span class="hljs-comment">// lower_bound返回指向第一个值为3的迭代器（索引为3的位置）</span>
<span class="hljs-keyword">auto</span> it = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>);
<span class="hljs-keyword">int</span> pos = it - v.begin(); <span class="hljs-comment">// 返回位置 3</span>

<span class="hljs-comment">// 查找第一个不小于2.5的元素</span>
<span class="hljs-comment">// 在v中没有2.5，所以lower_bound返回指向第一个大于2.5的元素，即索引为2的第一个3</span>
<span class="hljs-keyword">auto</span> it2 = lower_bound(v.begin(), v.end(), <span class="hljs-number">2.5</span>);
<span class="hljs-keyword">int</span> pos2 = it2 - v.begin(); <span class="hljs-comment">// 返回位置 2 (指向第一个3)</span>

<span class="hljs-comment">// 计算有序容器中元素的出现次数</span>
<span class="hljs-comment">// 使用upper_bound和lower_bound的差值计算元素3出现的次数</span>
<span class="hljs-comment">// upper_bound(v, 3) - lower_bound(v, 3) = 索引6 - 索引3 = 3</span>
<span class="hljs-keyword">int</span> val = <span class="hljs-number">3</span>;
<span class="hljs-keyword">int</span> count = upper_bound(v.begin(), v.end(), val) - lower_bound(v.begin(), v.end(), val);
<span class="hljs-comment">// count = 3，表示值3出现了3次</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>如果没找到（所有元素都小于value），返回last迭代器</li>
<li>区间必须已排序</li>
<li>通常与upper_bound配合使用</li>
</ul>
<h4 id="upperbound"><code>upper_bound</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 返回指向大于指定值的第一个元素的迭代器</span>
<span class="hljs-comment">// 返回值：迭代器，指向第一个大于value的元素；如果所有元素都不大于value，则返回last</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 指定查找范围的迭代器</span>
<span class="hljs-comment">// - value: 查找的值</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> it = upper_bound(first, last, value, comp);
</code></pre>
<p>时间复杂度：O(log N)</p>
<p>使用场景：</p>
<ul>
<li>查找第一个大于某值的元素</li>
<li>与lower_bound配合查找某个值的范围</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 查找第一个大于3的元素</span>
<span class="hljs-comment">// upper_bound返回指向第一个大于3的元素，即值为4的位置（索引为6）</span>
<span class="hljs-keyword">auto</span> it = upper_bound(v.begin(), v.end(), <span class="hljs-number">3</span>);
<span class="hljs-keyword">int</span> pos = it - v.begin(); <span class="hljs-comment">// 返回位置 6（指向4）</span>

<span class="hljs-comment">// 查找一个不存在的值的上界</span>
<span class="hljs-comment">// upper_bound返回指向第一个大于3.5的元素，即值为4的位置（索引为6）</span>
<span class="hljs-keyword">auto</span> it2 = upper_bound(v.begin(), v.end(), <span class="hljs-number">3.5</span>);
<span class="hljs-keyword">int</span> pos2 = it2 - v.begin(); <span class="hljs-comment">// 返回位置 6（指向4）</span>

<span class="hljs-comment">// 配合lower_bound获取等值区间</span>
<span class="hljs-comment">// 获取所有值为3的元素的范围</span>
<span class="hljs-keyword">auto</span> range_begin = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>); <span class="hljs-comment">// 索引3</span>
<span class="hljs-keyword">auto</span> range_end = upper_bound(v.begin(), v.end(), <span class="hljs-number">3</span>);   <span class="hljs-comment">// 索引6</span>
<span class="hljs-comment">// 现在[range_begin, range_end)包含所有值为3的元素（索引3,4,5）</span>
<span class="hljs-comment">// 可以用于遍历所有值为3的元素</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = range_begin; it != range_end; ++it) {
    <span class="hljs-comment">// 对每个值为3的元素进行操作</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">" at position "</span> &lt;&lt; (it - v.begin()) &lt;&lt; endl;
}
</code></pre>
<p>注意事项：</p>
<ul>
<li>如果没找到（所有元素都不大于value），返回last迭代器</li>
<li>区间必须已排序</li>
</ul>
<h4 id="equalrange"><code>equal_range</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 返回等于指定值的元素范围，返回pair&lt;迭代器,迭代器&gt;</span>
<span class="hljs-comment">// 返回值：pair对象，first成员是lower_bound的结果，second成员是upper_bound的结果</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 指定查找范围的迭代器</span>
<span class="hljs-comment">// - value: 查找的值</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> range = equal_range(first, last, value, comp);
</code></pre>
<p>时间复杂度：O(log N)</p>
<p>使用场景：</p>
<ul>
<li>需要同时获取lower_bound和upper_bound时</li>
<li>在排序容器中寻找等值区间</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 获取所有等于3的元素范围</span>
<span class="hljs-comment">// equal_range返回的pair中，first指向第一个值为3的元素（索引3）</span>
<span class="hljs-comment">// second指向第一个大于3的元素（索引6）</span>
<span class="hljs-keyword">auto</span> range = equal_range(v.begin(), v.end(), <span class="hljs-number">3</span>);
<span class="hljs-keyword">int</span> first_pos = range.first - v.begin();   <span class="hljs-comment">// 返回 3</span>
<span class="hljs-keyword">int</span> last_pos = range.second - v.begin();   <span class="hljs-comment">// 返回 6</span>
<span class="hljs-comment">// [range.first, range.second)区间内的所有值都等于3</span>
<span class="hljs-comment">// 可以用于检查元素数量或遍历所有匹配元素</span>
<span class="hljs-keyword">int</span> count = range.second - range.first; <span class="hljs-comment">// 值为3的元素数量</span>

<span class="hljs-comment">// 检查元素是否存在更简洁的方法</span>
<span class="hljs-comment">// 对于不存在的值7，equal_range返回的range.first和range.second相等</span>
<span class="hljs-keyword">auto</span> range2 = equal_range(v.begin(), v.end(), <span class="hljs-number">7</span>);
<span class="hljs-keyword">bool</span> exists = (range2.first != range2.second); <span class="hljs-comment">// 返回false，因为7不存在</span>
<span class="hljs-comment">// 如果元素存在，range2.first和range2.second之间会有至少一个元素</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>equal_range相当于同时调用lower_bound和upper_bound</li>
<li>区间必须已排序</li>
</ul>
<h3 id="集合操作">集合操作</h3>
<h4 id="merge"><code>merge</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 合并两个已排序的区间到目标区间</span>
<span class="hljs-comment">// 返回值：指向目标区间末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first1, last1: 第一个已排序范围的迭代器</span>
<span class="hljs-comment">// - first2, last2: 第二个已排序范围的迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> result_end = merge(first1, last1, first2, last2, result, comp);
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>first1</code>, <code>last1</code>：第一个已排序范围</li>
<li><code>first2</code>, <code>last2</code>：第二个已排序范围</li>
<li><code>result</code>：目标范围的起始迭代器</li>
<li><code>comp</code>：比较函数（可选）</li>
</ul>
<p>时间复杂度：O(N+M)，其中N和M是两个输入范围的大小</p>
<p>前提条件：两个输入范围都必须已经按相同顺序排序</p>
<p>使用场景：</p>
<ul>
<li>合并两个有序数组</li>
<li>归并排序算法实现</li>
<li>在保持顺序的前提下组合两个数据集</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v1.size() + v2.size());
<span class="hljs-comment">// 合并两个有序向量v1和v2到result中</span>
<span class="hljs-comment">// merge函数保持元素的有序性，按照从小到大排序合并</span>
<span class="hljs-comment">// 返回值是指向结果序列末尾的迭代器</span>
<span class="hljs-keyword">auto</span> end_it = merge(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());
<span class="hljs-comment">// 结果: {1, 2, 3, 4, 5, 6, 7, 8}</span>
<span class="hljs-comment">// 可以用返回值检查合并的元素个数</span>
<span class="hljs-keyword">int</span> merged_count = end_it - result.begin(); <span class="hljs-comment">// 应为8</span>

<span class="hljs-comment">// 使用比较函数进行降序合并</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; desc_v1 = {<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; desc_v2 = {<span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>};
<span class="hljs-comment">// 使用greater&lt;int&gt;()作为比较函数，表示在比较时认为greater返回true的元素排在前面</span>
<span class="hljs-comment">// 因此合并的结果是降序的</span>
<span class="hljs-keyword">auto</span> desc_end_it = merge(desc_v1.begin(), desc_v1.end(), desc_v2.begin(), desc_v2.end(), 
      result.begin(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: {8, 7, 6, 5, 4, 3, 2, 1}</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>目标区间必须有足够的空间</li>
<li>对于目标与源重叠的情况，结果不确定</li>
</ul>
<h4 id="inplacemerge"><code>inplace_merge</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将同一序列中的两个连续有序子序列合并为一个有序序列</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first: 序列起始位置</span>
<span class="hljs-comment">// - middle: 第一个子序列的结束位置（也是第二个子序列的起始位置）</span>
<span class="hljs-comment">// - last: 序列结束位置</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
inplace_merge(first, middle, last, comp);
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>first</code>：序列起始位置</li>
<li><code>middle</code>：第一个子序列的结束位置（也是第二个子序列的起始位置）</li>
<li><code>last</code>：序列结束位置</li>
<li><code>comp</code>：比较函数（可选）</li>
</ul>
<p>时间复杂度：</p>
<ul>
<li>如果有足够的额外内存：O(N)</li>
<li>否则：O(N log N)</li>
</ul>
<p>使用场景：</p>
<ul>
<li>归并排序的一部分</li>
<li>当已经有两个相邻的有序子序列需要合并时</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>};
<span class="hljs-comment">// v中[0,4)和[4,8)两个子序列都已排序</span>
<span class="hljs-comment">// inplace_merge将这两个有序子序列原地合并成一个有序序列</span>
<span class="hljs-comment">// 操作会修改v，使整个范围变为有序</span>
inplace_merge(v.begin(), v.begin() + <span class="hljs-number">4</span>, v.end());
<span class="hljs-comment">// 结果: {1, 2, 3, 4, 5, 6, 7, 8}</span>

<span class="hljs-comment">// 使用自定义比较函数进行降序合并</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; desc_v = {<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>};
<span class="hljs-comment">// 两个子序列分别是[0,4)和[4,8)，都是降序排列的</span>
inplace_merge(desc_v.begin(), desc_v.begin() + <span class="hljs-number">4</span>, desc_v.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: {8, 7, 6, 5, 4, 3, 2, 1}</span>
</code></pre>
<h4 id="setunion"><code>set_union</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算两个已排序区间的并集</span>
<span class="hljs-comment">// 返回值：指向结果集合末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first1, last1: 第一个已排序范围</span>
<span class="hljs-comment">// - first2, last2: 第二个已排序范围</span>
<span class="hljs-comment">// - result: 存储结果的起始迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> end_it = set_union(first1, last1, first2, last2, result, comp);
</code></pre>
<p>时间复杂度：O(N+M)，其中N和M是两个输入范围的大小</p>
<p>使用场景：</p>
<ul>
<li>需要合并两个集合且不重复</li>
<li>在有序集合上执行集合运算</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 足够大以容纳所有可能结果</span>
<span class="hljs-comment">// 计算v1和v2的并集</span>
<span class="hljs-comment">// set_union返回一个指向结果范围末尾的迭代器</span>
<span class="hljs-keyword">auto</span> it = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());
<span class="hljs-comment">// 调整result的大小为实际元素个数</span>
result.resize(it - result.begin());
<span class="hljs-comment">// 结果: {1, 2, 3, 4, 5, 6, 7}</span>
<span class="hljs-comment">// 注意：并集中的每个元素只出现一次</span>

<span class="hljs-comment">// 处理重复元素</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v4 = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
result.resize(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 重置result大小</span>
it = set_union(v3.begin(), v3.end(), v4.begin(), v4.end(), result.begin());
result.resize(it - result.begin());
<span class="hljs-comment">// 结果: {1, 2, 2, 3, 3, 4, 5}</span>
<span class="hljs-comment">// 注意重复元素在结果中的出现次数是两个输入序列中该元素出现次数的最大值</span>
<span class="hljs-comment">// v3中有2个'2'，v4中有1个'2'，并集中有2个'2'</span>
<span class="hljs-comment">// v3中有1个'3'，v4中有2个'3'，并集中有2个'3'</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>两个输入区间必须已排序</li>
<li>结果区间需要有足够空间</li>
<li>函数返回的是结果序列的末尾迭代器</li>
</ul>
<h4 id="setintersection"><code>set_intersection</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算两个已排序区间的交集</span>
<span class="hljs-comment">// 返回值：指向结果集合末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first1, last1: 第一个已排序范围</span>
<span class="hljs-comment">// - first2, last2: 第二个已排序范围</span>
<span class="hljs-comment">// - result: 存储结果的起始迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> end_it = set_intersection(first1, last1, first2, last2, result, comp);
</code></pre>
<p>时间复杂度：O(N+M)，其中N和M是两个输入范围的大小</p>
<p>使用场景：</p>
<ul>
<li>查找两个集合的共有元素</li>
<li>确定共同兴趣、共同特征等</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 足够大以容纳可能的结果</span>
<span class="hljs-comment">// 计算v1和v2的交集</span>
<span class="hljs-comment">// set_intersection返回指向结果范围末尾的迭代器</span>
<span class="hljs-keyword">auto</span> it = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());
<span class="hljs-comment">// 调整result的大小为实际元素个数</span>
result.resize(it - result.begin());
<span class="hljs-comment">// 结果: {3, 4, 5} - 这些是v1和v2中共有的元素</span>

<span class="hljs-comment">// 处理重复元素</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v4 = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
result.resize(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 重置result大小</span>
it = set_intersection(v3.begin(), v3.end(), v4.begin(), v4.end(), result.begin());
result.resize(it - result.begin());
<span class="hljs-comment">// 结果: {2, 3, 4}</span>
<span class="hljs-comment">// 注意重复元素在结果中的出现次数是两个输入序列中该元素出现次数的最小值</span>
<span class="hljs-comment">// v3中有两个2，v4中有一个2，交集中有一个2</span>
<span class="hljs-comment">// v3中有一个3，v4中有两个3，交集中有一个3</span>
</code></pre>
<h4 id="setdifference"><code>set_difference</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算两个已排序区间的差集 (在区间1中但不在区间2中)</span>
<span class="hljs-comment">// 返回值：指向结果集合末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first1, last1: 第一个已排序范围</span>
<span class="hljs-comment">// - first2, last2: 第二个已排序范围</span>
<span class="hljs-comment">// - result: 存储结果的起始迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> end_it = set_difference(first1, last1, first2, last2, result, comp);
</code></pre>
<p>时间复杂度：O(N+M)，其中N和M是两个输入范围的大小</p>
<p>使用场景：</p>
<ul>
<li>找出第一个集合中独有的元素</li>
<li>移除共有元素</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(<span class="hljs-number">5</span>);
<span class="hljs-comment">// 计算v1和v2的差集（在v1中但不在v2中）</span>
<span class="hljs-comment">// set_difference返回指向结果范围末尾的迭代器</span>
<span class="hljs-keyword">auto</span> it = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());
<span class="hljs-comment">// 调整result的大小为实际元素个数</span>
result.resize(it - result.begin());
<span class="hljs-comment">// 结果: {1, 2}</span>

<span class="hljs-comment">// 注意差集不是对称的</span>
<span class="hljs-comment">// 计算v2和v1的差集（在v2中但不在v1中）</span>
it = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), result.begin());
result.resize(it - result.begin());
<span class="hljs-comment">// 结果: {6, 7}</span>

<span class="hljs-comment">// 处理重复元素</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v4 = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
result.resize(<span class="hljs-number">5</span>);
it = set_difference(v3.begin(), v3.end(), v4.begin(), v4.end(), result.begin());
result.resize(it - result.begin());
<span class="hljs-comment">// 结果: {1, 2} </span>
<span class="hljs-comment">// v3中有两个2，v4中有一个2，差集中保留一个2</span>
</code></pre>
<h4 id="setsymmetricdifference"><code>set_symmetric_difference</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算两个已排序区间的对称差集 (在区间1或区间2中，但不同时在两者中)</span>
<span class="hljs-comment">// 返回值：指向结果集合末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first1, last1: 第一个已排序范围</span>
<span class="hljs-comment">// - first2, last2: 第二个已排序范围</span>
<span class="hljs-comment">// - result: 存储结果的起始迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> end_it = set_symmetric_difference(first1, last1, first2, last2, result, comp);
</code></pre>
<p>时间复杂度：O(N+M)，其中N和M是两个输入范围的大小</p>
<p>使用场景：</p>
<ul>
<li>寻找两个集合中不共有的元素</li>
<li>XOR类型的集合运算</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(<span class="hljs-number">10</span>);
<span class="hljs-comment">// 计算v1和v2的对称差集（在v1或v2中，但不同时在两者中）</span>
<span class="hljs-comment">// set_symmetric_difference返回指向结果范围末尾的迭代器</span>
<span class="hljs-keyword">auto</span> it = set_symmetric_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());
<span class="hljs-comment">// 调整result的大小为实际元素个数</span>
result.resize(it - result.begin());
<span class="hljs-comment">// 结果: {1, 2, 6, 7}</span>

<span class="hljs-comment">// 处理重复元素</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v4 = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
result.resize(<span class="hljs-number">10</span>);
it = set_symmetric_difference(v3.begin(), v3.end(), v4.begin(), v4.end(), result.begin());
result.resize(it - result.begin());
<span class="hljs-comment">// 结果: {1, 2, 3, 5}</span>
<span class="hljs-comment">// v3有两个2，v4有一个2，对称差集中有一个2</span>
<span class="hljs-comment">// v4有两个3，v3有一个3，对称差集中有一个3</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>对称差集是元素在一个集合但不在另一个集合中的所有元素</li>
<li>可以看作是 (A-B) ∪ (B-A)</li>
</ul>
<h3 id="数值算法">数值算法</h3>
<h4 id="count--countif"><code>count</code> / <code>count_if</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算指定元素在范围中的出现次数</span>
<span class="hljs-comment">// 返回值：int，表示元素出现的次数</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 指定范围的迭代器</span>
<span class="hljs-comment">// - value: 要计数的值</span>
<span class="hljs-keyword">int</span> num = count(first, last, value);

<span class="hljs-comment">// 计算满足谓词条件的元素个数</span>
<span class="hljs-comment">// 返回值：int，表示满足条件的元素个数</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 指定范围的迭代器</span>
<span class="hljs-comment">// - pred: 谓词函数，接收一个元素并返回bool值</span>
<span class="hljs-keyword">int</span> num = count_if(first, last, pred);
</code></pre>
<p>时间复杂度：O(N)，其中N是范围内的元素个数</p>
<p>使用场景：</p>
<ul>
<li>统计特定元素出现次数</li>
<li>统计满足特定条件的元素个数</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>};
<span class="hljs-comment">// 计算值为2的元素出现次数</span>
<span class="hljs-keyword">int</span> cnt = count(v.begin(), v.end(), <span class="hljs-number">2</span>); <span class="hljs-comment">// 返回 3</span>

<span class="hljs-comment">// 计算满足条件的元素个数</span>
<span class="hljs-comment">// 这里使用lambda表达式定义谓词函数，判断元素是否为偶数</span>
<span class="hljs-keyword">int</span> even_count = count_if(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> x) { 
    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; 
}); <span class="hljs-comment">// 返回 3（2出现三次）</span>

<span class="hljs-comment">// 在字符串中计数</span>
<span class="hljs-built_in">string</span> str = <span class="hljs-string">"Hello World"</span>;
<span class="hljs-comment">// 计算字符'l'出现的次数</span>
<span class="hljs-keyword">int</span> l_count = count(str.begin(), str.end(), <span class="hljs-string">'l'</span>); <span class="hljs-comment">// 返回 3</span>

<span class="hljs-comment">// 复杂条件统计</span>
<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&gt; students = {
    {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">85</span>}, {<span class="hljs-string">"Bob"</span>, <span class="hljs-number">92</span>}, {<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">85</span>}, {<span class="hljs-string">"David"</span>, <span class="hljs-number">78</span>}
};
<span class="hljs-comment">// 计算成绩大于等于85的学生数量</span>
<span class="hljs-keyword">int</span> high_score = count_if(students.begin(), students.end(), [](<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&amp; s) {
    <span class="hljs-keyword">return</span> s.second &gt;= <span class="hljs-number">85</span>;
}); <span class="hljs-comment">// 返回 3</span>
</code></pre>
<h4 id="minelement--maxelement--minmaxelement"><code>min_element</code> / <code>max_element</code> / <code>minmax_element</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 返回范围中最小/最大元素的迭代器</span>
<span class="hljs-comment">// 返回值：迭代器，指向最小/最大元素</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 指定范围的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> min_it = min_element(first, last, comp);
<span class="hljs-keyword">auto</span> max_it = max_element(first, last, comp);

<span class="hljs-comment">// 返回范围中最小和最大元素的迭代器</span>
<span class="hljs-comment">// 返回值：pair对象，first成员是最小元素的迭代器，second成员是最大元素的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 指定范围的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">auto</span> minmax = minmax_element(first, last, comp);
</code></pre>
<p>时间复杂度：</p>
<ul>
<li><code>min_element</code>/<code>max_element</code>: O(N)</li>
<li><code>minmax_element</code>: O(N)，但比单独调用min_element和max_element更高效</li>
</ul>
<p>使用场景：</p>
<ul>
<li>寻找数组中的最值</li>
<li>寻找最大/最小对象</li>
<li>同时需要最大和最小值时</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>};
<span class="hljs-comment">// 查找最小元素</span>
<span class="hljs-keyword">auto</span> min_it = min_element(v.begin(), v.end()); <span class="hljs-comment">// 指向 1</span>
<span class="hljs-comment">// 查找最大元素</span>
<span class="hljs-keyword">auto</span> max_it = max_element(v.begin(), v.end()); <span class="hljs-comment">// 指向 9</span>

<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"最小值: "</span> &lt;&lt; *min_it &lt;&lt; <span class="hljs-string">" 位置: "</span> &lt;&lt; (min_it - v.begin()) &lt;&lt; endl;
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"最大值: "</span> &lt;&lt; *max_it &lt;&lt; <span class="hljs-string">" 位置: "</span> &lt;&lt; (max_it - v.begin()) &lt;&lt; endl;

<span class="hljs-comment">// 同时获取最小和最大元素</span>
<span class="hljs-keyword">auto</span> minmax = minmax_element(v.begin(), v.end());
<span class="hljs-keyword">int</span> min_val = *minmax.first;   <span class="hljs-comment">// 1</span>
<span class="hljs-keyword">int</span> max_val = *minmax.second;  <span class="hljs-comment">// 9</span>

<span class="hljs-comment">// 使用自定义比较函数</span>
<span class="hljs-keyword">struct</span> Person {
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> age;
};
<span class="hljs-built_in">vector</span>&lt;Person&gt; people = { {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">25</span>}, {<span class="hljs-string">"Bob"</span>, <span class="hljs-number">20</span>}, {<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">30</span>} };
<span class="hljs-comment">// 查找年龄最大的Person</span>
<span class="hljs-keyword">auto</span> oldest = max_element(people.begin(), people.end(), 
    [](<span class="hljs-keyword">const</span> Person&amp; a, <span class="hljs-keyword">const</span> Person&amp; b) { <span class="hljs-keyword">return</span> a.age &lt; b.age; });
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"最年长的人是: "</span> &lt;&lt; oldest-&gt;name &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; oldest-&gt;age &lt;&lt; <span class="hljs-string">"岁"</span> &lt;&lt; endl;
</code></pre>
<p>注意事项：</p>
<ul>
<li>返回的是迭代器，需要解引用获取值</li>
<li>如果有多个最值元素，返回第一个最小值和最后一个最大值</li>
</ul>
<h4 id="accumulate"><code>accumulate</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算范围内元素的累加和</span>
<span class="hljs-comment">// 需引入头文件 #include &lt;numeric&gt;</span>
<span class="hljs-comment">// 返回值：累加结果</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 指定范围的迭代器</span>
<span class="hljs-comment">// - init_val: 初始值</span>
<span class="hljs-comment">// - op: 二元操作符（可选），默认为加法</span>
T sum = accumulate(first, last, init_val, op);
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>first</code>, <code>last</code>：指定范围</li>
<li><code>init_val</code>：初始值</li>
<li><code>op</code>：二元操作符（可选），默认为加法</li>
</ul>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>计算元素总和</li>
<li>将容器中所有元素连接起来</li>
<li>执行自定义累积操作</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span> // 提供multiplies等函数对象</span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 计算累加和</span>
<span class="hljs-keyword">int</span> sum = accumulate(v.begin(), v.end(), <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回 15</span>

<span class="hljs-comment">// 计算乘积</span>
<span class="hljs-keyword">int</span> product = accumulate(v.begin(), v.end(), <span class="hljs-number">1</span>, multiplies&lt;<span class="hljs-keyword">int</span>&gt;()); <span class="hljs-comment">// 返回 120</span>

<span class="hljs-comment">// 字符串连接</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; words = {<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>, <span class="hljs-string">"C++"</span>};
<span class="hljs-comment">// 使用accumulate将字符串连接起来</span>
<span class="hljs-comment">// next(words.begin())跳过第一个元素，避免在结果前面多一个空格</span>
<span class="hljs-built_in">string</span> sentence = accumulate(next(words.begin()), words.end(), words[<span class="hljs-number">0</span>],
    [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; b) { <span class="hljs-keyword">return</span> a + <span class="hljs-string">" "</span> + b; });
<span class="hljs-comment">// 返回 "Hello World C++"</span>

<span class="hljs-comment">// 更复杂的累积</span>
<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&gt; sales = { {<span class="hljs-string">"A"</span>, <span class="hljs-number">100</span>}, {<span class="hljs-string">"B"</span>, <span class="hljs-number">200</span>}, {<span class="hljs-string">"C"</span>, <span class="hljs-number">150</span>} };
<span class="hljs-comment">// 计算所有销售额的总和</span>
<span class="hljs-keyword">int</span> total = accumulate(sales.begin(), sales.end(), <span class="hljs-number">0</span>,
    [](<span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&amp; p) { <span class="hljs-keyword">return</span> sum + p.second; });
<span class="hljs-comment">// 返回 450</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>初始值的类型决定了累积结果的类型</li>
<li>操作必须满足结合律才能保证结果正确</li>
</ul>
<h4 id="innerproduct"><code>inner_product</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算两个区间的内积，需引入头文件 #include &lt;numeric&gt;</span>
<span class="hljs-comment">// 返回值：内积结果</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first1, last1: 第一个区间的迭代器</span>
<span class="hljs-comment">// - first2: 第二个区间的起始迭代器</span>
<span class="hljs-comment">// - init: 初始值</span>
<span class="hljs-comment">// - binary_op1: 累计操作（默认为加法）</span>
<span class="hljs-comment">// - binary_op2: 元素间操作（默认为乘法）</span>
T result = inner_product(first1, last1, first2, init, binary_op1, binary_op2);
</code></pre>
<p>参数说明：</p>
<ul>
<li><code>first1</code>, <code>last1</code>：第一个区间</li>
<li><code>first2</code>：第二个区间的起始位置</li>
<li><code>init</code>：初始值</li>
<li><code>binary_op1</code>：累计操作（默认为加法）</li>
<li><code>binary_op2</code>：元素间操作（默认为乘法）</li>
</ul>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>计算向量点积</li>
<li>计算加权和</li>
<li>比较两个序列的相似度</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>};

<span class="hljs-comment">// 计算点积: 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32</span>
<span class="hljs-keyword">int</span> dot_product = inner_product(v1.begin(), v1.end(), v2.begin(), <span class="hljs-number">0</span>);
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"点积: "</span> &lt;&lt; dot_product &lt;&lt; endl;

<span class="hljs-comment">// 自定义操作：计算匹配元素数量</span>
<span class="hljs-keyword">int</span> matches = inner_product(v1.begin(), v1.end(), v2.begin(), <span class="hljs-number">0</span>,
                          <span class="hljs-built_in">std</span>::plus&lt;<span class="hljs-keyword">int</span>&gt;(),
                          [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) { <span class="hljs-keyword">return</span> a == b ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; });

<span class="hljs-comment">// 计算欧几里得距离的平方</span>
<span class="hljs-keyword">int</span> euclidean_dist_squared = inner_product(
    v1.begin(), v1.end(), v2.begin(), <span class="hljs-number">0</span>,
    <span class="hljs-built_in">std</span>::plus&lt;<span class="hljs-keyword">int</span>&gt;(),
    [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) { <span class="hljs-keyword">return</span> (a - b) * (a - b); });
</code></pre>
<p>注意事项：</p>
<ul>
<li>第二个区间至少需要与第一个区间相同长度</li>
<li>操作的顺序是先应用binary_op2到对应元素，然后用binary_op1累积结果</li>
</ul>
<h4 id="partialsum"><code>partial_sum</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算部分和序列，需引入头文件 #include &lt;numeric&gt;</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result: 输出范围的起始迭代器</span>
<span class="hljs-comment">// - op: 二元操作（可选），默认为加法</span>
partial_sum(first, last, result, op);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>参数说明：</p>
<ul>
<li><code>first</code>, <code>last</code>：输入范围</li>
<li><code>result</code>：输出范围的起始位置</li>
<li><code>op</code>：二元操作（可选），默认为加法</li>
</ul>
<p>使用场景：</p>
<ul>
<li>计算前缀和</li>
<li>计算累积乘积</li>
<li>动态规划中的状态转移</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v.size());

<span class="hljs-comment">// 计算部分和</span>
partial_sum(v.begin(), v.end(), result.begin());
<span class="hljs-comment">// 结果: {1, 3, 6, 10, 15}</span>

<span class="hljs-comment">// 使用自定义操作：累积乘积</span>
partial_sum(v.begin(), v.end(), result.begin(), multiplies&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: {1, 2, 6, 24, 120}</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>输出序列可以与输入序列相同</li>
<li>一般用于快速计算前缀和，避免重复累加计算</li>
</ul>
<h4 id="adjacentdifference"><code>adjacent_difference</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算相邻元素的差，需引入头文件 #include &lt;numeric&gt;</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result: 输出范围的起始迭代器</span>
<span class="hljs-comment">// - op: 二元操作（可选），默认为减法</span>
adjacent_difference(first, last, result, op);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>参数说明：</p>
<ul>
<li><code>first</code>, <code>last</code>：输入范围</li>
<li><code>result</code>：输出范围的起始位置</li>
<li><code>op</code>：二元操作（可选），默认为减法</li>
</ul>
<p>使用场景：</p>
<ul>
<li>计算序列的差分</li>
<li>寻找序列中的变化</li>
<li>时间序列分析</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v.size());

<span class="hljs-comment">// 计算相邻元素的差</span>
adjacent_difference(v.begin(), v.end(), result.begin());
<span class="hljs-comment">// 结果: {1, 2, 3, 4, 5}</span>
<span class="hljs-comment">// 第一个元素保持不变，其余元素为当前元素减前一个元素</span>

<span class="hljs-comment">// 使用自定义操作：计算比值</span>
adjacent_difference(v.begin(), v.end(), result.begin(), 
                   [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) { <span class="hljs-keyword">return</span> a / b; });
<span class="hljs-comment">// 结果: {1, 3, 2, 10/6, 15/10} = {1, 3, 2, 1.67, 1.5}</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>第一个元素直接复制，不应用操作</li>
<li>输入输出范围可以是同一序列</li>
</ul>
<h4 id="iota"><code>iota</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 用连续递增的值填充范围，需引入头文件 #include &lt;numeric&gt;</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 要填充的范围的迭代器</span>
<span class="hljs-comment">// - value: 起始值</span>
iota(first, last, value);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>参数说明：</p>
<ul>
<li><code>first</code>, <code>last</code>：要填充的范围</li>
<li><code>value</code>：起始值</li>
</ul>
<p>使用场景：</p>
<ul>
<li>创建一个递增序列</li>
<li>生成索引数组</li>
<li>初始化容器</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v(<span class="hljs-number">10</span>);
<span class="hljs-comment">// 用0到9填充数组</span>
iota(v.begin(), v.end(), <span class="hljs-number">0</span>);
<span class="hljs-comment">// 结果: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</span>

<span class="hljs-comment">// 创建自定义序列</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; seq(<span class="hljs-number">5</span>);
iota(seq.begin(), seq.end(), <span class="hljs-number">100</span>);
<span class="hljs-comment">// 结果: {100, 101, 102, 103, 104}</span>
</code></pre>
<h3 id="修改序列">修改序列</h3>
<h4 id="copy--copyif--copyn--copybackward"><code>copy</code> / <code>copy_if</code> / <code>copy_n</code> / <code>copy_backward</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 复制元素到目标范围</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-keyword">auto</span> end_it = copy(first, last, result);

<span class="hljs-comment">// 根据条件复制元素</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-comment">// - pred: 谓词函数，接收一个元素并返回bool值</span>
<span class="hljs-keyword">auto</span> end_it = copy_if(first, last, result, pred);

<span class="hljs-comment">// 复制指定数量的元素</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first: 输入范围的起始迭代器</span>
<span class="hljs-comment">// - count: 要复制的元素数量</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-keyword">auto</span> end_it = copy_n(first, count, result);

<span class="hljs-comment">// 从后向前复制（避免覆盖）</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result_end: 目标范围的末尾迭代器</span>
<span class="hljs-keyword">auto</span> end_it = copy_backward(first, last, result_end);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>将一个容器的内容复制到另一个容器</li>
<li>选择性地复制满足条件的元素</li>
<li>处理重叠区域的复制</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2(<span class="hljs-number">5</span>);

<span class="hljs-comment">// 基本复制</span>
copy(v1.begin(), v1.end(), v2.begin());
<span class="hljs-comment">// v2: {1, 2, 3, 4, 5}</span>

<span class="hljs-comment">// 条件复制：只复制偶数</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; even_numbers;
copy_if(v1.begin(), v1.end(), back_inserter(even_numbers), [](<span class="hljs-keyword">int</span> x) {
    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;
});
<span class="hljs-comment">// even_numbers: {2, 4}</span>

<span class="hljs-comment">// 复制前3个元素</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3(<span class="hljs-number">3</span>);
copy_n(v1.begin(), <span class="hljs-number">3</span>, v3.begin());
<span class="hljs-comment">// v3: {1, 2, 3}</span>

<span class="hljs-comment">// 从后向前复制（适用于目标和源重叠的情况）</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v4 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
copy_backward(v4.begin(), v4.begin() + <span class="hljs-number">3</span>, v4.begin() + <span class="hljs-number">4</span>);
<span class="hljs-comment">// v4: {1, 2, 1, 2, 3}</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>目标区域必须有足够空间</li>
<li>使用<code>back_inserter</code>可以避免预分配空间</li>
<li>处理重叠区域时，<code>copy</code>从前向后复制，<code>copy_backward</code>从后向前复制</li>
</ul>
<h4 id="move--movebackward"><code>move</code> / <code>move_backward</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 移动元素到目标范围</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-keyword">auto</span> end_it = move(first, last, result);

<span class="hljs-comment">// 从后向前移动（避免覆盖）</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result_end: 目标范围的末尾迭代器</span>
<span class="hljs-keyword">auto</span> end_it = move_backward(first, last, result_end);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>高效转移资源所有权</li>
<li>避免不必要的拷贝操作</li>
<li>实现移动语义</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v1 = {<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"World"</span>, <span class="hljs-string">"C++"</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v2(<span class="hljs-number">3</span>);

<span class="hljs-comment">// 移动元素（避免拷贝）</span>
move(v1.begin(), v1.end(), v2.begin());
<span class="hljs-comment">// v2包含移动后的字符串，v1中的字符串可能变为空</span>

<span class="hljs-comment">// 处理重叠区域</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; v3 = {<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>};
move_backward(v3.begin(), v3.begin() + <span class="hljs-number">3</span>, v3.begin() + <span class="hljs-number">4</span>);
<span class="hljs-comment">// v3可能变为: {"A", "A", "B", "C", "E"}</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>移动后源对象处于有效但未指定状态</li>
<li>移动语义通常比复制更高效，特别是对于大型对象</li>
</ul>
<h4 id="fill--filln"><code>fill</code> / <code>fill_n</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 用指定值填充范围</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 要填充的范围的迭代器</span>
<span class="hljs-comment">// - value: 填充的值</span>
fill(first, last, value);

<span class="hljs-comment">// 用指定值填充指定数量的元素</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first: 要填充的范围的起始迭代器</span>
<span class="hljs-comment">// - count: 要填充的元素数量</span>
<span class="hljs-comment">// - value: 填充的值</span>
fill_n(first, count, value);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>初始化数组或向量</li>
<li>重置容器的所有值</li>
<li>填充特定区域</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v(<span class="hljs-number">5</span>);
<span class="hljs-comment">// 用7填充整个范围</span>
fill(v.begin(), v.end(), <span class="hljs-number">7</span>);
<span class="hljs-comment">// 结果: {7, 7, 7, 7, 7}</span>

<span class="hljs-comment">// 只填充部分元素</span>
fill_n(v.begin(), <span class="hljs-number">3</span>, <span class="hljs-number">9</span>);
<span class="hljs-comment">// 结果: {9, 9, 9, 7, 7}</span>

<span class="hljs-comment">// 二维数组的初始化</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; matrix(<span class="hljs-number">3</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">3</span>));
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; row : matrix) {
    fill(row.begin(), row.end(), <span class="hljs-number">0</span>);
}
<span class="hljs-comment">// 所有元素都被设置为0</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li><code>fill_n</code> 不检查空间是否足够，调用者需确保有足够空间</li>
<li>对于自定义类型，要确保赋值操作是高效的</li>
</ul>
<h4 id="transform"><code>transform</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 对范围内的元素应用函数，结果放入目标范围</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first1, last1: 输入范围的迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-comment">// - unary_op: 一元操作函数，接收一个元素并返回转换后的值</span>
<span class="hljs-keyword">auto</span> end_it = transform(first1, last1, result, unary_op);

<span class="hljs-comment">// 对两个范围内的对应元素应用二元函数</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first1, last1: 第一个输入范围的迭代器</span>
<span class="hljs-comment">// - first2: 第二个输入范围的起始迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-comment">// - binary_op: 二元操作函数，接收两个元素并返回转换后的值</span>
<span class="hljs-keyword">auto</span> end_it = transform(first1, last1, first2, result, binary_op);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>元素级别的数据转换</li>
<li>对两个序列执行元素对应的运算</li>
<li>应用映射或过滤函数</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v.size());

<span class="hljs-comment">// 一元操作：每个元素平方</span>
transform(v.begin(), v.end(), result.begin(), [](<span class="hljs-keyword">int</span> x) {
    <span class="hljs-keyword">return</span> x * x;
});
<span class="hljs-comment">// 结果: {1, 4, 9, 16, 25}</span>

<span class="hljs-comment">// 二元操作：对应元素相加</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>};
transform(v.begin(), v.end(), v2.begin(), result.begin(), plus&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: {11, 22, 33, 44, 55}</span>

<span class="hljs-comment">// 复杂变换：结构转换</span>
<span class="hljs-keyword">struct</span> Person { <span class="hljs-built_in">string</span> name; <span class="hljs-keyword">int</span> age; };
<span class="hljs-keyword">struct</span> PersonView { <span class="hljs-built_in">string</span> display; };

<span class="hljs-built_in">vector</span>&lt;Person&gt; people = { {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">25</span>}, {<span class="hljs-string">"Bob"</span>, <span class="hljs-number">30</span>} };
<span class="hljs-built_in">vector</span>&lt;PersonView&gt; views(people.size());

transform(people.begin(), people.end(), views.begin(), [](<span class="hljs-keyword">const</span> Person&amp; p) {
    <span class="hljs-keyword">return</span> PersonView{p.name + <span class="hljs-string">" ("</span> + to_string(p.age) + <span class="hljs-string">")"</span>};
});
<span class="hljs-comment">// 结果: [{"Alice (25)"}, {"Bob (30)"}]</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>目标范围必须有足够空间</li>
<li>源和目标可以是同一范围</li>
<li>可以使用标准库中的函数对象或自定义函数</li>
</ul>
<h4 id="replace--replaceif--replacecopy"><code>replace</code> / <code>replace_if</code> / <code>replace_copy</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 替换范围内的指定值</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - old_value: 要替换的值</span>
<span class="hljs-comment">// - new_value: 替换后的值</span>
replace(first, last, old_value, new_value);

<span class="hljs-comment">// 根据条件替换</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - pred: 谓词函数，接收一个元素并返回bool值</span>
<span class="hljs-comment">// - new_value: 替换后的值</span>
replace_if(first, last, pred, new_value);

<span class="hljs-comment">// 替换并复制到新范围</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-comment">// - old_value: 要替换的值</span>
<span class="hljs-comment">// - new_value: 替换后的值</span>
<span class="hljs-keyword">auto</span> end_it = replace_copy(first, last, result, old_value, new_value);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>数据清洗和转换</li>
<li>条件替换</li>
<li>生成替换后的新序列</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 替换值为2的元素为99</span>
replace(v.begin(), v.end(), <span class="hljs-number">2</span>, <span class="hljs-number">99</span>);
<span class="hljs-comment">// 结果: {1, 99, 3, 99, 5}</span>

<span class="hljs-comment">// 条件替换：将所有负数替换为0</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">5</span>};
replace_if(v2.begin(), v2.end(), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span>; }, <span class="hljs-number">0</span>);
<span class="hljs-comment">// 结果: {0, 2, 0, 4, 0}</span>

<span class="hljs-comment">// 替换并复制</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v3.size());
replace_copy(v3.begin(), v3.end(), result.begin(), <span class="hljs-number">2</span>, <span class="hljs-number">99</span>);
<span class="hljs-comment">// v3不变，result: {1, 99, 3, 99, 5}</span>
</code></pre>
<h4 id="unique--uniquecopy"><code>unique</code> / <code>unique_copy</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 移除连续重复元素，返回新逻辑结尾的迭代器</span>
<span class="hljs-comment">// 返回值：指向新逻辑结尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - pred: 比较函数（可选），接收两个元素并返回bool值</span>
<span class="hljs-keyword">auto</span> new_end = unique(first, last, pred);

<span class="hljs-comment">// 复制不重复的元素到目标范围</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-comment">// - pred: 比较函数（可选），接收两个元素并返回bool值</span>
<span class="hljs-keyword">auto</span> result_end = unique_copy(first, last, result, pred);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>移除序列中的连续重复元素</li>
<li>创建不包含连续重复元素的副本</li>
<li>数据去重（需要先排序）</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 移除连续重复元素</span>
<span class="hljs-keyword">auto</span> it = unique(v.begin(), v.end());
v.resize(it - v.begin());
<span class="hljs-comment">// 结果: {1, 2, 3, 4, 5}</span>

<span class="hljs-comment">// 使用自定义比较</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; words = {<span class="hljs-string">"apple"</span>, <span class="hljs-string">"APPLE"</span>, <span class="hljs-string">"banana"</span>, <span class="hljs-string">"BANANA"</span>, <span class="hljs-string">"orange"</span>};
<span class="hljs-keyword">auto</span> it2 = unique(words.begin(), words.end(), [](<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; a, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; b) {
    <span class="hljs-keyword">return</span> a.size() == b.size();  <span class="hljs-comment">// 根据长度判断是否相同</span>
});
words.resize(it2 - words.begin());
<span class="hljs-comment">// 可能的结果: {"apple", "banana", "orange"}</span>

<span class="hljs-comment">// 复制不重复元素到新容器</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;
unique_copy(v2.begin(), v2.end(), back_inserter(result));
<span class="hljs-comment">// 结果: {1, 2, 3, 4, 5}</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li><code>unique</code>只移除连续重复的元素，所以通常先排序</li>
<li>不会改变容器大小，需手动调整（通常用resize）</li>
<li>被"移除"的元素仍在容器中，但处于未指定状态</li>
</ul>
<h4 id="reverse--reversecopy"><code>reverse</code> / <code>reverse_copy</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 反转序列中的元素顺序</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
reverse(first, last);

<span class="hljs-comment">// 将反转后的序列复制到目标范围</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-keyword">auto</span> result_end = reverse_copy(first, last, result);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>反转数组、字符串或向量</li>
<li>创建反转的副本而不修改原序列</li>
<li>算法中需要处理反向序列</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 反转整个序列</span>
reverse(v.begin(), v.end());
<span class="hljs-comment">// 结果: {5, 4, 3, 2, 1}</span>

<span class="hljs-comment">// 反转部分序列</span>
<span class="hljs-built_in">string</span> s = <span class="hljs-string">"Hello World"</span>;
reverse(s.begin() + <span class="hljs-number">6</span>, s.end());
<span class="hljs-comment">// 结果: "Hello dlroW"</span>

<span class="hljs-comment">// 创建反转副本</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v2.size());
reverse_copy(v2.begin(), v2.end(), result.begin());
<span class="hljs-comment">// v2不变，result: {5, 4, 3, 2, 1}</span>
</code></pre>
<h4 id="rotate--rotatecopy"><code>rotate</code> / <code>rotate_copy</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 旋转序列中的元素，将middle指向的元素放到首位</span>
<span class="hljs-comment">// 返回值：指向旋转后原来首元素的新位置的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, middle: 输入范围的起始迭代器和旋转点</span>
<span class="hljs-comment">// - last: 输入范围的结束迭代器</span>
<span class="hljs-keyword">auto</span> new_first = rotate(first, middle, last);

<span class="hljs-comment">// 旋转并复制到目标范围</span>
<span class="hljs-comment">// 返回值：指向目标范围末尾的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, middle: 输入范围的起始迭代器和旋转点</span>
<span class="hljs-comment">// - last: 输入范围的结束迭代器</span>
<span class="hljs-comment">// - result: 目标范围的起始迭代器</span>
<span class="hljs-keyword">auto</span> result_end = rotate_copy(first, middle, last, result);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>循环移位</li>
<li>重新排列数据</li>
<li>实现循环缓冲区</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 将3放到开头（向左旋转2个位置）</span>
rotate(v.begin(), v.begin() + <span class="hljs-number">2</span>, v.end());
<span class="hljs-comment">// 结果: {3, 4, 5, 1, 2}</span>

<span class="hljs-comment">// 复制旋转结果到新容器</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v2.size());
rotate_copy(v2.begin(), v2.begin() + <span class="hljs-number">1</span>, v2.end(), result.begin());
<span class="hljs-comment">// 结果: {2, 3, 4, 5, 1}</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li><code>middle</code>必须在<code>first</code>和<code>last</code>之间</li>
<li>返回值是旋转后原来首元素的新位置</li>
<li>可以用于高效实现循环队列和缓冲区</li>
</ul>
<h4 id="shuffle"><code>shuffle</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 随机打乱序列，使用随机数生成器</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - gen: 随机数生成器</span>
shuffle(first, last, gen);
</code></pre>
<p>时间复杂度：O(N)</p>
<p>使用场景：</p>
<ul>
<li>随机化数据集</li>
<li>实现洗牌算法</li>
<li>Monte Carlo方法</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp">#include &lt;random&gt;

vector&lt;int&gt; v = {1, 2, 3, 4, 5, 6, 7, 8};
// 使用随机数引擎
random_device rd;
mt19937 g(rd());
shuffle(v.begin(), v.end(), g);
// 结果: 序列随机排列，如 {3, 1, 7, 8, 4, 2, 5, 6}
</code></pre>
<p>注意事项：</p>
<ul>
<li><code>shuffle</code>比<code>random_shuffle</code>提供更好的随机性，推荐使用</li>
<li>需要高质量随机性时，避免使用<code>rand()</code></li>
<li>推荐使用<code>&lt;random&gt;</code>头文件中的随机数生成器</li>
</ul>
<h3 id="排列组合">排列组合</h3>
<h4 id="nextpermutation--prevpermutation"><code>next_permutation</code> / <code>prev_permutation</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 生成下一个字典序排列，成功返回true，否则返回false</span>
<span class="hljs-comment">// 返回值：bool值，表示是否生成了下一个排列</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">bool</span> has_next = next_permutation(first, last, comp);

<span class="hljs-comment">// 生成上一个字典序排列，成功返回true，否则返回false</span>
<span class="hljs-comment">// 返回值：bool值，表示是否生成了上一个排列</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
<span class="hljs-keyword">bool</span> has_prev = prev_permutation(first, last, comp);
</code></pre>
<p>时间复杂度：平均O(N)，最坏O(N²)</p>
<p>使用场景：</p>
<ul>
<li>枚举所有可能的排列</li>
<li>组合优化问题</li>
<li>生成下一个排列</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-comment">// 枚举所有排列</span>
<span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// 处理当前排列</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : v) <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">' '</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'\n'</span>;
} <span class="hljs-keyword">while</span> (next_permutation(v.begin(), v.end()));

<span class="hljs-comment">// 输出:</span>
<span class="hljs-comment">// 1 2 3</span>
<span class="hljs-comment">// 1 3 2</span>
<span class="hljs-comment">// 2 1 3</span>
<span class="hljs-comment">// 2 3 1</span>
<span class="hljs-comment">// 3 1 2</span>
<span class="hljs-comment">// 3 2 1</span>

<span class="hljs-comment">// 对于已排序的最大排列，下一个排列会回到开始</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>};
<span class="hljs-keyword">bool</span> has_next = next_permutation(v2.begin(), v2.end());
<span class="hljs-comment">// has_next为false，v2变为{1, 2, 3}</span>

<span class="hljs-comment">// 使用prev_permutation</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 = {<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>};
<span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// 处理当前排列</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : v3) <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">' '</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">'\n'</span>;
} <span class="hljs-keyword">while</span> (prev_permutation(v3.begin(), v3.end()));

<span class="hljs-comment">// 输出与next_permutation相反的顺序</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>初始序列需要是有效的排列（没有重复元素）</li>
<li>想要生成所有排列，起始序列应该是最小排列（已排序）</li>
<li>函数会修改序列，将其变为下一个/上一个排列</li>
</ul>
<h3 id="堆操作">堆操作</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 创建堆</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
make_heap(first, last, comp);

<span class="hljs-comment">// 添加元素到堆</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
push_heap(first, last, comp);

<span class="hljs-comment">// 移除堆顶元素</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
pop_heap(first, last, comp);

<span class="hljs-comment">// 堆排序</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 输入范围的迭代器</span>
<span class="hljs-comment">// - comp: 比较函数（可选）</span>
sort_heap(first, last, comp);
</code></pre>
<p>时间复杂度：</p>
<ul>
<li><code>make_heap</code>: O(N)</li>
<li><code>push_heap</code>: O(log N)</li>
<li><code>pop_heap</code>: O(log N)</li>
<li><code>sort_heap</code>: O(N log N)</li>
</ul>
<p>使用场景：</p>
<ul>
<li>优先队列实现</li>
<li>堆排序</li>
<li>动态维护最大/最小值</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>};

<span class="hljs-comment">// 构建最大堆</span>
make_heap(v.begin(), v.end());
<span class="hljs-comment">// v可能变为: {9, 5, 4, 1, 1, 3}</span>

<span class="hljs-comment">// 添加元素</span>
v.push_back(<span class="hljs-number">6</span>);
push_heap(v.begin(), v.end());
<span class="hljs-comment">// 先添加元素到末尾，然后调整堆</span>

<span class="hljs-comment">// 移除堆顶元素</span>
pop_heap(v.begin(), v.end());
<span class="hljs-keyword">int</span> top = v.back(); <span class="hljs-comment">// 获取堆顶元素</span>
v.pop_back();       <span class="hljs-comment">// 从容器中移除</span>
<span class="hljs-comment">// pop_heap将堆顶元素移到末尾，并重新调整堆</span>

<span class="hljs-comment">// 堆排序</span>
sort_heap(v.begin(), v.end());
<span class="hljs-comment">// 结果: 升序排列</span>
</code></pre>
<p>详细用法：</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// 创建最小堆</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; min_heap = {<span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
make_heap(min_heap.begin(), min_heap.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// min_heap可能为: {1, 3, 2, 8, 6, 4}</span>

<span class="hljs-comment">// 弹出最小元素</span>
pop_heap(min_heap.begin(), min_heap.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-keyword">int</span> min_val = min_heap.back();
min_heap.pop_back();
<span class="hljs-comment">// min_val = 1</span>

<span class="hljs-comment">// 添加元素到最小堆</span>
min_heap.push_back(<span class="hljs-number">0</span>);
push_heap(min_heap.begin(), min_heap.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 0现在是堆顶最小元素</span>

<span class="hljs-comment">// 自定义堆比较函数</span>
<span class="hljs-keyword">struct</span> Person {
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> priority;
};

<span class="hljs-built_in">vector</span>&lt;Person&gt; persons = {
    {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">3</span>}, {<span class="hljs-string">"Bob"</span>, <span class="hljs-number">1</span>}, {<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">2</span>}
};

make_heap(persons.begin(), persons.end(), 
    [](<span class="hljs-keyword">const</span> Person&amp; a, <span class="hljs-keyword">const</span> Person&amp; b) {
        <span class="hljs-keyword">return</span> a.priority &lt; b.priority;  <span class="hljs-comment">// 优先级高的放堆顶</span>
    });
</code></pre>
<p>注意事项：</p>
<ul>
<li>默认创建的是最大堆</li>
<li>常用于实现优先队列和堆排序</li>
<li>需要手动维护容器大小</li>
</ul>
<h2 id="迭代器相关函数">迭代器相关函数</h2>
<blockquote>
<p>使用前需要包含头文件 <code>#include &lt;iterator&gt;</code></p>
</blockquote>
<h4 id="advance"><code>advance</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将迭代器向前或向后移动n个位置</span>
<span class="hljs-comment">// 返回值：无</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - it: 要移动的迭代器</span>
<span class="hljs-comment">// - n: 移动的距离，可以为负</span>
advance(it, n);
</code></pre>
<p>时间复杂度：</p>
<ul>
<li>随机访问迭代器: O(1)</li>
<li>其他迭代器: O(N)</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; lst = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-keyword">auto</span> it = lst.begin();
advance(it, <span class="hljs-number">2</span>); <span class="hljs-comment">// 现在it指向3</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>没有边界检查，调用者必须确保移动后迭代器仍然有效</li>
<li>对于双向迭代器，n可以为负</li>
<li>对于单向迭代器，n必须为非负</li>
</ul>
<h4 id="distance"><code>distance</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算两个迭代器之间的距离</span>
<span class="hljs-comment">// 返回值：int，表示两个迭代器之间的距离</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - first, last: 要计算距离的两个迭代器</span>
<span class="hljs-keyword">int</span> d = distance(first, last);
</code></pre>
<p>时间复杂度：</p>
<ul>
<li>随机访问迭代器: O(1)</li>
<li>其他迭代器: O(N)</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-keyword">int</span> d = distance(v.begin(), v.end()); <span class="hljs-comment">// 返回5</span>

<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; lst = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>};
<span class="hljs-keyword">auto</span> it = lst.begin();
advance(it, <span class="hljs-number">2</span>);
<span class="hljs-keyword">int</span> d2 = distance(lst.begin(), it); <span class="hljs-comment">// 返回2</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>first必须可达last，否则行为未定义</li>
<li>对于非随机访问迭代器，需要遍历计算距离</li>
</ul>
<h4 id="next--prev"><code>next</code> / <code>prev</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 返回前进n个位置的迭代器（不修改原迭代器）</span>
<span class="hljs-comment">// 返回值：前进n个位置后的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - it: 要前进的迭代器</span>
<span class="hljs-comment">// - n: 前进的距离，默认为1</span>
<span class="hljs-keyword">auto</span> next_it = next(it, n = <span class="hljs-number">1</span>);

<span class="hljs-comment">// 返回后退n个位置的迭代器（不修改原迭代器）</span>
<span class="hljs-comment">// 返回值：后退n个位置后的迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - it: 要后退的迭代器</span>
<span class="hljs-comment">// - n: 后退的距离，默认为1</span>
<span class="hljs-keyword">auto</span> prev_it = prev(it, n = <span class="hljs-number">1</span>);
</code></pre>
<p>时间复杂度：与<code>advance</code>相同</p>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; lst = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-keyword">auto</span> it = lst.begin();
<span class="hljs-keyword">auto</span> it2 = next(it, <span class="hljs-number">2</span>); <span class="hljs-comment">// 指向3，不修改it</span>
<span class="hljs-keyword">auto</span> it3 = prev(lst.end(), <span class="hljs-number">1</span>); <span class="hljs-comment">// 指向5</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>与<code>advance</code>不同，不会修改原迭代器</li>
<li>C++11引入，提供更安全的迭代器移动方式</li>
</ul>
<h4 id="backinserter--frontinserter--inserter"><code>back_inserter</code> / <code>front_inserter</code> / <code>inserter</code></h4>
<pre><code class="lang-cpp"><span class="hljs-comment">// 创建插入迭代器</span>
<span class="hljs-comment">// 返回值：插入迭代器</span>
<span class="hljs-comment">// 参数说明：</span>
<span class="hljs-comment">// - container: 要插入元素的容器</span>
back_inserter(container);   <span class="hljs-comment">// 在容器末尾插入</span>
front_inserter(container);  <span class="hljs-comment">// 在容器开头插入</span>
inserter(container, it);    <span class="hljs-comment">// 在指定位置插入</span>
</code></pre>
<p>使用场景：</p>
<ul>
<li>在STL算法中动态扩展容器</li>
<li>避免手动调整容器大小</li>
<li>实现流式处理</li>
</ul>
<p>示例：</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; source = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dest;

<span class="hljs-comment">// 使用back_inserter避免预先分配空间</span>
copy(source.begin(), source.end(), back_inserter(dest));
<span class="hljs-comment">// dest: {1, 2, 3, 4, 5}</span>

<span class="hljs-comment">// 过滤并插入</span>
copy_if(source.begin(), source.end(), back_inserter(dest),
       [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; });
<span class="hljs-comment">// 添加到dest后面: {1, 2, 3, 4, 5, 2, 4}</span>

<span class="hljs-comment">// front_inserter适用于双端队列和列表</span>
<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; lst;
copy(source.begin(), source.end(), front_inserter(lst));
<span class="hljs-comment">// lst: {5, 4, 3, 2, 1} (注意顺序反转)</span>

<span class="hljs-comment">// 在特定位置插入</span>
<span class="hljs-built_in">list</span>&lt;<span class="hljs-keyword">int</span>&gt; lst2 = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>};
<span class="hljs-keyword">auto</span> pos = next(lst2.begin(), <span class="hljs-number">2</span>); <span class="hljs-comment">// 指向30</span>
copy(source.begin(), source.end(), inserter(lst2, pos));
<span class="hljs-comment">// lst2: {10, 20, 1, 2, 3, 4, 5, 30, 40}</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li><code>back_inserter</code>调用<code>push_back</code>，适用于vector、deque、list等</li>
<li><code>front_inserter</code>调用<code>push_front</code>，只适用于deque、list等</li>
<li><code>inserter</code>调用<code>insert</code>，适合所有支持插入的容器</li>
</ul>
<h2 id="函数对象">函数对象</h2>
<blockquote>
<p>需包含头文件 <code>#include &lt;functional&gt;</code></p>
</blockquote>
<p>STL提供了许多预定义的函数对象，它们是实现了函数调用运算符（<code>operator()</code>）的类。这些对象可以像函数一样使用，但有更多灵活性。</p>
<h3 id="预定义函数对象">预定义函数对象</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 算术运算</span>
plus&lt;T&gt;()          <span class="hljs-comment">// 函数对象，实现 a + b 的加法操作</span>
minus&lt;T&gt;()         <span class="hljs-comment">// 函数对象，实现 a - b 的减法操作</span>
multiplies&lt;T&gt;()    <span class="hljs-comment">// 函数对象，实现 a * b 的乘法操作</span>
divides&lt;T&gt;()       <span class="hljs-comment">// 函数对象，实现 a / b 的除法操作</span>
modulus&lt;T&gt;()       <span class="hljs-comment">// 函数对象，实现 a % b 的取模操作</span>
negate&lt;T&gt;()        <span class="hljs-comment">// 函数对象，实现 -a 的取负操作</span>

<span class="hljs-comment">// 比较运算</span>
equal_to&lt;T&gt;()      <span class="hljs-comment">// 函数对象，检查 a == b 是否成立</span>
not_equal_to&lt;T&gt;()  <span class="hljs-comment">// 函数对象，检查 a != b 是否成立</span>
greater&lt;T&gt;()       <span class="hljs-comment">// 函数对象，检查 a &gt; b 是否成立</span>
less&lt;T&gt;()          <span class="hljs-comment">// 函数对象，检查 a &lt; b 是否成立</span>
greater_equal&lt;T&gt;() <span class="hljs-comment">// 函数对象，检查 a &gt;= b 是否成立</span>
less_equal&lt;T&gt;()    <span class="hljs-comment">// 函数对象，检查 a &lt;= b 是否成立</span>

<span class="hljs-comment">// 逻辑运算</span>
logical_and&lt;T&gt;()   <span class="hljs-comment">// 函数对象，实现 a &amp;&amp; b 的逻辑与操作</span>
logical_or&lt;T&gt;()    <span class="hljs-comment">// 函数对象，实现 a || b 的逻辑或操作</span>
logical_not&lt;T&gt;()   <span class="hljs-comment">// 函数对象，实现 !a 的逻辑非操作</span>
</code></pre>
<p>函数对象的优点：</p>
<ol>
<li>比函数指针更高效，因为编译器可以内联它们</li>
<li>可以有状态（成员变量）</li>
<li>可以与STL算法无缝配合</li>
<li>便于组合和自定义</li>
</ol>
<p>使用场景：</p>
<ul>
<li>作为排序和比较操作的谓词</li>
<li>参与STL算法中的函数组合</li>
<li>实现自定义的操作，尤其是需要保存状态的操作</li>
</ul>
<h3 id="基本用法示例">基本用法示例</h3>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>};

<span class="hljs-comment">// 使用greater函数对象进行降序排序</span>
<span class="hljs-comment">// greater&lt;int&gt;()创建一个函数对象，当第一个参数大于第二个参数时返回true</span>
<span class="hljs-comment">// 这会导致较大的元素排在前面，实现降序排序</span>
sort(v.begin(), v.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: {9, 8, 5, 2, 1}</span>

<span class="hljs-comment">// 使用less函数对象进行升序排序（这实际上是默认行为）</span>
<span class="hljs-comment">// less&lt;int&gt;()创建一个函数对象，当第一个参数小于第二个参数时返回true</span>
sort(v.begin(), v.end(), less&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: {1, 2, 5, 8, 9}</span>
</code></pre>
<h3 id="函数对象用于算术运算">函数对象用于算术运算</h3>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-comment">// 准备两个向量</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v1.size());

<span class="hljs-comment">// 使用plus函数对象对应元素相加</span>
<span class="hljs-comment">// transform以v1和v2为输入，以result为输出，对每对对应元素应用plus&lt;int&gt;()操作</span>
<span class="hljs-comment">// plus&lt;int&gt;()会将两个参数相加并返回和</span>
transform(v1.begin(), v1.end(), v2.begin(), result.begin(), plus&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: {11, 22, 33, 44}</span>

<span class="hljs-comment">// 使用multiplies函数对象对应元素相乘</span>
<span class="hljs-comment">// multiplies&lt;int&gt;()会将两个参数相乘并返回乘积</span>
transform(v1.begin(), v1.end(), v2.begin(), result.begin(), multiplies&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: {10, 40, 90, 160}</span>

<span class="hljs-comment">// 使用accumulate计算乘积</span>
<span class="hljs-comment">// 这里用multiplies&lt;int&gt;()替代默认的加法操作，实现连乘</span>
<span class="hljs-keyword">int</span> product = accumulate(v1.begin(), v1.end(), <span class="hljs-number">1</span>, multiplies&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// 结果: 24 (= 1*1*2*3*4)</span>
</code></pre>
<h3 id="创建自定义函数对象">创建自定义函数对象</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 自定义函数对象：计算平方</span>
<span class="hljs-keyword">struct</span> Square {
    <span class="hljs-comment">// 重载函数调用运算符，使Square对象可以像函数一样被调用</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> x * x;
    }
};

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; squares(nums.size());

<span class="hljs-comment">// 使用自定义函数对象</span>
<span class="hljs-comment">// 创建一个Square对象并将其传给transform</span>
<span class="hljs-comment">// transform会对nums中每个元素调用Square对象，计算其平方值</span>
transform(nums.begin(), nums.end(), squares.begin(), Square());
<span class="hljs-comment">// 结果: {1, 4, 9, 16, 25}</span>

<span class="hljs-comment">// 带状态的函数对象</span>
<span class="hljs-keyword">class</span> Accumulator {
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> sum; <span class="hljs-comment">// 状态：保存累计和</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 构造函数初始化状态</span>
    Accumulator() : sum(<span class="hljs-number">0</span>) {}

    <span class="hljs-comment">// 函数调用运算符：累加并返回当前和</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
        sum += x;
        <span class="hljs-keyword">return</span> sum;
    }

    <span class="hljs-comment">// 获取当前累计结果</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> sum;
    }
};

<span class="hljs-comment">// 使用带状态的函数对象</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; cumulative(nums.size());
Accumulator acc;
<span class="hljs-comment">// transform调用acc处理nums中每个元素，acc会维护累计和</span>
transform(nums.begin(), nums.end(), cumulative.begin(), ref(acc));
<span class="hljs-comment">// 结果: {1, 3, 6, 10, 15}</span>
<span class="hljs-comment">// 注：使用ref()包装函数对象以传引用，确保状态被正确累计</span>
</code></pre>
<h3 id="绑定参数与函数组合">绑定参数与函数组合</h3>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span>

<span class="hljs-comment">// 使用bind创建新的函数对象</span>
<span class="hljs-comment">// bind将第一个参数(multiplies&lt;int&gt;())与常量5绑定，生成新的函数</span>
<span class="hljs-keyword">auto</span> times5 = bind(multiplies&lt;<span class="hljs-keyword">int</span>&gt;(), placeholders::_1, <span class="hljs-number">5</span>);
<span class="hljs-comment">// times5(x)等价于x*5</span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v.size());

<span class="hljs-comment">// 使用绑定后的函数对象</span>
transform(v.begin(), v.end(), result.begin(), times5);
<span class="hljs-comment">// 结果: {5, 10, 15, 20}</span>

<span class="hljs-comment">// 更复杂的函数组合</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = {<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">5</span>};

<span class="hljs-comment">// 使用lambda表达式与accumulate组合</span>
<span class="hljs-comment">// 这个lambda仅累加正数，忽略负数</span>
<span class="hljs-keyword">int</span> positive_sum = accumulate(nums.begin(), nums.end(), <span class="hljs-number">0</span>,
                             [](<span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> x) {
                                 <span class="hljs-keyword">return</span> sum + (x &gt; <span class="hljs-number">0</span> ? x : <span class="hljs-number">0</span>);
                             });
<span class="hljs-comment">// positive_sum = 9 (= 1 + 3 + 5)</span>
</code></pre>
<h3 id="c14透明函数对象">C++14透明函数对象</h3>
<p>C++14 引入了透明的函数对象，无需指定类型，编译器可以从上下文推导：</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// C++14特性：透明函数对象</span>
sort(v.begin(), v.end(), greater&lt;&gt;()); <span class="hljs-comment">// 不指定类型，自动推导</span>
sort(v.begin(), v.end(), less&lt;&gt;());    <span class="hljs-comment">// 不指定类型，自动推导</span>

<span class="hljs-comment">// 这样写可以处理不同类型的比较</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; vs = {<span class="hljs-string">"apple"</span>, <span class="hljs-string">"Orange"</span>, <span class="hljs-string">"banana"</span>};
<span class="hljs-comment">// 使用less&lt;&gt;可以直接比较不同类型</span>
sort(vs.begin(), vs.end(), less&lt;&gt;()); <span class="hljs-comment">// 默认字典序</span>
</code></pre>
<h3 id="函数包装器-stdfunction">函数包装器 <code>std::function</code></h3>
<p><code>std::function</code>是一个通用的函数包装器，可以存储、复制和调用任何可调用目标：</p>
<pre><code class="lang-cpp">#include &lt;functional&gt;

// 创建一个接受两个int并返回int的函数类型
function&lt;int(int, int)&gt; op;

// 存储函数指针
int add(int a, int b) { return a + b; }
op = add;
int result1 = op(2, 3); // 结果: 5

// 存储函数对象
op = multiplies&lt;int&gt;();
int result2 = op(2, 3); // 结果: 6

// 存储lambda表达式
op = [](int a, int b) { return a - b; };
int result3 = op(5, 3); // 结果: 2

// 用于回调函数
void processNumbers(vector&lt;int&gt;&amp; v, function&lt;void(int&amp;)&gt; processor) {
    for (auto&amp; num : v) {
        processor(num);
    }
}

// 使用不同的处理函数
vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};
processNumbers(numbers, [](int&amp; x) { x *= 2; });  // 所有元素乘2
// 结果: {2, 4, 6, 8, 10}
</code></pre>
<h2 id="数值处理函数">数值处理函数</h2>
<blockquote>
<p>使用前需包含头文件 <code>#include &lt;cmath&gt;</code></p>
</blockquote>
<p>STL 提供了丰富的数学函数，这些函数广泛用于科学计算、几何处理和数值分析等场景。</p>
<h3 id="基本数学函数">基本数学函数</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 基本运算</span>
<span class="hljs-built_in">abs</span>(x)       <span class="hljs-comment">// 整数绝对值，参数和返回值类型相同</span>
<span class="hljs-built_in">fabs</span>(x)      <span class="hljs-comment">// 浮点数绝对值，返回double类型</span>
<span class="hljs-built_in">sqrt</span>(x)      <span class="hljs-comment">// 平方根，参数可以是任何数值类型，返回浮点类型</span>
cbrt(x)      <span class="hljs-comment">// 立方根，参数可以是任何数值类型，返回浮点类型</span>
hypot(x, y)  <span class="hljs-comment">// 计算sqrt(x*x + y*y)，避免中间溢出</span>

<span class="hljs-comment">// 指数和对数</span>
<span class="hljs-built_in">pow</span>(x, y)    <span class="hljs-comment">// x的y次幂，两个参数可以是不同类型</span>
<span class="hljs-built_in">exp</span>(x)       <span class="hljs-comment">// e的x次幂</span>
<span class="hljs-built_in">log</span>(x)       <span class="hljs-comment">// 自然对数(以e为底)，参数必须为正</span>
<span class="hljs-built_in">log10</span>(x)     <span class="hljs-comment">// 以10为底的对数，参数必须为正</span>
log2(x)      <span class="hljs-comment">// 以2为底的对数，参数必须为正</span>
</code></pre>
<h3 id="取整函数">取整函数</h3>
<pre><code class="lang-cpp"><span class="hljs-built_in">ceil</span>(x)      <span class="hljs-comment">// 向上取整，返回大于等于x的最小整数</span>
<span class="hljs-built_in">floor</span>(x)     <span class="hljs-comment">// 向下取整，返回小于等于x的最大整数</span>
round(x)     <span class="hljs-comment">// 四舍五入到最接近的整数</span>
trunc(x)     <span class="hljs-comment">// 截断取整（向0取整），丢弃小数部分</span>
</code></pre>
<h3 id="三角函数和双曲函数">三角函数和双曲函数</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 三角函数（参数为弧度）</span>
<span class="hljs-built_in">sin</span>(x)       <span class="hljs-comment">// 正弦</span>
<span class="hljs-built_in">cos</span>(x)       <span class="hljs-comment">// 余弦</span>
<span class="hljs-built_in">tan</span>(x)       <span class="hljs-comment">// 正切</span>
<span class="hljs-built_in">asin</span>(x)      <span class="hljs-comment">// 反正弦，参数范围[-1,1]，返回[-π/2,π/2]</span>
<span class="hljs-built_in">acos</span>(x)      <span class="hljs-comment">// 反余弦，参数范围[-1,1]，返回[0,π]</span>
<span class="hljs-built_in">atan</span>(x)      <span class="hljs-comment">// 反正切，返回[-π/2,π/2]</span>
<span class="hljs-built_in">atan2</span>(y, x)  <span class="hljs-comment">// 计算y/x的反正切，考虑象限，返回[-π,π]</span>

<span class="hljs-comment">// 双曲函数</span>
<span class="hljs-built_in">sinh</span>(x)      <span class="hljs-comment">// 双曲正弦</span>
<span class="hljs-built_in">cosh</span>(x)      <span class="hljs-comment">// 双曲余弦</span>
<span class="hljs-built_in">tanh</span>(x)      <span class="hljs-comment">// 双曲正切</span>
asinh(x)     <span class="hljs-comment">// 反双曲正弦</span>
acosh(x)     <span class="hljs-comment">// 反双曲余弦，参数必须≥1</span>
atanh(x)     <span class="hljs-comment">// 反双曲正切，参数范围(-1,1)</span>
</code></pre>
<h3 id="特殊数值判断和操作">特殊数值判断和操作</h3>
<pre><code class="lang-cpp">isnan(x)     <span class="hljs-comment">// 检查x是否为NaN(不是一个数)，返回bool</span>
isinf(x)     <span class="hljs-comment">// 检查x是否为无穷大，返回bool</span>
isfinite(x)  <span class="hljs-comment">// 检查x是否为有限值，返回bool</span>
signbit(x)   <span class="hljs-comment">// 检查x的符号位是否被设置（是否为负），返回bool</span>
copysign(x,y) <span class="hljs-comment">// 返回带有y符号的x的绝对值</span>
nextafter(x,y) <span class="hljs-comment">// 返回x向着y方向的下一个可表示的数</span>
</code></pre>
<h3 id="实际使用示例">实际使用示例</h3>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>

<span class="hljs-comment">// 基本计算</span>
<span class="hljs-keyword">double</span> a = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">16</span>);             <span class="hljs-comment">// 计算16的平方根：4.0</span>
<span class="hljs-keyword">double</span> b = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);            <span class="hljs-comment">// 计算2的3次方：8.0</span>
<span class="hljs-keyword">double</span> c = <span class="hljs-built_in">log10</span>(<span class="hljs-number">100</span>);           <span class="hljs-comment">// 计算log₁₀(100)：2.0</span>

<span class="hljs-comment">// 取整操作</span>
<span class="hljs-keyword">double</span> d = <span class="hljs-built_in">ceil</span>(<span class="hljs-number">3.14</span>);           <span class="hljs-comment">// 向上取整：4.0</span>
<span class="hljs-keyword">double</span> e = <span class="hljs-built_in">floor</span>(<span class="hljs-number">3.14</span>);          <span class="hljs-comment">// 向下取整：3.0</span>
<span class="hljs-keyword">double</span> f = round(<span class="hljs-number">3.5</span>);           <span class="hljs-comment">// 四舍五入：4.0</span>
<span class="hljs-keyword">double</span> g = trunc(-<span class="hljs-number">2.7</span>);          <span class="hljs-comment">// 截断取整：-2.0</span>

<span class="hljs-comment">// 三角函数（注意使用弧度）</span>
<span class="hljs-keyword">double</span> h = <span class="hljs-built_in">sin</span>(M_PI / <span class="hljs-number">2</span>);        <span class="hljs-comment">// sin(90°)：1.0</span>
<span class="hljs-keyword">double</span> i = <span class="hljs-built_in">cos</span>(M_PI);            <span class="hljs-comment">// cos(180°)：-1.0</span>
<span class="hljs-keyword">double</span> j = <span class="hljs-built_in">atan2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);          <span class="hljs-comment">// 计算1/1的反正切：π/4</span>

<span class="hljs-comment">// 特殊值判断</span>
<span class="hljs-keyword">double</span> inf = <span class="hljs-number">1.0</span> / <span class="hljs-number">0.0</span>;          <span class="hljs-comment">// 创建无穷大值</span>
<span class="hljs-keyword">double</span> nan_val = <span class="hljs-number">0.0</span> / <span class="hljs-number">0.0</span>;      <span class="hljs-comment">// 创建NaN值</span>
<span class="hljs-keyword">bool</span> is_inf = isinf(inf);        <span class="hljs-comment">// 检查是否为无穷大：true</span>
<span class="hljs-keyword">bool</span> is_nan = isnan(nan_val);    <span class="hljs-comment">// 检查是否为NaN：true</span>
<span class="hljs-keyword">bool</span> is_finite = isfinite(inf);  <span class="hljs-comment">// 检查是否为有限值：false</span>

<span class="hljs-comment">// 高精度浮点数比较</span>
<span class="hljs-comment">// 浮点数不应直接用==比较，而应考虑误差范围</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> epsilon = <span class="hljs-number">1e-9</span>;     <span class="hljs-comment">// 误差容忍度</span>
<span class="hljs-keyword">bool</span> is_equal = <span class="hljs-built_in">fabs</span>(a - <span class="hljs-number">4.0</span>) &lt; epsilon;  <span class="hljs-comment">// 检查a是否等于4.0：true</span>

<span class="hljs-comment">// 实际应用：计算两点之间的欧几里得距离</span>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x1, <span class="hljs-keyword">double</span> y1, <span class="hljs-keyword">double</span> x2, <span class="hljs-keyword">double</span> y2)</span> </span>{
    <span class="hljs-comment">// hypot函数避免了中间计算可能的溢出问题</span>
    <span class="hljs-keyword">return</span> hypot(x2 - x1, y2 - y1);
}
<span class="hljs-keyword">double</span> dist = distance(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 计算原点到(3,4)的距离：5.0</span>

<span class="hljs-comment">// 使用三角函数计算角度（弧度转角度）</span>
<span class="hljs-keyword">double</span> angle_rad = <span class="hljs-built_in">atan2</span>(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>);      <span class="hljs-comment">// 计算向量(3,4)与x轴的角度（弧度）</span>
<span class="hljs-keyword">double</span> angle_deg = angle_rad * <span class="hljs-number">180</span> / M_PI;  <span class="hljs-comment">// 将弧度转换为角度：约53.13°</span>
</code></pre>
<h3 id="复数相关函数">复数相关函数</h3>
<p>对于复数操作，需要包含头文件<code>&lt;complex&gt;</code>：</p>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;complex&gt;</span></span>

<span class="hljs-comment">// 定义复数</span>
<span class="hljs-keyword">complex</span>&lt;<span class="hljs-keyword">double</span>&gt; z1(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">// 实部3，虚部4</span>
<span class="hljs-keyword">complex</span>&lt;<span class="hljs-keyword">double</span>&gt; z2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

<span class="hljs-comment">// 复数运算</span>
<span class="hljs-keyword">auto</span> sum = z1 + z2;        <span class="hljs-comment">// 复数加法：(4,6)</span>
<span class="hljs-keyword">auto</span> product = z1 * z2;    <span class="hljs-comment">// 复数乘法：(3*1-4*2, 3*2+4*1)=(−5,10)</span>

<span class="hljs-comment">// 复数函数</span>
<span class="hljs-keyword">double</span> mag = <span class="hljs-built_in">abs</span>(z1);      <span class="hljs-comment">// 复数的模：5</span>
<span class="hljs-keyword">double</span> arg = arg(z1);      <span class="hljs-comment">// 复数的辐角</span>
<span class="hljs-keyword">complex</span>&lt;<span class="hljs-keyword">double</span>&gt; conj = conj(z1);  <span class="hljs-comment">// 共轭复数：(3,-4)</span>
<span class="hljs-keyword">complex</span>&lt;<span class="hljs-keyword">double</span>&gt; sqr = <span class="hljs-built_in">sqrt</span>(z1);   <span class="hljs-comment">// 复数的平方根</span>
</code></pre>
<h2 id="字符串处理函数">字符串处理函数</h2>
<p>C++提供了两种处理字符串的方式：C风格的字符串函数和C++ string类。对于现代C++编程，推荐使用C++ string类，它更安全，更灵活。</p>
<h3 id="c风格字符串函数-cstring">C风格字符串函数 (<code>&lt;cstring&gt;</code>)</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 字符串长度和比较</span>
<span class="hljs-built_in">strlen</span>(str)                  <span class="hljs-comment">// 计算字符串长度（不包括null结束符）</span>
<span class="hljs-built_in">strcmp</span>(s1, s2)               <span class="hljs-comment">// 比较字符串，相等返回0，s1&lt;s2返回负值，s1&gt;s2返回正值</span>
<span class="hljs-built_in">strncmp</span>(s1, s2, n)           <span class="hljs-comment">// 比较最多n个字符</span>

<span class="hljs-comment">// 字符串复制和连接</span>
<span class="hljs-built_in">strcpy</span>(dest, src)            <span class="hljs-comment">// 将src复制到dest，包括null结束符</span>
<span class="hljs-built_in">strncpy</span>(dest, src, n)        <span class="hljs-comment">// 复制最多n个字符，不保证null结束符</span>
<span class="hljs-built_in">strcat</span>(dest, src)            <span class="hljs-comment">// 将src连接到dest末尾</span>
<span class="hljs-built_in">strncat</span>(dest, src, n)        <span class="hljs-comment">// 连接最多n个字符</span>

<span class="hljs-comment">// 字符串搜索</span>
<span class="hljs-built_in">strchr</span>(str, c)               <span class="hljs-comment">// 查找字符c首次出现的位置，返回指针或NULL</span>
<span class="hljs-built_in">strrchr</span>(str, c)              <span class="hljs-comment">// 查找字符c最后出现的位置，返回指针或NULL</span>
<span class="hljs-built_in">strstr</span>(str, substr)          <span class="hljs-comment">// 查找子串substr首次出现的位置，返回指针或NULL</span>
<span class="hljs-built_in">strpbrk</span>(str, charset)        <span class="hljs-comment">// 查找charset中任意字符首次出现的位置</span>

<span class="hljs-comment">// 字符串分割和转换</span>
strtok(str, delim)           <span class="hljs-comment">// 按分隔符分割字符串，返回下一个标记或NULL</span>
atoi(str)                    <span class="hljs-comment">// 将字符串转换为int</span>
atof(str)                    <span class="hljs-comment">// 将字符串转换为double</span>
</code></pre>
<p>详细示例：</p>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-comment">// 基本字符串操作</span>
<span class="hljs-keyword">char</span> s1[<span class="hljs-number">100</span>] = <span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">char</span> s2[] = <span class="hljs-string">"World"</span>;

<span class="hljs-comment">// 获取字符串长度</span>
<span class="hljs-keyword">size_t</span> len = <span class="hljs-built_in">strlen</span>(s1);        <span class="hljs-comment">// 返回5（不计算结束符'\0'）</span>

<span class="hljs-comment">// 字符串比较</span>
<span class="hljs-keyword">int</span> cmp = <span class="hljs-built_in">strcmp</span>(s1, s2);       <span class="hljs-comment">// 返回负值，因为'H'的ASCII码小于'W'</span>
<span class="hljs-keyword">bool</span> is_equal = (<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">"Hello"</span>) == <span class="hljs-number">0</span>); <span class="hljs-comment">// 检查s1是否等于"Hello"：true</span>

<span class="hljs-comment">// 字符串复制和连接</span>
<span class="hljs-built_in">strcpy</span>(s1 + <span class="hljs-number">5</span>, <span class="hljs-string">" "</span>);            <span class="hljs-comment">// 将空格复制到s1[5]位置，s1变为"Hello "</span>
<span class="hljs-built_in">strcat</span>(s1, s2);                 <span class="hljs-comment">// 将s2连接到s1末尾，s1变为"Hello World"</span>

<span class="hljs-comment">// 字符串搜索</span>
<span class="hljs-keyword">char</span>* found = <span class="hljs-built_in">strchr</span>(s1, <span class="hljs-string">'o'</span>);  <span class="hljs-comment">// 查找'o'首次出现位置，found指向"o World"</span>
<span class="hljs-keyword">char</span>* last_o = <span class="hljs-built_in">strrchr</span>(s1, <span class="hljs-string">'o'</span>); <span class="hljs-comment">// 查找'o'最后出现位置，指向"orld"中的'o'</span>
<span class="hljs-keyword">char</span>* substr = <span class="hljs-built_in">strstr</span>(s1, <span class="hljs-string">"World"</span>); <span class="hljs-comment">// 查找"World"，substr指向"World"</span>

<span class="hljs-comment">// 字符串分割</span>
<span class="hljs-keyword">char</span> csv[] = <span class="hljs-string">"apple,banana,orange"</span>;
<span class="hljs-keyword">char</span>* token = strtok(csv, <span class="hljs-string">","</span>); <span class="hljs-comment">// 获取第一个标记：apple</span>
<span class="hljs-keyword">while</span> (token != <span class="hljs-literal">nullptr</span>) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; token &lt;&lt; <span class="hljs-built_in">std</span>::endl; <span class="hljs-comment">// 输出当前标记</span>
    token = strtok(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">","</span>);    <span class="hljs-comment">// 获取下一个标记</span>
}
<span class="hljs-comment">// 输出:</span>
<span class="hljs-comment">// apple</span>
<span class="hljs-comment">// banana</span>
<span class="hljs-comment">// orange</span>

<span class="hljs-comment">// 注意：strtok会修改原字符串，插入null字符('\0')来分隔标记</span>
<span class="hljs-comment">// 如果需要保留原字符串，应事先创建副本</span>

<span class="hljs-comment">// 安全的字符串复制（防止缓冲区溢出）</span>
<span class="hljs-keyword">char</span> dest[<span class="hljs-number">10</span>];
<span class="hljs-built_in">strncpy</span>(dest, <span class="hljs-string">"This is a very long string"</span>, <span class="hljs-number">9</span>); <span class="hljs-comment">// 只复制前9个字符</span>
dest[<span class="hljs-number">9</span>] = <span class="hljs-string">'\0'</span>; <span class="hljs-comment">// 手动添加结束符确保安全</span>
<span class="hljs-comment">// dest包含"This is a"</span>

<span class="hljs-comment">// 字符串转数字</span>
<span class="hljs-keyword">int</span> num = atoi(<span class="hljs-string">"123"</span>);         <span class="hljs-comment">// 将字符串转换为整数：123</span>
<span class="hljs-keyword">double</span> dbl = atof(<span class="hljs-string">"3.14159"</span>);  <span class="hljs-comment">// 将字符串转换为浮点数：3.14159</span>
</code></pre>
<p>注意事项：</p>
<ul>
<li>C风格字符串函数不检查边界，可能导致缓冲区溢出和安全问题</li>
<li>使用时必须确保目标数组有足够空间</li>
<li>函数如<code>strncpy</code>不会自动添加null结束符，需手动添加</li>
<li>推荐使用C++ string类替代这些函数，更安全可靠</li>
</ul>
<h3 id="c-string类函数-string">C++ string类函数 (<code>&lt;string&gt;</code>)</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 构造和基本操作</span>
<span class="hljs-built_in">string</span> str;              <span class="hljs-comment">// 创建空字符串</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(n, c)</span></span>;        <span class="hljs-comment">// 创建包含n个字符c的字符串</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(other_str)</span></span>;   <span class="hljs-comment">// 从另一个string创建（复制构造）</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">str</span><span class="hljs-params">(char_array)</span></span>;  <span class="hljs-comment">// 从C风格字符串创建</span>

<span class="hljs-comment">// 大小和容量</span>
str.length(), str.size() <span class="hljs-comment">// 字符串长度（以字符计）</span>
str.empty()              <span class="hljs-comment">// 检查字符串是否为空</span>
str.capacity()           <span class="hljs-comment">// 返回当前分配的存储空间大小</span>
str.reserve(n)           <span class="hljs-comment">// 预留至少能存储n个字符的空间</span>
str.shrink_to_fit()      <span class="hljs-comment">// 减少容量以适应实际大小</span>

<span class="hljs-comment">// 元素访问</span>
str[i]                   <span class="hljs-comment">// 访问第i个字符（无边界检查）</span>
str.at(i)                <span class="hljs-comment">// 访问第i个字符（有边界检查，越界抛出异常）</span>
str.front()              <span class="hljs-comment">// 访问第一个字符</span>
str.back()               <span class="hljs-comment">// 访问最后一个字符</span>
str.data(), str.c_str()  <span class="hljs-comment">// 获取底层的C风格字符串指针</span>

<span class="hljs-comment">// 修改操作</span>
str.clear()              <span class="hljs-comment">// 清空字符串内容</span>
str.insert(pos, s)       <span class="hljs-comment">// 在位置pos插入字符串s</span>
str.erase(pos, len)      <span class="hljs-comment">// 从位置pos开始删除len个字符</span>
str.replace(pos, len, s) <span class="hljs-comment">// 用s替换从pos开始的len个字符</span>
str.append(s)            <span class="hljs-comment">// 追加字符串s到末尾</span>
str.push_back(c)         <span class="hljs-comment">// 追加字符c到末尾</span>
str.pop_back()           <span class="hljs-comment">// 删除最后一个字符</span>
str += s                 <span class="hljs-comment">// 字符串连接（操作符重载）</span>

<span class="hljs-comment">// 查找操作</span>
str.find(s)              <span class="hljs-comment">// 查找子串s首次出现的位置</span>
str.rfind(s)             <span class="hljs-comment">// 查找子串s最后出现的位置</span>
str.find_first_of(s)     <span class="hljs-comment">// 查找s中任何字符首次出现的位置</span>
str.find_last_of(s)      <span class="hljs-comment">// 查找s中任何字符最后出现的位置</span>
str.find_first_not_of(s) <span class="hljs-comment">// 查找不在s中的任何字符首次出现位置</span>
str.find_last_not_of(s)  <span class="hljs-comment">// 查找不在s中的任何字符最后出现位置</span>

<span class="hljs-comment">// 子串操作</span>
str.substr(pos, len)     <span class="hljs-comment">// 提取子串，从pos开始len个字符</span>

<span class="hljs-comment">// 比较操作</span>
str.compare(s)           <span class="hljs-comment">// 比较两个字符串，相等返回0</span>
str == s, str != s       <span class="hljs-comment">// 字符串相等/不等比较</span>
str &lt; s, str &gt; s         <span class="hljs-comment">// 字符串大小比较（字典序）</span>

<span class="hljs-comment">// 数值转换</span>
stoi(str), stol(str)     <span class="hljs-comment">// 字符串转整数（int, long）</span>
stof(str), stod(str)     <span class="hljs-comment">// 字符串转浮点数（float, double）</span>
to_string(val)           <span class="hljs-comment">// 数值转字符串</span>
</code></pre>
<p>详细示例：</p>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>

<span class="hljs-comment">// 字符串创建和基本操作</span>
<span class="hljs-built_in">string</span> s1 = <span class="hljs-string">"Hello"</span>;
<span class="hljs-built_in">string</span> s2 = <span class="hljs-string">" World"</span>;
<span class="hljs-built_in">string</span> s3 = s1 + s2;          <span class="hljs-comment">// 字符串连接："Hello World"</span>

<span class="hljs-comment">// 字符串检查</span>
<span class="hljs-keyword">bool</span> empty = s1.empty();       <span class="hljs-comment">// 检查是否为空：false</span>
<span class="hljs-keyword">size_t</span> len = s1.length();      <span class="hljs-comment">// 获取长度：5</span>
<span class="hljs-keyword">char</span> first = s1[<span class="hljs-number">0</span>];            <span class="hljs-comment">// 获取第一个字符：'H'</span>
<span class="hljs-keyword">char</span> last = s1.back();         <span class="hljs-comment">// 获取最后一个字符：'o'</span>
<span class="hljs-keyword">char</span> safe_access = s1.at(<span class="hljs-number">2</span>);   <span class="hljs-comment">// 安全访问第3个字符：'l'</span>

<span class="hljs-comment">// 字符串修改</span>
s1.append(<span class="hljs-string">" C++"</span>);             <span class="hljs-comment">// 追加字符串："Hello C++"</span>
s1.push_back(<span class="hljs-string">'!'</span>);             <span class="hljs-comment">// 追加字符：'Hello C++!'</span>
s1.insert(<span class="hljs-number">5</span>, <span class="hljs-string">" Modern"</span>);       <span class="hljs-comment">// 在位置5插入字符串："Hello Modern C++!"</span>
s1.replace(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-string">"New"</span>);       <span class="hljs-comment">// 替换位置6开始的6个字符："Hello New C++!"</span>
s1.erase(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>);                <span class="hljs-comment">// 删除从位置5开始的4个字符："Hello C++!"</span>
s1.pop_back();                 <span class="hljs-comment">// 删除最后一个字符："Hello C++"</span>
s1.clear();                    <span class="hljs-comment">// 清空字符串：""</span>

<span class="hljs-comment">// 子串操作</span>
<span class="hljs-built_in">string</span> sentence = <span class="hljs-string">"Hello World C++"</span>;
<span class="hljs-built_in">string</span> sub = sentence.substr(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>);  <span class="hljs-comment">// 提取子串："World"</span>

<span class="hljs-comment">// 搜索操作</span>
<span class="hljs-keyword">size_t</span> pos = sentence.find(<span class="hljs-string">"World"</span>); <span class="hljs-comment">// 查找子串："World"位置为6</span>
pos = sentence.rfind(<span class="hljs-string">"l"</span>);          <span class="hljs-comment">// 从右侧查找'l'，位置为9</span>
pos = sentence.find_first_of(<span class="hljs-string">"Wo"</span>); <span class="hljs-comment">// 查找'W'或'o'首次出现，位置为6（'W'）</span>
pos = sentence.find_last_of(<span class="hljs-string">"Wo"</span>);  <span class="hljs-comment">// 查找'W'或'o'最后出现，位置为8（'o'）</span>

<span class="hljs-comment">// string::npos 常量表示"未找到"或"直到字符串末尾"</span>
<span class="hljs-keyword">if</span> (sentence.find(<span class="hljs-string">"Java"</span>) == <span class="hljs-built_in">string</span>::npos) {
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Java not found in the string"</span> &lt;&lt; endl;
}

<span class="hljs-comment">// 字符串比较</span>
<span class="hljs-keyword">bool</span> equals = (s1 == s2);           <span class="hljs-comment">// 检查s1是否等于s2</span>
<span class="hljs-keyword">int</span> cmp = sentence.compare(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// 比较字符串，不相等返回非零值</span>

<span class="hljs-comment">// 字符串与数值转换</span>
<span class="hljs-built_in">string</span> num_str = <span class="hljs-string">"123.45"</span>;
<span class="hljs-keyword">int</span> i = stoi(<span class="hljs-string">"123"</span>);          <span class="hljs-comment">// 字符串转int：123</span>
<span class="hljs-keyword">double</span> d = stod(num_str);     <span class="hljs-comment">// 字符串转double：123.45</span>

<span class="hljs-built_in">string</span> str_i = to_string(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 整数转字符串："42"</span>
<span class="hljs-built_in">string</span> str_d = to_string(<span class="hljs-number">3.14</span>); <span class="hljs-comment">// 浮点数转字符串："3.140000"</span>

<span class="hljs-comment">// 字符串分割（C++没有内置的split函数，需要自己实现）</span>
<span class="hljs-built_in">string</span> csv = <span class="hljs-string">"apple,banana,orange,grape"</span>;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; tokens;
<span class="hljs-keyword">size_t</span> start = <span class="hljs-number">0</span>;
<span class="hljs-keyword">size_t</span> end = csv.find(<span class="hljs-string">","</span>);
<span class="hljs-keyword">while</span> (end != <span class="hljs-built_in">string</span>::npos) {
    tokens.push_back(csv.substr(start, end - start));
    start = end + <span class="hljs-number">1</span>;
    end = csv.find(<span class="hljs-string">","</span>, start);
}
tokens.push_back(csv.substr(start)); <span class="hljs-comment">// 添加最后一个部分</span>

<span class="hljs-comment">// 输出分割后的结果：</span>
<span class="hljs-comment">// tokens = {"apple", "banana", "orange", "grape"}</span>

<span class="hljs-comment">// 字符串连接（join操作）</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; words = {<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"Modern"</span>, <span class="hljs-string">"C++"</span>};
<span class="hljs-built_in">string</span> joined = words[<span class="hljs-number">0</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">1</span>; i &lt; words.size(); ++i) {
    joined += <span class="hljs-string">" "</span> + words[i];
}
<span class="hljs-comment">// joined = "Hello Modern C++"</span>

<span class="hljs-comment">// 更高效的字符串构建（对于大量拼接）</span>
<span class="hljs-built_in">string</span> large_str;
large_str.reserve(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 预先分配空间避免多次重新分配</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {
    large_str += <span class="hljs-string">"item "</span> + to_string(i) + <span class="hljs-string">", "</span>;
}
</code></pre>
<p>字符串处理的高级技巧：</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// 字符串转换为大写或小写</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">to_upper</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
    transform(s.begin(), s.end(), s.begin(),
              [](<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> c) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">toupper</span>(c); });
    <span class="hljs-keyword">return</span> s;
}

<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">to_lower</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>{
    transform(s.begin(), s.end(), s.begin(),
              [](<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> c) { <span class="hljs-keyword">return</span> <span class="hljs-built_in">tolower</span>(c); });
    <span class="hljs-keyword">return</span> s;
}

<span class="hljs-comment">// 修剪字符串（去除前后空白）</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">trim</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s)</span> </span>{
    <span class="hljs-comment">// 查找第一个非空白字符</span>
    <span class="hljs-keyword">auto</span> start = s.find_first_not_of(<span class="hljs-string">" \t\n\r\f\v"</span>);
    <span class="hljs-comment">// 如果字符串全是空白，则返回空字符串</span>
    <span class="hljs-keyword">if</span> (start == <span class="hljs-built_in">string</span>::npos) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;

    <span class="hljs-comment">// 查找最后一个非空白字符</span>
    <span class="hljs-keyword">auto</span> end = s.find_last_not_of(<span class="hljs-string">" \t\n\r\f\v"</span>);
    <span class="hljs-comment">// 返回修剪后的子串</span>
    <span class="hljs-keyword">return</span> s.substr(start, end - start + <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// 字符串分割函数</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; split(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; delimiter) {
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; tokens;
    <span class="hljs-keyword">size_t</span> last = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">size_t</span> next = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> ((next = s.find(delimiter, last)) != <span class="hljs-built_in">string</span>::npos) {
        tokens.push_back(s.substr(last, next - last));
        last = next + delimiter.length();
    }
    tokens.push_back(s.substr(last));
    <span class="hljs-keyword">return</span> tokens;
}

<span class="hljs-comment">// 字符串连接函数</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; delimiter)</span> </span>{
    <span class="hljs-keyword">if</span> (strs.empty()) <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;

    <span class="hljs-built_in">string</span> result = strs[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">1</span>; i &lt; strs.size(); ++i) {
        result += delimiter + strs[i];
    }
    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 字符串替换（替换所有匹配子串）</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">replace_all</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; from, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; to)</span> </span>{
    <span class="hljs-keyword">size_t</span> start_pos = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> ((start_pos = str.find(from, start_pos)) != <span class="hljs-built_in">string</span>::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length(); <span class="hljs-comment">// 避免无限循环</span>
    }
    <span class="hljs-keyword">return</span> str;
}

<span class="hljs-comment">// 检查字符串是否以某个前缀开始</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">starts_with</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; prefix)</span> </span>{
    <span class="hljs-keyword">return</span> str.size() &gt;= prefix.size() &amp;&amp; 
           str.compare(<span class="hljs-number">0</span>, prefix.size(), prefix) == <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 检查字符串是否以某个后缀结束</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">ends_with</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; suffix)</span> </span>{
    <span class="hljs-keyword">return</span> str.size() &gt;= suffix.size() &amp;&amp; 
           str.compare(str.size() - suffix.size(), suffix.size(), suffix) == <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 将字符串转换为数值类型，带错误处理</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
optional&lt;T&gt; string_to_number(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str) {
    T value;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(is_same_v&lt;T, <span class="hljs-keyword">int</span>&gt;)</span>
            value </span>= stoi(str);
        <span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(is_same_v&lt;T, <span class="hljs-keyword">long</span>&gt;)</span>
            value </span>= stol(str);
        <span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(is_same_v&lt;T, <span class="hljs-keyword">double</span>&gt;)</span>
            value </span>= stod(str);
        <span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(is_same_v&lt;T, <span class="hljs-keyword">float</span>&gt;)</span>
            value </span>= stof(str);
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> nullopt;

        <span class="hljs-keyword">return</span> value;
    } <span class="hljs-keyword">catch</span> (...) {
        <span class="hljs-keyword">return</span> nullopt; <span class="hljs-comment">// 转换失败</span>
    }
}

<span class="hljs-comment">// 字符串格式化（C++20特性，此处仅为概念示例）</span>
<span class="hljs-comment">// 在C++20之前，可以使用sprintf或stringstream实现类似功能</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">format_example</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">string</span> name = <span class="hljs-string">"Alice"</span>;
    <span class="hljs-keyword">int</span> age = <span class="hljs-number">30</span>;

    <span class="hljs-comment">// C++20方式（需要支持&lt;format&gt;库）</span>
    <span class="hljs-comment">// return std::format("{} is {} years old", name, age);</span>

    <span class="hljs-comment">// 使用stringstream的替代方法</span>
    <span class="hljs-built_in">stringstream</span> ss;
    ss &lt;&lt; name &lt;&lt; <span class="hljs-string">" is "</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">" years old"</span>;
    <span class="hljs-keyword">return</span> ss.str();
}
</code></pre>
<p>注意事项：</p>
<ul>
<li>C++17标准库没有内建的字符串split、join功能，需要自行实现</li>
<li>C++20引入了<code>starts_with</code>、<code>ends_with</code>方法和<code>&lt;format&gt;</code>库，但在竞赛中可能不可用</li>
<li>处理大量字符串连接时，使用<code>stringstream</code>或<code>reserve</code>+<code>append</code>比反复<code>+</code>更高效</li>
<li>字符串查找失败时返回<code>string::npos</code>，记得检查这种情况</li>
<li>C++中不同于某些语言，字符串是可变的，许多操作会直接修改原字符串</li>
</ul>
<h2 id="时间复杂度总结">时间复杂度总结</h2>
<p>下面是常见STL函数的时间复杂度：</p>
<h3 id="容器操作">容器操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set/map</th>
<th>unordered_set/map</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机访问 []</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(N)</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>插入/删除（末尾）</td>
<td>O(1)*</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(1) 平均</td>
</tr>
<tr>
<td>插入/删除（开头）</td>
<td>O(N)</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(logN)</td>
<td>O(1) 平均</td>
</tr>
<tr>
<td>插入/删除（中间）</td>
<td>O(N)</td>
<td>O(N)</td>
<td>O(1)**</td>
<td>O(logN)</td>
<td>O(1) 平均</td>
</tr>
<tr>
<td>查找</td>
<td>O(N)</td>
<td>O(N)</td>
<td>O(N)</td>
<td>O(logN)</td>
<td>O(1) 平均</td>
</tr>
</tbody>
</table>
<p>* 对于vector，如果需要扩容则为O(N)
** 对于list，如果已知位置（迭代器）则为O(1)，否则需要O(N)查找</p>
<h3 id="常用算法">常用算法</h3>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort</td>
<td>O(N log N)</td>
<td>O(log N)</td>
</tr>
<tr>
<td>stable_sort</td>
<td>O(N log N)</td>
<td>O(N) 或 O(1)</td>
</tr>
<tr>
<td>nth_element</td>
<td>O(N) 平均</td>
<td>O(1)</td>
</tr>
<tr>
<td>binary_search</td>
<td>O(log N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>merge</td>
<td>O(N+M)</td>
<td>O(N+M)</td>
</tr>
<tr>
<td>accumulate</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>find/count</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>min/max_element</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>copy/transform</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>unique</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>next_permutation</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h2 id="实用技巧与最佳实践">实用技巧与最佳实践</h2>
<h3 id="1-使用合适的容器">1. 使用合适的容器</h3>
<ul>
<li>需要频繁随机访问元素：<code>vector</code></li>
<li>需要频繁在两端操作：<code>deque</code></li>
<li>需要频繁在中间插入/删除：<code>list</code></li>
<li>需要保持元素排序：<code>set</code>, <code>map</code></li>
<li>需要快速查找但不关心顺序：<code>unordered_set</code>, <code>unordered_map</code></li>
</ul>
<h3 id="2-迭代器优化">2. 迭代器优化</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 避免重复计算end()</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 较差的方式</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.size(); ++i) {
    <span class="hljs-comment">// v.size() 每次循环都会调用</span>
}

<span class="hljs-comment">// 更好的方式</span>
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::size_type i = <span class="hljs-number">0</span>, size = v.size(); i &lt; size; ++i) {
    <span class="hljs-comment">// size只计算一次</span>
}

<span class="hljs-comment">// 现代C++的方式</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; item : v) {
    <span class="hljs-comment">// 使用范围for循环</span>
}

<span class="hljs-comment">// 迭代器失效问题</span>
<span class="hljs-keyword">auto</span> it = v.begin();
v.erase(it);     <span class="hljs-comment">// it现在无效</span>
it = v.begin();  <span class="hljs-comment">// 重新获取有效迭代器</span>
</code></pre>
<h3 id="3-算法组合技巧">3. 算法组合技巧</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 寻找前k大/小元素</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>};
<span class="hljs-keyword">int</span> k = <span class="hljs-number">3</span>;

<span class="hljs-comment">// 第一种方法：排序后取前k个</span>
sort(v.begin(), v.end());
<span class="hljs-comment">// 前k小: v[0]到v[k-1]</span>

<span class="hljs-comment">// 第二种方法：使用nth_element更高效</span>
nth_element(v.begin(), v.begin() + k - <span class="hljs-number">1</span>, v.end());
<span class="hljs-comment">// 现在前k个元素是最小的k个（不一定有序）</span>

<span class="hljs-comment">// 第三种方法：使用partial_sort</span>
partial_sort(v.begin(), v.begin() + k, v.end());
<span class="hljs-comment">// 前k个元素是有序的最小k个</span>

<span class="hljs-comment">// 查找特定范围的元素</span>
<span class="hljs-keyword">auto</span> range = equal_range(v.begin(), v.end(), <span class="hljs-number">5</span>);
<span class="hljs-keyword">bool</span> found = (range.first != range.second);
</code></pre>
<h3 id="4-使用合适的函数">4. 使用合适的函数</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算乘积：使用accumulate而非循环</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-keyword">int</span> product = accumulate(v.begin(), v.end(), <span class="hljs-number">1</span>, multiplies&lt;<span class="hljs-keyword">int</span>&gt;());

<span class="hljs-comment">// 高效寻找最大值和位置</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>};
<span class="hljs-keyword">auto</span> max_it = max_element(v.begin(), v.end());
<span class="hljs-keyword">int</span> max_value = *max_it;
<span class="hljs-keyword">int</span> max_position = distance(v.begin(), max_it);

<span class="hljs-comment">// 去除重复元素（需要先排序）</span>
sort(v.begin(), v.end());
<span class="hljs-keyword">auto</span> new_end = unique(v.begin(), v.end());
v.erase(new_end, v.end());
</code></pre>
<h3 id="5-性能优化">5. 性能优化</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 预分配容器空间</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
v.reserve(<span class="hljs-number">10000</span>); <span class="hljs-comment">// 避免频繁重新分配内存</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
    v.push_back(i); <span class="hljs-comment">// 不会导致重新分配</span>
}

<span class="hljs-comment">// 批量插入</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; src = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dest;
<span class="hljs-comment">// 比循环中push_back更高效</span>
dest.insert(dest.end(), src.begin(), src.end());

<span class="hljs-comment">// 交换技巧清空容器</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;().swap(v); <span class="hljs-comment">// 高效清空并释放内存</span>
</code></pre>
<h3 id="6-常见错误避免">6. 常见错误避免</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 避免在循环中调整容器大小</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; ++i) {
    v.push_back(i);  <span class="hljs-comment">// 可能导致多次重新分配</span>
}
<span class="hljs-comment">// 修正：使用reserve()或resize()预先分配空间</span>

<span class="hljs-comment">// 避免迭代器失效</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 错误方式</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.begin(); it != v.end(); ++it) {
    <span class="hljs-keyword">if</span> (*it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        v.erase(it);  <span class="hljs-comment">// 迭代器失效!</span>
    }
}
<span class="hljs-comment">// 正确方式</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = v.begin(); it != v.end(); ) {
    <span class="hljs-keyword">if</span> (*it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        it = v.erase(it); <span class="hljs-comment">// erase返回下一个有效迭代器</span>
    } <span class="hljs-keyword">else</span> {
        ++it;
    }
}

<span class="hljs-comment">// 或使用remove_if和erase的组合</span>
v.erase(
    remove_if(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> n){ <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; }),
    v.end()
);
</code></pre>
<hr></hr>
<p>这份指南涵盖了ACM竞赛中最常用的STL函数及其用法。通过熟练掌握这些函数，你可以用更少的代码解决更复杂的问题，并且提高代码的效率和可读性。在实际竞赛中，选择合适的算法和数据结构往往比编写复杂的自定义实现更为明智。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="ACM常用算法.html" class="navigation navigation-prev " aria-label="Previous page: ACM常用算法">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="stl容器.html" class="navigation navigation-next " aria-label="Next page: stl容器">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"STL常用函数","level":"1.1.11","depth":2,"next":{"title":"stl容器","level":"1.1.12","depth":2,"path":"stl容器.md","ref":"stl容器.md","articles":[]},"previous":{"title":"ACM常用算法","level":"1.1.10","depth":2,"path":"ACM常用算法.md","ref":"ACM常用算法.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"STL常用函数.md","mtime":"2025-04-25T11:45:23.849Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:25:04.518Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

