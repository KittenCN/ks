
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>算法比赛技巧 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="CoderFAN 资料库 算法资料 实战练习指导">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="常见解题模板.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="实战练习概述.html">
            
                <a href="实战练习概述.html">
            
                    
                    实战练习指导
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="如何分析问题.html">
            
                <a href="如何分析问题.html">
            
                    
                    如何分析问题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="常见解题模板.html">
            
                <a href="常见解题模板.html">
            
                    
                    常见解题模板
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.3" data-path="算法比赛技巧.html">
            
                <a href="算法比赛技巧.html">
            
                    
                    算法比赛技巧
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >算法比赛技巧</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h2 id="算法比赛技巧">算法比赛技巧</h2>
<h2 id="引言">引言</h2>
<p>ACM竞赛不仅是对算法和编程能力的考验，更是对参赛者分析问题、管理时间和应对压力能力的综合测试。本文将分享一系列实用的竞赛技巧，帮助你在算法比赛中取得更好的成绩。</p>
<h2 id="赛前准备">赛前准备</h2>
<h3 id="团队协作策略">团队协作策略</h3>
<p>在团队赛中，合理的分工与协作至关重要：</p>
<ol>
<li><p><strong>根据专长分工</strong>：让每位队员负责自己最擅长的领域，如图论、动态规划或数学问题。</p>
</li>
<li><p><strong>交叉覆盖</strong>：确保每类问题至少有两人熟悉，以防某人被困在难题上。</p>
</li>
<li><p><strong>预设角色</strong>：可以设定几种角色组合，如：</p>
<ul>
<li>一人读题并构建测试用例</li>
<li>一人设计算法并编码</li>
<li>一人进行代码审核和测试</li>
</ul>
</li>
<li><p><strong>建立沟通机制</strong>：约定清晰的沟通规则和信号，例如：</p>
<ul>
<li>"我需要帮助" - 无法在合理时间内解决问题</li>
<li>"我快完成了" - 预计5分钟内能完成当前题目</li>
<li>"这题很难" - 难度超出预期，需要重新评估</li>
</ul>
</li>
</ol>
<h3 id="个人准备清单">个人准备清单</h3>
<p>比赛前，确保你已准备好：</p>
<ol>
<li><strong>代码模板</strong>：常见算法和数据结构的实现模板</li>
<li><strong>环境配置</strong>：熟悉比赛平台和编程环境</li>
<li><strong>个人工具</strong>：准备好草稿纸、笔和允许使用的参考资料</li>
<li><strong>身心状态</strong>：保证充足的休息和适度的放松</li>
<li><strong>应急预案</strong>：为可能遇到的困难准备对策</li>
</ol>
<h3 id="模板准备">模板准备</h3>
<p>准备精简且易用的代码模板，包括但不限于：</p>
<ol>
<li><strong>数据结构</strong>：线段树、树状数组、并查集、字典树等</li>
<li><strong>图论算法</strong>：最短路、最小生成树、网络流等</li>
<li><strong>字符串</strong>：KMP、AC自动机、后缀数组等</li>
<li><strong>数学</strong>：快速幂、组合数计算、素数筛等</li>
<li><strong>IO优化</strong>：快速读写函数</li>
</ol>
<h2 id="比赛策略">比赛策略</h2>
<h3 id="读题与选题">读题与选题</h3>
<ol>
<li><p><strong>【快速筛选】</strong>：开始比赛后，快速浏览所有题目描述：</p>
<ul>
<li>记下每题的数据范围、约束条件</li>
<li>初步判断每题的难度和可能的算法类型</li>
</ul>
</li>
<li><p><strong>【优先级排序】</strong>：按以下标准对题目排序：</p>
<ul>
<li>确定能解的简单题 &gt; 似乎能解但需思考的题 &gt; 不确定的难题</li>
<li>注意分值分配，优先解决高分/时间比的题目</li>
</ul>
</li>
<li><p><strong>【读题技巧】</strong>：</p>
<ul>
<li>反复阅读，确保理解所有条件</li>
<li>手动构造小规模测试用例验证理解</li>
<li>特别注意边界条件和特殊情况</li>
</ul>
</li>
</ol>
<pre><code>// 示例：读题清单
1. 问题本质是什么？（图论/DP/贪心/...）
2. 输入规模和约束是什么？（n ≤ 10^5 等）
3. 边界情况有哪些？
4. 是否有特殊条件？
</code></pre><h3 id="时间管理">时间管理</h3>
<ol>
<li><p><strong>【三阶段分配】</strong>：</p>
<ul>
<li><strong>初期</strong>（前30%时间）：快速解决简单题，建立信心</li>
<li><strong>中期</strong>（中间50%时间）：攻克难度中等的题目</li>
<li><strong>后期</strong>（最后20%时间）：改进解法，争取额外分数</li>
</ul>
</li>
<li><p><strong>【设定截止时间】</strong>：为每道题设定一个时间限制，若超时则：</p>
<ul>
<li>重新评估算法思路</li>
<li>寻求队友帮助</li>
<li>暂时搁置，转战其他题目</li>
</ul>
</li>
<li><p><strong>【预留调试时间】</strong>：为每道题预留足够的调试和优化时间，避免仓促提交导致多次错误。</p>
</li>
</ol>
<h3 id="调试策略">调试策略</h3>
<ol>
<li><p><strong>【系统性调试】</strong>：</p>
<ul>
<li>先检查算法逻辑，再检查代码实现</li>
<li>使用小规模测试用例手动验证结果</li>
<li>添加断言和输出语句追踪关键变量</li>
</ul>
</li>
<li><p><strong>【常见错误检查表】</strong>：</p>
<ul>
<li>数组越界或指针错误</li>
<li>整数溢出</li>
<li>初始化错误</li>
<li>循环条件错误</li>
<li>边界条件处理</li>
</ul>
</li>
<li><p><strong>【二分调试法】</strong>：当程序错误不明显时，使用二分法定位问题：</p>
<ul>
<li>在程序中间位置添加输出</li>
<li>根据输出结果，确定错误在前半部分还是后半部分</li>
<li>递进缩小范围，直到定位错误</li>
</ul>
</li>
</ol>
<pre><code class="lang-cpp"><span class="hljs-comment">// 调试辅助函数</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> DEBUG</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">ifdef</span> DEBUG</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> dbg(x) cout &lt;&lt; <span class="hljs-string">"DEBUG: "</span> &lt;&lt; #x &lt;&lt; <span class="hljs-string">" = "</span> &lt;&lt; x &lt;&lt; endl</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> dbg(x)</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<h2 id="解题技巧">解题技巧</h2>
<h3 id="问题转化">问题转化</h3>
<p>学会将未知问题转化为已知问题类型：</p>
<ol>
<li><p><strong>【识别问题模式】</strong>：</p>
<ul>
<li>最优化问题 → 动态规划</li>
<li>连通性问题 → 图论（DFS/BFS）</li>
<li>区间查询 → 线段树/树状数组</li>
<li>字符串匹配 → KMP/Trie/后缀数组</li>
</ul>
</li>
<li><p><strong>【等价转换】</strong>：</p>
<ul>
<li>最大化问题 ↔ 最小化问题的负值</li>
<li>直接计算 ↔ 反向计算（从结果推原因）</li>
<li>绝对值处理 → 分类讨论或平方处理</li>
</ul>
</li>
<li><p><strong>【减少问题规模】</strong>：</p>
<ul>
<li>找规律：寻找数学关系或递推公式</li>
<li>分治：将大问题拆分为小规模子问题</li>
<li>预处理：提前计算频繁使用的结果</li>
</ul>
</li>
</ol>
<h3 id="特殊情况处理">特殊情况处理</h3>
<ol>
<li><p><strong>【关注边界条件】</strong>：</p>
<ul>
<li>空集、单元素集合</li>
<li>最大值、最小值</li>
<li>满员、空缺</li>
<li>首尾节点</li>
</ul>
</li>
<li><p><strong>【特殊结构利用】</strong>：</p>
<ul>
<li>单调性（如单调栈/队列）</li>
<li>周期性</li>
<li>对称性</li>
<li>二分性质</li>
</ul>
</li>
<li><p><strong>【简化与逼近】</strong>：</p>
<ul>
<li>先解决简化版本的问题</li>
<li>使用贪心策略尝试构造解</li>
<li>从暴力解法开始，逐步优化</li>
</ul>
</li>
</ol>
<h3 id="证明与反证">证明与反证</h3>
<ol>
<li><p><strong>【正确性验证】</strong>：</p>
<ul>
<li>使用数学归纳法证明</li>
<li>验证极端情况</li>
<li>检查是否满足问题的所有约束</li>
</ul>
</li>
<li><p><strong>【反例思考】</strong>：</p>
<ul>
<li>尝试构造反例，推翻自己的算法</li>
<li>常见反例：最小规模、最大规模、等值元素、全相同元素等</li>
</ul>
</li>
<li><p><strong>【直觉检验】</strong>：凭借经验判断结果是否合理，非正式但有效的验证方法。</p>
</li>
</ol>
<h2 id="常见问题与应对策略">常见问题与应对策略</h2>
<h3 id="算法超时">算法超时</h3>
<ol>
<li><p><strong>【思路优化】</strong>：</p>
<ul>
<li>换用更高效的算法（如O(n²)→O(nlogn)）</li>
<li>减少不必要的计算</li>
<li>利用问题特性进行剪枝</li>
</ul>
</li>
<li><p><strong>【代码优化】</strong>：</p>
<ul>
<li>使用更高效的数据结构</li>
<li>预计算和缓存结果</li>
<li>避免重复计算</li>
</ul>
</li>
</ol>
<pre><code class="lang-cpp"><span class="hljs-comment">// 示例：使用记忆化搜索避免重复计算</span>
<span class="hljs-keyword">int</span> memo[MAXN];
<span class="hljs-keyword">bool</span> calculated[MAXN] = {<span class="hljs-literal">false</span>};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">if</span> (calculated[n]) <span class="hljs-keyword">return</span> memo[n];
    <span class="hljs-comment">// 计算结果</span>
    <span class="hljs-keyword">int</span> result = ...;
    memo[n] = result;
    calculated[n] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<ol>
<li><strong>【常数优化】</strong>：<ul>
<li>减少函数调用</li>
<li>使用位运算替代乘除</li>
<li>避免多余的内存分配</li>
</ul>
</li>
</ol>
<h3 id="内存限制">内存限制</h3>
<ol>
<li><p><strong>【数据结构选择】</strong>：</p>
<ul>
<li>使用数组替代链表（减少指针开销）</li>
<li>使用位操作存储布尔值</li>
<li>选择空间效率高的数据结构</li>
</ul>
</li>
<li><p><strong>【内存复用】</strong>：</p>
<ul>
<li>滚动数组：只保留必要的状态</li>
<li>原地算法：直接在输入数组上操作</li>
</ul>
</li>
</ol>
<pre><code class="lang-cpp"><span class="hljs-comment">// 示例：动态规划中的滚动数组</span>
<span class="hljs-comment">// 原始：</span>
<span class="hljs-comment">// dp[n][m]</span>
<span class="hljs-comment">// 优化：</span>
<span class="hljs-comment">// dp[2][m]</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {
        dp[i % <span class="hljs-number">2</span>][j] = f(dp[(i-<span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j], ...);
    }
}
</code></pre>
<ol>
<li><strong>【减少冗余】</strong>：<ul>
<li>压缩存储（如状态压缩）</li>
<li>只存储必要信息</li>
</ul>
</li>
</ol>
<h3 id="精度问题">精度问题</h3>
<ol>
<li><strong>【避免浮点比较】</strong>：<ul>
<li>使用epsilon进行浮点数比较</li>
<li>将浮点问题转化为整数问题</li>
</ul>
</li>
</ol>
<pre><code class="lang-cpp"><span class="hljs-comment">// 浮点数比较</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> EPS = <span class="hljs-number">1e-9</span>;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEqual</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - b) &lt; EPS;
}
</code></pre>
<ol>
<li><p><strong>【分数表示】</strong>：使用分子分母表示精确值，避免浮点误差。</p>
</li>
<li><p><strong>【放大缩小】</strong>：适当放大或缩小所有数据，避免精度丢失。</p>
</li>
</ol>
<h2 id="提交策略">提交策略</h2>
<h3 id="提交前检查">提交前检查</h3>
<p>每次提交前，确认以下事项：</p>
<ol>
<li><p><strong>【代码完整性】</strong>：</p>
<ul>
<li>所有函数都被正确实现</li>
<li>主函数中调用了解法函数</li>
<li>输出格式符合要求</li>
</ul>
</li>
<li><p><strong>【边界处理】</strong>：</p>
<ul>
<li>数组索引不越界</li>
<li>处理了所有可能的输入情况</li>
<li>考虑了空输入或最小/最大输入</li>
</ul>
</li>
<li><p><strong>【错误处理】</strong>：</p>
<ul>
<li>处理了可能的除零情况</li>
<li>处理了可能的溢出问题</li>
<li>避免未初始化变量</li>
</ul>
</li>
</ol>
<h3 id="增量式提交">增量式提交</h3>
<p>对于复杂问题，可采用增量式提交策略：</p>
<ol>
<li><p><strong>【先实现基础版本】</strong>：</p>
<ul>
<li>仅处理主要情况</li>
<li>验证基本逻辑正确</li>
</ul>
</li>
<li><p><strong>【逐步改进】</strong>：</p>
<ul>
<li>处理特殊情况</li>
<li>优化时间和空间复杂度</li>
</ul>
</li>
<li><p><strong>【保留通过版本】</strong>：</p>
<ul>
<li>保存已通过的简单版本</li>
<li>在此基础上进行改进</li>
</ul>
</li>
</ol>
<h3 id="多次提交处理">多次提交处理</h3>
<p>当提交被拒绝时：</p>
<ol>
<li><p><strong>【分析错误类型】</strong>：</p>
<ul>
<li>WA（Wrong Answer）：逻辑错误或边界处理不当</li>
<li>TLE（Time Limit Exceeded）：算法效率低或循环出错</li>
<li>MLE（Memory Limit Exceeded）：内存使用过多</li>
<li>RE（Runtime Error）：数组越界、除零等运行时错误</li>
<li>CE（Compilation Error）：语法错误</li>
</ul>
</li>
<li><p><strong>【针对性修复】</strong>：</p>
<ul>
<li>WA：检查算法逻辑和边界条件</li>
<li>TLE：优化算法或代码</li>
<li>MLE：减少内存使用</li>
<li>RE：检查数组访问和异常情况</li>
<li>CE：修复语法错误</li>
</ul>
</li>
<li><p><strong>【反思与改进】</strong>：</p>
<ul>
<li>分析错误原因</li>
<li>总结经验教训</li>
<li>调整解题策略</li>
</ul>
</li>
</ol>
<h2 id="心态管理">心态管理</h2>
<h3 id="压力处理">压力处理</h3>
<p>比赛中保持良好心态：</p>
<ol>
<li><strong>【接受挑战】</strong>：将困难视为挑战而非威胁</li>
<li><strong>【专注当下】</strong>：只关注当前正在解决的问题</li>
<li><strong>【积极自我对话】</strong>：避免消极思想，保持建设性思维</li>
<li><strong>【短暂休息】</strong>：遇到瓶颈时，短暂休息清空思路</li>
</ol>
<h3 id="高效沟通">高效沟通</h3>
<p>团队赛中的沟通技巧：</p>
<ol>
<li><strong>【清晰表达】</strong>：简洁明了地描述问题和思路</li>
<li><strong>【积极倾听】</strong>：认真理解队友的想法和建议</li>
<li><strong>【建设性批评】</strong>：提出问题的同时提供解决方案</li>
<li><strong>【及时反馈】</strong>：主动分享进展，早发现早解决问题</li>
</ol>
<h3 id="失误恢复">失误恢复</h3>
<p>从失误中快速恢复：</p>
<ol>
<li><strong>【承认错误】</strong>：坦然面对错误，避免过度自责</li>
<li><strong>【限时思考】</strong>：给自己设定短暂的思考时间，然后果断决策</li>
<li><strong>【重新规划】</strong>：调整计划，最大化剩余时间的效益</li>
<li><strong>【吸取教训】</strong>：记录经验，避免再犯同样的错误</li>
</ol>
<h2 id="比赛后分析">比赛后分析</h2>
<h3 id="个人提升">个人提升</h3>
<p>每场比赛后的自我总结：</p>
<ol>
<li><strong>【解题记录】</strong>：记录每道题的思路、难点和解决方法</li>
<li><strong>【错误分析】</strong>：总结犯错原因，制定改进计划</li>
<li><strong>【知识补充】</strong>：针对比赛中遇到的新知识点进行学习</li>
<li><strong>【反思策略】</strong>：评估时间分配和解题顺序是否合理</li>
</ol>
<h3 id="团队反思">团队反思</h3>
<p>团队赛后复盘：</p>
<ol>
<li><strong>【分工评估】</strong>：检视团队分工是否合理</li>
<li><strong>【沟通回顾】</strong>：审视沟通过程中的优点和问题</li>
<li><strong>【集体总结】</strong>：共同分析错过的题目，讨论可能的解法</li>
<li><strong>【战略优化】</strong>：根据表现调整未来比赛策略</li>
</ol>
<h3 id="持续改进">持续改进</h3>
<p>长期进步策略：</p>
<ol>
<li><strong>【建立题库】</strong>：收集有代表性的题目，定期复习</li>
<li><strong>【专题训练】</strong>：针对弱项进行集中训练</li>
<li><strong>【模拟比赛】</strong>：定期进行模拟比赛，锻炼实战能力</li>
<li><strong>【技术更新】</strong>：关注算法领域的新发展，不断学习新技巧</li>
</ol>
<h2 id="实战案例分析">实战案例分析</h2>
<h3 id="案例1：时间分配决策">案例1：时间分配决策</h3>
<p><strong>问题情境</strong>：一场5小时的比赛，10道题目，难度不一。</p>
<p><strong>决策过程</strong>：</p>
<ol>
<li>快速通读所有题目（15分钟）</li>
<li>解决3道简单题（1.5小时）</li>
<li>中等难度题目尝试（2小时）</li>
<li>选择1道较有把握的难题（1小时）</li>
<li>最后检查和优化（15分钟）</li>
</ol>
<p><strong>结果分析</strong>：</p>
<ul>
<li>优点：保证了基础分数，有针对性地挑战难题</li>
<li>不足：可能错过某些看似难但实际简单的题目</li>
<li>改进：可以更快地筛选题目，并灵活调整计划</li>
</ul>
<h3 id="案例2：调试难题">案例2：调试难题</h3>
<p><strong>问题情境</strong>：提交代码反复WA，但样例测试正确。</p>
<p><strong>处理过程</strong>：</p>
<ol>
<li>检查边界条件（找到最小/最大输入）</li>
<li>构造更多测试用例，包括临界值</li>
<li>添加详细调试输出，追踪变量变化</li>
<li>发现特殊情况未处理（数据为空）</li>
<li>修复并再次提交</li>
</ol>
<p><strong>经验总结</strong>：</p>
<ul>
<li>样例通过不代表程序正确</li>
<li>系统性构造测试用例的重要性</li>
<li>调试输出的有效使用方法</li>
</ul>
<h2 id="总结">总结</h2>
<p>成功参加算法竞赛不仅需要扎实的算法知识和编程能力，还需要有效的比赛策略和良好的心态。通过合理的赛前准备、科学的比赛策略、灵活的问题解决方法以及积极的心态管理，你可以在竞赛中发挥出最佳水平。</p>
<p>记住，竞赛经验是一种宝贵的财富，每一次比赛都是学习和成长的机会。持续总结和改进，你的竞赛能力将不断提升。祝你在算法竞赛的道路上取得优异成绩！</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="常见解题模板.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: 常见解题模板">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"CoderFAN 资料库 算法资料 实战练习指导","title":"算法比赛技巧","level":"1.2.3","depth":2,"previous":{"title":"常见解题模板","level":"1.2.2","depth":2,"path":"常见解题模板.md","ref":"常见解题模板.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*","description":"CoderFAN 资料库 算法资料 实战练习指导"},"file":{"path":"算法比赛技巧.md","mtime":"2025-05-12T03:21:13.271Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-12T03:23:27.983Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

