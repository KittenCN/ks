
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>常见解题模板 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="算法比赛技巧.html" />
    
    
    <link rel="prev" href="如何分析问题.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="实战练习概述.html">
            
                <a href="实战练习概述.html">
            
                    
                    实战练习指导
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="如何分析问题.html">
            
                <a href="如何分析问题.html">
            
                    
                    如何分析问题
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.2" data-path="常见解题模板.html">
            
                <a href="常见解题模板.html">
            
                    
                    常见解题模板
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="算法比赛技巧.html">
            
                <a href="算法比赛技巧.html">
            
                    
                    算法比赛技巧
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >常见解题模板</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="常见解题模板">常见解题模板</h1>
<h2 id="引言">引言</h2>
<p>在ACM竞赛中，掌握一些常用的解题模板可以大大提高编程效率和准确性。本文整理了竞赛中最常用的代码模板，涵盖了输入输出、基础算法、数据结构和特定问题类型等方面。这些模板可以作为你编写代码的起点，帮助你快速构建解决方案。</p>
<h2 id="基础输入输出模板">基础输入输出模板</h2>
<h3 id="标准输入输出加速">标准输入输出加速</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 关闭同步流，加速cin/cout</span>
ios::sync_with_stdio(<span class="hljs-literal">false</span>);
<span class="hljs-built_in">cin</span>.tie(<span class="hljs-literal">nullptr</span>);

<span class="hljs-comment">// 输入直到EOF</span>
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n) {
    <span class="hljs-comment">// 处理输入</span>
}

<span class="hljs-comment">// 输入指定数量的测试用例</span>
<span class="hljs-keyword">int</span> T;
<span class="hljs-built_in">cin</span> &gt;&gt; T;
<span class="hljs-keyword">while</span> (T--) {
    <span class="hljs-comment">// 处理每个测试用例</span>
}

<span class="hljs-comment">// 输入不定量的数据直到特定条件</span>
<span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &amp;&amp; n != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// 处理输入</span>
}
</code></pre>
<h3 id="快速读写（处理大量数据）">快速读写（处理大量数据）</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 快速读取整数</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">char</span> ch = getchar();
    <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">'0'</span> || ch &gt; <span class="hljs-string">'9'</span>) {
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'-'</span>) f = -<span class="hljs-number">1</span>;
        ch = getchar();
    }
    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">'0'</span> &amp;&amp; ch &lt;= <span class="hljs-string">'9'</span>) {
        x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">'0'</span>;
        ch = getchar();
    }
    <span class="hljs-keyword">return</span> x * f;
}

<span class="hljs-comment">// 快速输出整数</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'-'</span>);
        x = -x;
    }
    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">9</span>) write(x / <span class="hljs-number">10</span>);
    <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-string">'0'</span>);
}
</code></pre>
<h2 id="数据结构模板">数据结构模板</h2>
<h3 id="并查集">并查集</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 并查集基本模板</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> parent[MAXN];
<span class="hljs-keyword">int</span> rank_[MAXN];  <span class="hljs-comment">// 秩优化</span>

<span class="hljs-comment">// 初始化</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        parent[i] = i;
        rank_[i] = <span class="hljs-number">1</span>;
    }
}

<span class="hljs-comment">// 查找根节点（路径压缩）</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> parent[x] == x ? x : (parent[x] = find(parent[x]));
}

<span class="hljs-comment">// 合并集合（按秩合并）</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
    <span class="hljs-keyword">int</span> rootX = find(x);
    <span class="hljs-keyword">int</span> rootY = find(y);
    <span class="hljs-keyword">if</span> (rootX != rootY) {
        <span class="hljs-keyword">if</span> (rank_[rootX] &lt; rank_[rootY]) {
            parent[rootX] = rootY;
        } <span class="hljs-keyword">else</span> {
            parent[rootY] = rootX;
            <span class="hljs-keyword">if</span> (rank_[rootX] == rank_[rootY]) {
                rank_[rootX]++;
            }
        }
    }
}
</code></pre>
<h3 id="线段树（区间查询与修改）">线段树（区间查询与修改）</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 线段树基本模板</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> arr[MAXN];  <span class="hljs-comment">// 原始数组</span>
<span class="hljs-keyword">int</span> tree[MAXN * <span class="hljs-number">4</span>];  <span class="hljs-comment">// 线段树数组，大小通常为原数组的4倍</span>

<span class="hljs-comment">// 构建线段树</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
    <span class="hljs-keyword">if</span> (start == end) {
        tree[node] = arr[start];
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">int</span> mid = (start + end) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">int</span> leftNode = <span class="hljs-number">2</span> * node;
    <span class="hljs-keyword">int</span> rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>;

    build(leftNode, start, mid);
    build(rightNode, mid + <span class="hljs-number">1</span>, end);

    tree[node] = tree[leftNode] + tree[rightNode];  <span class="hljs-comment">// 根据需要修改操作（如求和、求最大等）</span>
}

<span class="hljs-comment">// 区间查询</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{
    <span class="hljs-comment">// 查询区间[l, r]</span>
    <span class="hljs-keyword">if</span> (r &lt; start || l &gt; end) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 查询区间与当前节点区间无交集</span>
    }
    <span class="hljs-keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) {
        <span class="hljs-keyword">return</span> tree[node];  <span class="hljs-comment">// 查询区间包含当前节点区间</span>
    }

    <span class="hljs-keyword">int</span> mid = (start + end) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">int</span> leftNode = <span class="hljs-number">2</span> * node;
    <span class="hljs-keyword">int</span> rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>;

    <span class="hljs-keyword">int</span> leftSum = query(leftNode, start, mid, l, r);
    <span class="hljs-keyword">int</span> rightSum = query(rightNode, mid + <span class="hljs-number">1</span>, end, l, r);

    <span class="hljs-keyword">return</span> leftSum + rightSum;  <span class="hljs-comment">// 根据需要修改操作</span>
}

<span class="hljs-comment">// 单点更新</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> val)</span> </span>{
    <span class="hljs-keyword">if</span> (start == end) {
        arr[idx] = val;
        tree[node] = val;
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">int</span> mid = (start + end) / <span class="hljs-number">2</span>;
    <span class="hljs-keyword">int</span> leftNode = <span class="hljs-number">2</span> * node;
    <span class="hljs-keyword">int</span> rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>;

    <span class="hljs-keyword">if</span> (idx &lt;= mid) {
        update(leftNode, start, mid, idx, val);
    } <span class="hljs-keyword">else</span> {
        update(rightNode, mid + <span class="hljs-number">1</span>, end, idx, val);
    }

    tree[node] = tree[leftNode] + tree[rightNode];  <span class="hljs-comment">// 根据需要修改操作</span>
}
</code></pre>
<h3 id="树状数组（区间查询与单点修改）">树状数组（区间查询与单点修改）</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 树状数组基本模板</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> bit[MAXN];

<span class="hljs-comment">// 获取最低位的1</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> x &amp; (-x);
}

<span class="hljs-comment">// 单点更新</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> val, <span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">while</span> (idx &lt;= n) {
        bit[idx] += val;
        idx += lowbit(idx);
    }
}

<span class="hljs-comment">// 前缀和查询</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>{
    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (idx &gt; <span class="hljs-number">0</span>) {
        sum += bit[idx];
        idx -= lowbit(idx);
    }
    <span class="hljs-keyword">return</span> sum;
}

<span class="hljs-comment">// 区间查询[l,r]</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rangeQuery</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{
    <span class="hljs-keyword">return</span> query(r) - query(l - <span class="hljs-number">1</span>);
}
</code></pre>
<h2 id="图论算法模板">图论算法模板</h2>
<h3 id="深度优先搜索-dfs">深度优先搜索 (DFS)</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// DFS模板</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; graph[MAXN];  <span class="hljs-comment">// 邻接表表示图</span>
<span class="hljs-keyword">bool</span> visited[MAXN];  <span class="hljs-comment">// 访问标记</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{
    visited[u] = <span class="hljs-literal">true</span>;
    <span class="hljs-comment">// 处理节点u</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : graph[u]) {
        <span class="hljs-keyword">if</span> (!visited[v]) {
            dfs(v);
        }
    }

    <span class="hljs-comment">// 如果需要，在这里处理回溯操作</span>
}
</code></pre>
<h3 id="广度优先搜索-bfs">广度优先搜索 (BFS)</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// BFS模板</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; graph[MAXN];  <span class="hljs-comment">// 邻接表表示图</span>
<span class="hljs-keyword">bool</span> visited[MAXN];  <span class="hljs-comment">// 访问标记</span>
<span class="hljs-keyword">int</span> dist[MAXN];  <span class="hljs-comment">// 距离数组，用于最短路等问题</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>{
    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; q;
    q.push(start);
    visited[start] = <span class="hljs-literal">true</span>;
    dist[start] = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (!q.empty()) {
        <span class="hljs-keyword">int</span> u = q.front();
        q.pop();

        <span class="hljs-comment">// 处理节点u</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : graph[u]) {
            <span class="hljs-keyword">if</span> (!visited[v]) {
                visited[v] = <span class="hljs-literal">true</span>;
                dist[v] = dist[u] + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 更新距离</span>
                q.push(v);
            }
        }
    }
}
</code></pre>
<h3 id="dijkstra算法（单源最短路）">Dijkstra算法（单源最短路）</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// Dijkstra算法（堆优化）</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;

<span class="hljs-keyword">struct</span> Edge {
    <span class="hljs-keyword">int</span> to, cost;
    Edge(<span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> c) : to(t), cost(c) {}
};

<span class="hljs-built_in">vector</span>&lt;Edge&gt; graph[MAXN];  <span class="hljs-comment">// 邻接表</span>
<span class="hljs-keyword">int</span> dist[MAXN];  <span class="hljs-comment">// 距离数组</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>{
    fill(dist, dist + MAXN, INF);
    dist[start] = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 使用优先队列优化，pair&lt;距离, 节点编号&gt;</span>
    priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, <span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;
    pq.push({<span class="hljs-number">0</span>, start});

    <span class="hljs-keyword">while</span> (!pq.empty()) {
        <span class="hljs-keyword">int</span> u = pq.top().second;
        <span class="hljs-keyword">int</span> d = pq.top().first;
        pq.pop();

        <span class="hljs-keyword">if</span> (d &gt; dist[u]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 已有更短的路径</span>

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : graph[u]) {
            <span class="hljs-keyword">int</span> v = edge.to;
            <span class="hljs-keyword">int</span> cost = edge.cost;

            <span class="hljs-keyword">if</span> (dist[u] + cost &lt; dist[v]) {
                dist[v] = dist[u] + cost;
                pq.push({dist[v], v});
            }
        }
    }
}
</code></pre>
<h3 id="bellman-ford算法（处理负权）">Bellman-Ford算法（处理负权）</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// Bellman-Ford算法</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;

<span class="hljs-keyword">struct</span> Edge {
    <span class="hljs-keyword">int</span> from, to, cost;
};

<span class="hljs-built_in">vector</span>&lt;Edge&gt; edges;  <span class="hljs-comment">// 边集合</span>
<span class="hljs-keyword">int</span> dist[MAXN];  <span class="hljs-comment">// 距离数组</span>

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bellmanFord</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> start)</span> </span>{
    fill(dist, dist + n + <span class="hljs-number">1</span>, INF);
    dist[start] = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 进行n-1轮松弛操作</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">bool</span> updated = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : edges) {
            <span class="hljs-keyword">if</span> (dist[edge.from] != INF &amp;&amp; dist[edge.from] + edge.cost &lt; dist[edge.to]) {
                dist[edge.to] = dist[edge.from] + edge.cost;
                updated = <span class="hljs-literal">true</span>;
            }
        }
        <span class="hljs-keyword">if</span> (!updated) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 如果本轮没有更新，提前退出</span>
    }

    <span class="hljs-comment">// 检测负权回路</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge : edges) {
        <span class="hljs-keyword">if</span> (dist[edge.from] != INF &amp;&amp; dist[edge.from] + edge.cost &lt; dist[edge.to]) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 存在负权回路</span>
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 不存在负权回路</span>
}
</code></pre>
<h3 id="floyd-warshall算法（多源最短路）">Floyd-Warshall算法（多源最短路）</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// Floyd-Warshall算法</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">500</span> + <span class="hljs-number">5</span>;  <span class="hljs-comment">// 节点数量限制更小</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;

<span class="hljs-keyword">int</span> dist[MAXN][MAXN];  <span class="hljs-comment">// 距离矩阵</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
            <span class="hljs-keyword">if</span> (i == j) dist[i][j] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dist[i][j] == <span class="hljs-number">0</span>) dist[i][j] = INF;  <span class="hljs-comment">// 如果没有直接边，设为无穷</span>
        }
    }

    <span class="hljs-comment">// Floyd算法主体</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) {
                <span class="hljs-keyword">if</span> (dist[i][k] != INF &amp;&amp; dist[k][j] != INF) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
    }
}
</code></pre>
<h3 id="kruskal算法（最小生成树）">Kruskal算法（最小生成树）</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// Kruskal算法（结合并查集）</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXM = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;

<span class="hljs-keyword">struct</span> Edge {
    <span class="hljs-keyword">int</span> u, v, cost;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Edge&amp; other) <span class="hljs-keyword">const</span> {
        <span class="hljs-keyword">return</span> cost &lt; other.cost;
    }
};

Edge edges[MAXM];  <span class="hljs-comment">// 边集合</span>
<span class="hljs-keyword">int</span> parent[MAXN];  <span class="hljs-comment">// 并查集</span>

<span class="hljs-comment">// 并查集查找</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-keyword">return</span> parent[x] == x ? x : (parent[x] = find(parent[x]));
}

<span class="hljs-comment">// 最小生成树 - Kruskal算法</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>{
    <span class="hljs-comment">// 初始化并查集</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        parent[i] = i;
    }

    <span class="hljs-comment">// 按边权排序</span>
    sort(edges, edges + m);

    <span class="hljs-keyword">int</span> totalCost = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 最小生成树的总权值</span>
    <span class="hljs-keyword">int</span> edgeCount = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 已选边数</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">int</span> rootU = find(edges[i].u);
        <span class="hljs-keyword">int</span> rootV = find(edges[i].v);

        <span class="hljs-keyword">if</span> (rootU != rootV) {  <span class="hljs-comment">// 不会形成环</span>
            parent[rootU] = rootV;  <span class="hljs-comment">// 合并集合</span>
            totalCost += edges[i].cost;
            edgeCount++;

            <span class="hljs-keyword">if</span> (edgeCount == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 已找到最小生成树</span>
        }
    }

    <span class="hljs-keyword">return</span> edgeCount == n - <span class="hljs-number">1</span> ? totalCost : -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果不能形成生成树，返回-1</span>
}
</code></pre>
<h2 id="动态规划模板">动态规划模板</h2>
<h3 id="背包问题模板">背包问题模板</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 01背包问题</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n, W;  <span class="hljs-comment">// n: 物品数量, W: 背包容量</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weights(n);  <span class="hljs-comment">// 物品重量</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; values(n);   <span class="hljs-comment">// 物品价值</span>

    <span class="hljs-comment">// dp[i]: 容量为i的背包能装的最大价值</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp(W + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-comment">// 逆序遍历确保物品只被选择一次</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = W; j &gt;= weights[i]; j--) {
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);
        }
    }
}

<span class="hljs-comment">// 完全背包问题</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unboundedKnapsack</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> n, W;  <span class="hljs-comment">// n: 物品数量, W: 背包容量</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; weights(n);  <span class="hljs-comment">// 物品重量</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; values(n);   <span class="hljs-comment">// 物品价值</span>

    <span class="hljs-comment">// dp[i]: 容量为i的背包能装的最大价值</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp(W + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-comment">// 正序遍历允许物品被重复选择</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = weights[i]; j &lt;= W; j++) {
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);
        }
    }
}
</code></pre>
<h3 id="最长公共子序列-lcs">最长公共子序列 (LCS)</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 最长公共子序列问题</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcs</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2)</span> </span>{
    <span class="hljs-keyword">int</span> n = s1.length();
    <span class="hljs-keyword">int</span> m = s2.length();

    <span class="hljs-comment">// dp[i][j]: s1[0...i-1]和s2[0...j-1]的最长公共子序列长度</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) {
            <span class="hljs-keyword">if</span> (s1[i-<span class="hljs-number">1</span>] == s2[j-<span class="hljs-number">1</span>]) {
                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;
            } <span class="hljs-keyword">else</span> {
                dp[i][j] = max(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]);
            }
        }
    }

    <span class="hljs-keyword">return</span> dp[n][m];
}
</code></pre>
<h3 id="最长递增子序列-lis">最长递增子序列 (LIS)</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 最长递增子序列问题 - O(n²)解法</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lis_n2</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">int</span> n = nums.size();
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// dp[i]: 以nums[i]结尾的最长递增子序列长度</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; dp(n, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) {
            <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) {
                dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>);
            }
        }
        result = max(result, dp[i]);
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 最长递增子序列问题 - O(nlogn)解法</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lis_nlogn</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">int</span> n = nums.size();
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// tails[i]: 长度为i+1的LIS的末尾元素的最小值</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tails;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) {
        <span class="hljs-comment">// 二分查找x应该插入的位置</span>
        <span class="hljs-keyword">auto</span> it = lower_bound(tails.begin(), tails.end(), x);

        <span class="hljs-keyword">if</span> (it == tails.end()) {
            tails.push_back(x);  <span class="hljs-comment">// x比所有尾部元素都大，新增一个长度</span>
        } <span class="hljs-keyword">else</span> {
            *it = x;  <span class="hljs-comment">// 更新长度为it-tails.begin()+1的LIS的末尾元素</span>
        }
    }

    <span class="hljs-keyword">return</span> tails.size();
}
</code></pre>
<h2 id="字符串算法模板">字符串算法模板</h2>
<h3 id="kmp算法">KMP算法</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// KMP算法</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; computeLPS(<span class="hljs-built_in">string</span> pattern) {
    <span class="hljs-keyword">int</span> m = pattern.length();
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; lps(m, <span class="hljs-number">0</span>);  <span class="hljs-comment">// Longest Proper Prefix which is also Suffix</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-number">0</span>; i &lt; m; ) {
        <span class="hljs-keyword">if</span> (pattern[i] == pattern[len]) {
            lps[i++] = ++len;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) {
            len = lps[len - <span class="hljs-number">1</span>];
        } <span class="hljs-keyword">else</span> {
            lps[i++] = <span class="hljs-number">0</span>;
        }
    }

    <span class="hljs-keyword">return</span> lps;
}

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; kmpSearch(<span class="hljs-built_in">string</span> text, <span class="hljs-built_in">string</span> pattern) {
    <span class="hljs-keyword">int</span> n = text.length();
    <span class="hljs-keyword">int</span> m = pattern.length();
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; lps = computeLPS(pattern);
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; matches;  <span class="hljs-comment">// 存储匹配位置</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; ) {
        <span class="hljs-keyword">if</span> (pattern[j] == text[i]) {
            i++; j++;
        }

        <span class="hljs-keyword">if</span> (j == m) {  <span class="hljs-comment">// 找到一个匹配</span>
            matches.push_back(i - j);
            j = lps[j - <span class="hljs-number">1</span>];
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; n &amp;&amp; pattern[j] != text[i]) {
            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) {
                j = lps[j - <span class="hljs-number">1</span>];
            } <span class="hljs-keyword">else</span> {
                i++;
            }
        }
    }

    <span class="hljs-keyword">return</span> matches;
}
</code></pre>
<h3 id="trie树（字典树）">Trie树（字典树）</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 字典树（Trie）</span>
<span class="hljs-keyword">struct</span> TrieNode {
    TrieNode* children[<span class="hljs-number">26</span>];  <span class="hljs-comment">// 假设只包含小写字母</span>
    <span class="hljs-keyword">bool</span> isEndOfWord;

    TrieNode() {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) {
            children[i] = <span class="hljs-literal">nullptr</span>;
        }
        isEndOfWord = <span class="hljs-literal">false</span>;
    }
};

<span class="hljs-keyword">class</span> Trie {
<span class="hljs-keyword">private</span>:
    TrieNode* root;

<span class="hljs-keyword">public</span>:
    Trie() {
        root = <span class="hljs-keyword">new</span> TrieNode();
    }

    <span class="hljs-comment">// 插入单词</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>{
        TrieNode* node = root;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word) {
            <span class="hljs-keyword">int</span> index = c - <span class="hljs-string">'a'</span>;
            <span class="hljs-keyword">if</span> (!node-&gt;children[index]) {
                node-&gt;children[index] = <span class="hljs-keyword">new</span> TrieNode();
            }
            node = node-&gt;children[index];
        }
        node-&gt;isEndOfWord = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-comment">// 查找单词</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-built_in">string</span> word)</span> </span>{
        TrieNode* node = root;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : word) {
            <span class="hljs-keyword">int</span> index = c - <span class="hljs-string">'a'</span>;
            <span class="hljs-keyword">if</span> (!node-&gt;children[index]) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            node = node-&gt;children[index];
        }
        <span class="hljs-keyword">return</span> node-&gt;isEndOfWord;
    }

    <span class="hljs-comment">// 查找是否有以prefix为前缀的单词</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(<span class="hljs-built_in">string</span> prefix)</span> </span>{
        TrieNode* node = root;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : prefix) {
            <span class="hljs-keyword">int</span> index = c - <span class="hljs-string">'a'</span>;
            <span class="hljs-keyword">if</span> (!node-&gt;children[index]) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
            node = node-&gt;children[index];
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
};
</code></pre>
<h2 id="数学模板">数学模板</h2>
<h3 id="最大公约数与最小公倍数">最大公约数与最小公倍数</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 最大公约数（辗转相除法）</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> b ? gcd(b, a % b) : a;
}

<span class="hljs-comment">// 最小公倍数</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> a / gcd(a, b) * b;  <span class="hljs-comment">// 避免a*b可能的溢出</span>
}
</code></pre>
<h3 id="快速幂">快速幂</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 快速幂（非递归实现）</span>
<span class="hljs-comment">// 计算 (base^exponent) % mod</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> exponent, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mod)</span> </span>{
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;
    base %= mod;

    <span class="hljs-keyword">while</span> (exponent &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (exponent &amp; <span class="hljs-number">1</span>) {
            result = (result * base) % mod;
        }
        exponent &gt;&gt;= <span class="hljs-number">1</span>;
        base = (base * base) % mod;
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h3 id="素数筛法">素数筛法</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 埃氏筛法</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; sieveOfEratosthenes(<span class="hljs-keyword">int</span> n) {
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; isPrime(n + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
    isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) {
        <span class="hljs-keyword">if</span> (isPrime[i]) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j += i) {
                isPrime[j] = <span class="hljs-literal">false</span>;
            }
        }
    }

    <span class="hljs-keyword">return</span> isPrime;
}

<span class="hljs-comment">// 线性筛法（欧拉筛）</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; linearSieve(<span class="hljs-keyword">int</span> n) {
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; isPrime(n + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; primes;
    isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">if</span> (isPrime[i]) {
            primes.push_back(i);
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; primes.size() &amp;&amp; i * primes[j] &lt;= n; j++) {
            isPrime[i * primes[j]] = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 核心优化</span>
        }
    }

    <span class="hljs-keyword">return</span> primes;
}
</code></pre>
<h3 id="组合数计算">组合数计算</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 组合数 C(n,k) % mod，使用逆元优化</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;

<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fact[MAXN];  <span class="hljs-comment">// 阶乘</span>
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> invFact[MAXN];  <span class="hljs-comment">// 阶乘的逆元</span>

<span class="hljs-comment">// 快速幂计算逆元</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x, <span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res = (res * x) % MOD;
        x = (x * x) % MOD;
        n &gt;&gt;= <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> res;
}

<span class="hljs-comment">// 预处理阶乘及其逆元</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">precompute</span><span class="hljs-params">()</span> </span>{
    fact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXN; i++) {
        fact[i] = (fact[i-<span class="hljs-number">1</span>] * i) % MOD;
    }

    <span class="hljs-comment">// 计算阶乘的逆元，invFact[n] = fact[n]^(MOD-2) % MOD</span>
    invFact[MAXN-<span class="hljs-number">1</span>] = quickPow(fact[MAXN-<span class="hljs-number">1</span>], MOD - <span class="hljs-number">2</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = MAXN - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        invFact[i] = (invFact[i+<span class="hljs-number">1</span>] * (i+<span class="hljs-number">1</span>)) % MOD;
    }
}

<span class="hljs-comment">// 计算组合数 C(n,k) % MOD</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>{
    <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span> || k &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> (((fact[n] * invFact[k]) % MOD) * invFact[n-k]) % MOD;
}
</code></pre>
<h2 id="完整程序模板">完整程序模板</h2>
<h3 id="基本框架">基本框架</h3>
<pre><code class="lang-cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// 常用类型别名</span>
<span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;
<span class="hljs-keyword">using</span> ull = <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;
<span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;;
<span class="hljs-keyword">using</span> vi = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;;
<span class="hljs-keyword">using</span> vll = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;;
<span class="hljs-keyword">using</span> vvi = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;;

<span class="hljs-comment">// 常用常量</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-keyword">const</span> ll LINF = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>LL;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> EPS = <span class="hljs-number">1e-9</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> PI = <span class="hljs-built_in">acos</span>(-<span class="hljs-number">1</span>);

<span class="hljs-comment">// 常用宏定义</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> sz(x) (int)(x).size()</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> pb push_back</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> mp make_pair</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> fi first</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> se second</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 在这里实现具体的解题逻辑</span>
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 关闭同步流，加速输入输出</span>
    ios::sync_with_stdio(<span class="hljs-literal">false</span>);
    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-literal">nullptr</span>);

    <span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span>;
    <span class="hljs-comment">// cin &gt;&gt; t;  // 如果有多个测试用例</span>
    <span class="hljs-keyword">while</span> (t--) {
        solve();
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h2 id="注意事项与使用建议">注意事项与使用建议</h2>
<ol>
<li><p><strong>模板适配</strong>：所提供的模板是通用的，在使用时需根据具体问题调整参数、条件和函数实现。</p>
</li>
<li><p><strong>变量命名</strong>：在实际比赛中，可以使用更简短的变量名以提高编码速度，但确保命名方式一致且清晰。</p>
</li>
<li><p><strong>边界检查</strong>：务必注意数组越界、整数溢出等问题，根据题目数据范围适当选择数据类型。</p>
</li>
<li><p><strong>调试技巧</strong>：在模板中添加自己的调试功能，如打印中间结果、检查特定条件等。</p>
</li>
<li><p><strong>个性化定制</strong>：随着编程经验的积累，不断调整和完善自己的模板库，使其更符合个人习惯。</p>
</li>
<li><p><strong>复制粘贴注意</strong>：使用模板时，小心调整索引起始（0-based vs 1-based）、符号和特殊条件。</p>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>本文提供了ACM竞赛中最常用的代码模板，覆盖了基础输入输出、数据结构、图论、动态规划、字符串处理和数学算法等多个方面。这些模板不仅可以提高你的编码效率，还能减少出错的可能性。建议你根据自己的需要和习惯，将这些模板整理成个人的代码库，以便在比赛中快速调用。</p>
<p>记住，模板只是工具，真正的解题能力来自于对算法思想的深刻理解和灵活运用。在比赛中，要根据具体问题选择合适的算法，并将模板与实际情况结合起来。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="如何分析问题.html" class="navigation navigation-prev " aria-label="Previous page: 如何分析问题">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="算法比赛技巧.html" class="navigation navigation-next " aria-label="Next page: 算法比赛技巧">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"常见解题模板","level":"1.2.2","depth":2,"next":{"title":"算法比赛技巧","level":"1.2.3","depth":2,"path":"算法比赛技巧.md","ref":"算法比赛技巧.md","articles":[]},"previous":{"title":"如何分析问题","level":"1.2.1","depth":2,"path":"如何分析问题.md","ref":"如何分析问题.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"常见解题模板.md","mtime":"2025-04-25T00:01:42.822Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-09T01:06:42.106Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

