
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>算法函数 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="ACM常用算法.html" />
    
    
    <link rel="prev" href="实战练习指导/实战练习概述.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    ACM算法指南
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="数据结构/基础数据结构.html">
            
                <a href="数据结构/基础数据结构.html">
            
                    
                    基础数据结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="搜索算法/搜索算法概述.html">
            
                <a href="搜索算法/搜索算法概述.html">
            
                    
                    搜索算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="图论算法/图论概述.html">
            
                <a href="图论算法/图论概述.html">
            
                    
                    图论算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="动态规划/动态规划概述.html">
            
                <a href="动态规划/动态规划概述.html">
            
                    
                    动态规划
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="字符串算法/字符串算法概述.html">
            
                <a href="字符串算法/字符串算法概述.html">
            
                    
                    字符串算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="数学算法/数学算法概述.html">
            
                <a href="数学算法/数学算法概述.html">
            
                    
                    数学算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="技巧与优化/技巧与优化概述.html">
            
                <a href="技巧与优化/技巧与优化概述.html">
            
                    
                    技巧与优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="实战练习指导/实战练习概述.html">
            
                <a href="实战练习指导/实战练习概述.html">
            
                    
                    实战练习指导
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.9" data-path="算法函数.html">
            
                <a href="算法函数.html">
            
                    
                    算法函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="ACM常用算法.html">
            
                <a href="ACM常用算法.html">
            
                    
                    ACM常用算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="STL常用函数.html">
            
                <a href="STL常用函数.html">
            
                    
                    STL常用函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="stl容器.html">
            
                <a href="stl容器.html">
            
                    
                    stl容器
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="string.html">
            
                <a href="string.html">
            
                    
                    string
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >算法函数</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="c-stl算法函数详解">C++ STL算法函数详解</h1>
<p>STL(Standard Template Library)中的算法函数是ACM竞赛中的利器，掌握它们可以大幅提高编码效率和程序性能。本文将详细介绍常用算法函数的使用方法、复杂度分析及实战应用。</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#排序相关算法">排序相关算法</a></li>
<li><a href="#查找相关算法">查找相关算法</a></li>
<li><a href="#数值操作算法">数值操作算法</a></li>
<li><a href="#集合操作算法">集合操作算法</a></li>
<li><a href="#修改序列算法">修改序列算法</a></li>
<li><a href="#排列组合算法">排列组合算法</a></li>
<li><a href="#堆操作算法">堆操作算法</a></li>
<li><a href="#其他实用算法">其他实用算法</a></li>
<li><a href="#acm竞赛中的应用技巧">ACM竞赛中的应用技巧</a></li>
</ul>
<h2 id="排序相关算法">排序相关算法</h2>
<h3 id="sort">sort</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 对[first, last)范围内的元素进行排序</span>
sort(first, last);
sort(first, last, comp);  <span class="hljs-comment">// 使用自定义比较函数</span>
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n log n) - 基于快速排序、堆排序和插入排序的混合优化算法</li>
<li><strong>空间复杂度</strong>: O(log n) - 用于递归调用栈</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>};
sort(v.begin(), v.end());  <span class="hljs-comment">// 升序排序: 1, 2, 3, 5, 7, 8</span>
sort(v.begin(), v.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());  <span class="hljs-comment">// 降序排序: 8, 7, 5, 3, 2, 1</span>

<span class="hljs-comment">// 自定义比较函数</span>
<span class="hljs-keyword">struct</span> Point { <span class="hljs-keyword">int</span> x, y; };
<span class="hljs-built_in">vector</span>&lt;Point&gt; points = { {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">3</span>, <span class="hljs-number">2</span>} };
sort(points.begin(), points.end(), [](<span class="hljs-keyword">const</span> Point&amp; a, <span class="hljs-keyword">const</span> Point&amp; b) {
    <span class="hljs-keyword">if</span> (a.x == b.x) <span class="hljs-keyword">return</span> a.y &lt; b.y;
    <span class="hljs-keyword">return</span> a.x &lt; b.x;
});  <span class="hljs-comment">// 先按x排序，x相同则按y排序</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>贪心算法的预处理</li>
<li>区间问题的预排序</li>
<li>用于优化搜索范围</li>
</ul>
<p><strong>易错点</strong>:</p>
<ul>
<li>自定义比较函数必须满足严格弱序关系（否则会产生未定义行为）</li>
<li>使用自定义比较时，要确保相等情况返回false</li>
</ul>
<h3 id="stablesort">stable_sort</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 稳定排序，保持相等元素的相对顺序</span>
stable_sort(first, last);
stable_sort(first, last, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: 如果有足够内存为O(n log n)，否则为O(n log² n)</li>
<li><strong>空间复杂度</strong>: 如果有足够内存为O(n)，否则为O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">struct</span> Student {
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> score;
};
<span class="hljs-built_in">vector</span>&lt;Student&gt; students = { {<span class="hljs-string">"Alice"</span>, <span class="hljs-number">85</span>}, {<span class="hljs-string">"Bob"</span>, <span class="hljs-number">90</span>}, {<span class="hljs-string">"Charlie"</span>, <span class="hljs-number">85</span>} };
stable_sort(students.begin(), students.end(), [](<span class="hljs-keyword">const</span> Student&amp; a, <span class="hljs-keyword">const</span> Student&amp; b) {
    <span class="hljs-keyword">return</span> a.score &gt; b.score;  <span class="hljs-comment">// 按分数降序，相同分数保持原顺序</span>
});
<span class="hljs-comment">// 结果: [{"Bob", 90}, {"Alice", 85}, {"Charlie", 85}]</span>
</code></pre>
<h3 id="partialsort">partial_sort</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将范围[first, middle)中的元素按顺序排列，剩余元素无序</span>
partial_sort(first, middle, last);
partial_sort(first, middle, last, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n log m)，其中n=(last-first)，m=(middle-first)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>};
<span class="hljs-comment">// 只排序前3个元素</span>
partial_sort(v.begin(), v.begin() + <span class="hljs-number">3</span>, v.end());
<span class="hljs-comment">// 结果: [1, 2, 3, ?, ?, ?, ?] (其中?为原数组中的其他元素，顺序不确定)</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【TopK问题】- 只需要找出最大/最小的K个元素</li>
</ul>
<h3 id="nthelement">nth_element</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 重排[first, last)，使得nth位置的元素是排序后应该在那个位置的元素</span>
<span class="hljs-comment">// 且保证nth之前的元素都不大于它，nth之后的元素都不小于它</span>
nth_element(first, nth, last);
nth_element(first, nth, last, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n) 平均情况</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>};
<span class="hljs-comment">// 找到中位数（第4个元素）</span>
nth_element(v.begin(), v.begin() + <span class="hljs-number">3</span>, v.end());
<span class="hljs-keyword">int</span> median = v[<span class="hljs-number">3</span>];  <span class="hljs-comment">// 现在v[3]就是中位数</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【快速查找】第K大/小的元素</li>
<li>【分治算法】在分区后找到划分点</li>
</ul>
<h2 id="查找相关算法">查找相关算法</h2>
<h3 id="binarysearch">binary_search</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 检查[first, last)中是否存在等于value的元素</span>
<span class="hljs-keyword">bool</span> exists = binary_search(first, last, value);
<span class="hljs-keyword">bool</span> exists = binary_search(first, last, value, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(log n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>};  <span class="hljs-comment">// 必须是有序集合</span>
<span class="hljs-keyword">bool</span> found = binary_search(v.begin(), v.end(), <span class="hljs-number">5</span>);  <span class="hljs-comment">// true</span>
found = binary_search(v.begin(), v.end(), <span class="hljs-number">4</span>);  <span class="hljs-comment">// false</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【二分查找】判断元素是否存在</li>
<li>【离散化】后的查询</li>
</ul>
<p><strong>易错点</strong>:</p>
<ul>
<li>【必须对有序数组使用】，否则结果未定义</li>
</ul>
<h3 id="lowerbound--upperbound">lower_bound / upper_bound</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// lower_bound: 返回指向&gt;=value的第一个元素的迭代器</span>
<span class="hljs-keyword">auto</span> it = lower_bound(first, last, value);
<span class="hljs-keyword">auto</span> it = lower_bound(first, last, value, comp);

<span class="hljs-comment">// upper_bound: 返回指向&gt;value的第一个元素的迭代器</span>
<span class="hljs-keyword">auto</span> it = upper_bound(first, last, value);
<span class="hljs-keyword">auto</span> it = upper_bound(first, last, value, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(log n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>};  <span class="hljs-comment">// 有序数组</span>
<span class="hljs-keyword">auto</span> it1 = lower_bound(v.begin(), v.end(), <span class="hljs-number">3</span>);  <span class="hljs-comment">// 指向第一个3</span>
<span class="hljs-keyword">auto</span> it2 = upper_bound(v.begin(), v.end(), <span class="hljs-number">3</span>);  <span class="hljs-comment">// 指向5</span>
<span class="hljs-keyword">int</span> count = it2 - it1;  <span class="hljs-comment">// 值为3的元素个数(3个)</span>

<span class="hljs-comment">// 求小于等于4的最大值</span>
<span class="hljs-keyword">auto</span> it3 = upper_bound(v.begin(), v.end(), <span class="hljs-number">4</span>);
<span class="hljs-keyword">int</span> result = *(it3 - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 结果为3</span>

<span class="hljs-comment">// 求大于等于4的最小值</span>
<span class="hljs-keyword">auto</span> it4 = lower_bound(v.begin(), v.end(), <span class="hljs-number">4</span>);
<span class="hljs-keyword">int</span> result2 = *it4;  <span class="hljs-comment">// 结果为5</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【二分答案】的实现</li>
<li>【离散化】操作</li>
<li>【区间查询】问题</li>
<li>【计数排序】代替map</li>
</ul>
<p><strong>易错点</strong>:</p>
<ul>
<li>返回迭代器可能指向end()，使用前需要检查</li>
<li>必须对有序容器使用</li>
</ul>
<h3 id="find--findif">find / find_if</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 查找等于value的第一个元素</span>
<span class="hljs-keyword">auto</span> it = find(first, last, value);

<span class="hljs-comment">// 查找满足谓词的第一个元素</span>
<span class="hljs-keyword">auto</span> it = find_if(first, last, pred);

<span class="hljs-comment">// 查找不满足谓词的第一个元素</span>
<span class="hljs-keyword">auto</span> it = find_if_not(first, last, pred);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>};
<span class="hljs-keyword">auto</span> it = find(v.begin(), v.end(), <span class="hljs-number">5</span>);  <span class="hljs-comment">// 指向5</span>
<span class="hljs-keyword">auto</span> it2 = find_if(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">6</span>; });  <span class="hljs-comment">// 指向7</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>无序数据中的元素查找</li>
<li>条件性搜索</li>
</ul>
<h2 id="数值操作算法">数值操作算法</h2>
<h3 id="accumulate">accumulate</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算[first, last)中所有元素的总和，init为初始值</span>
T sum = accumulate(first, last, init);
T sum = accumulate(first, last, init, op);  <span class="hljs-comment">// 使用自定义操作</span>
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-keyword">int</span> sum = accumulate(v.begin(), v.end(), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 15</span>
<span class="hljs-keyword">int</span> product = accumulate(v.begin(), v.end(), <span class="hljs-number">1</span>, multiplies&lt;<span class="hljs-keyword">int</span>&gt;());  <span class="hljs-comment">// 120</span>

<span class="hljs-comment">// 字符串连接</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; sv = {<span class="hljs-string">"Hello"</span>, <span class="hljs-string">" "</span>, <span class="hljs-string">"World"</span>};
<span class="hljs-built_in">string</span> result = accumulate(sv.begin(), sv.end(), <span class="hljs-built_in">string</span>(<span class="hljs-string">""</span>));  <span class="hljs-comment">// "Hello World"</span>

<span class="hljs-comment">// 自定义结构</span>
<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; points = { {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">6</span>} };
<span class="hljs-keyword">int</span> sum_x = accumulate(points.begin(), points.end(), <span class="hljs-number">0</span>, 
                       [](<span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; p) { <span class="hljs-keyword">return</span> sum + p.first; });  <span class="hljs-comment">// 9</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【求和】操作</li>
<li>【乘积】计算</li>
<li>通过自定义函数实现【复杂累积】操作</li>
</ul>
<h3 id="partialsum">partial_sum</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算前缀和并存储到result</span>
partial_sum(first, last, result);
partial_sum(first, last, result, op);  <span class="hljs-comment">// 使用自定义操作</span>
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; prefix_sum(v.size());
partial_sum(v.begin(), v.end(), prefix_sum.begin());
<span class="hljs-comment">// prefix_sum: [1, 3, 6, 10, 15]</span>

<span class="hljs-comment">// 前缀乘积</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; prefix_product(v.size());
partial_sum(v.begin(), v.end(), prefix_product.begin(), multiplies&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// prefix_product: [1, 2, 6, 24, 120]</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【前缀和】计算</li>
<li>【动态规划】中的状态转移</li>
</ul>
<h3 id="adjacentdifference">adjacent_difference</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算相邻元素差并存储到result</span>
adjacent_difference(first, last, result);
adjacent_difference(first, last, result, op);  <span class="hljs-comment">// 使用自定义操作</span>
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; diff(v.size());
adjacent_difference(v.begin(), v.end(), diff.begin());
<span class="hljs-comment">// diff: [1, 2, 3, 4, 5]</span>

<span class="hljs-comment">// 计算比值</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; ratio(v.size());
adjacent_difference(v.begin(), v.end(), ratio.begin(), [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) { 
    <span class="hljs-keyword">return</span> a / (<span class="hljs-keyword">double</span>)b; 
});
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【差分数组】构造</li>
<li>【变化率】计算</li>
</ul>
<h3 id="innerproduct">inner_product</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算两个序列的内积，init为初始值</span>
T result = inner_product(first1, last1, first2, init);
T result = inner_product(first1, last1, first2, init, op1, op2);  <span class="hljs-comment">// 自定义操作</span>
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>};
<span class="hljs-comment">// (1*4 + 2*5 + 3*6) + 0 = 32</span>
<span class="hljs-keyword">int</span> dot_product = inner_product(v1.begin(), v1.end(), v2.begin(), <span class="hljs-number">0</span>);

<span class="hljs-comment">// 计算向量距离的平方</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; p1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; p2 = {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>};
<span class="hljs-keyword">int</span> distance_sq = inner_product(p1.begin(), p1.end(), p2.begin(), <span class="hljs-number">0</span>,
                               plus&lt;<span class="hljs-keyword">int</span>&gt;(),  <span class="hljs-comment">// 外部运算</span>
                               [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) { <span class="hljs-keyword">return</span> (a - b) * (a - b); });  <span class="hljs-comment">// 内部运算</span>
<span class="hljs-comment">// (1-4)² + (2-5)² + (3-6)² = 27</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【向量内积】计算</li>
<li>【欧几里得距离】计算</li>
<li>【相似度】计算</li>
</ul>
<h2 id="集合操作算法">集合操作算法</h2>
<h3 id="setunion">set_union</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算两个有序集合的并集，结果存储在result</span>
<span class="hljs-keyword">auto</span> end_iter = set_union(first1, last1, first2, last2, result);
<span class="hljs-keyword">auto</span> end_iter = set_union(first1, last1, first2, last2, result, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n+m)</li>
<li><strong>空间复杂度</strong>: O(n+m)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v1.size() + v2.size());

<span class="hljs-keyword">auto</span> it = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());
result.resize(it - result.begin());
<span class="hljs-comment">// result: [1, 2, 3, 4, 5, 6, 7]</span>
</code></pre>
<h3 id="setintersection">set_intersection</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算两个有序集合的交集，结果存储在result</span>
<span class="hljs-keyword">auto</span> end_iter = set_intersection(first1, last1, first2, last2, result);
<span class="hljs-keyword">auto</span> end_iter = set_intersection(first1, last1, first2, last2, result, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n+m)</li>
<li><strong>空间复杂度</strong>: O(min(n,m))</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(min(v1.size(), v2.size()));

<span class="hljs-keyword">auto</span> it = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());
result.resize(it - result.begin());
<span class="hljs-comment">// result: [2, 7]</span>
</code></pre>
<h3 id="setdifference">set_difference</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算第一个集合相对第二个集合的差集，结果存储在result</span>
<span class="hljs-keyword">auto</span> end_iter = set_difference(first1, last1, first2, last2, result);
<span class="hljs-keyword">auto</span> end_iter = set_difference(first1, last1, first2, last2, result, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n+m)</li>
<li><strong>空间复杂度</strong>: O(n)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result(v1.size());

<span class="hljs-keyword">auto</span> it = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), result.begin());
result.resize(it - result.begin());
<span class="hljs-comment">// result: [1, 3, 5]</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【集合操作】实现</li>
<li>【离散化】后的区间合并</li>
</ul>
<h2 id="修改序列算法">修改序列算法</h2>
<h3 id="copy--copyif">copy / copy_if</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将[first, last)复制到result开始的位置</span>
<span class="hljs-keyword">auto</span> end_iter = copy(first, last, result);

<span class="hljs-comment">// 复制满足谓词条件的元素</span>
<span class="hljs-keyword">auto</span> end_iter = copy_if(first, last, result, pred);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2(v.size());
copy(v.begin(), v.end(), v2.begin());  <span class="hljs-comment">// v2: [1, 2, 3, 4, 5]</span>

<span class="hljs-comment">// 只复制偶数</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; even;
copy_if(v.begin(), v.end(), back_inserter(even), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; });
<span class="hljs-comment">// even: [2, 4]</span>
</code></pre>
<h3 id="transform">transform</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将[first, last)中的元素应用op操作后存入result</span>
transform(first, last, result, op);

<span class="hljs-comment">// 将两个范围[first1, last1)和从first2开始的范围应用binary_op后存入result</span>
transform(first1, last1, first2, result, binary_op);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; squares(v.size());
transform(v.begin(), v.end(), squares.begin(), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x * x; });
<span class="hljs-comment">// squares: [1, 4, 9, 16, 25]</span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; sums(v1.size());
transform(v1.begin(), v1.end(), v2.begin(), sums.begin(), plus&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-comment">// sums: [5, 7, 9]</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【向量运算】</li>
<li>【数据变换】</li>
<li>【自定义映射】</li>
</ul>
<h3 id="fill--filln">fill / fill_n</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 用value填充[first, last)</span>
fill(first, last, value);

<span class="hljs-comment">// 从first开始填充n个value</span>
fill_n(first, n, value);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v(<span class="hljs-number">5</span>);
fill(v.begin(), v.end(), <span class="hljs-number">10</span>);  <span class="hljs-comment">// v: [10, 10, 10, 10, 10]</span>

<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2(<span class="hljs-number">10</span>);
fill_n(v2.begin(), <span class="hljs-number">5</span>, <span class="hljs-number">20</span>);  <span class="hljs-comment">// v2: [20, 20, 20, 20, 20, 0, 0, 0, 0, 0]</span>
</code></pre>
<h3 id="replace--replaceif">replace / replace_if</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将[first, last)中的old_value替换为new_value</span>
replace(first, last, old_value, new_value);

<span class="hljs-comment">// 将[first, last)中满足谓词条件的元素替换为new_value</span>
replace_if(first, last, pred, new_value);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>};
replace(v.begin(), v.end(), <span class="hljs-number">2</span>, <span class="hljs-number">99</span>);  <span class="hljs-comment">// v: [1, 99, 3, 99, 5]</span>

replace_if(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">50</span>; }, <span class="hljs-number">0</span>);
<span class="hljs-comment">// v: [1, 0, 3, 0, 5]</span>
</code></pre>
<h3 id="unique--uniquecopy">unique / unique_copy</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 删除[first, last)中的连续重复元素（需要先排序）</span>
<span class="hljs-keyword">auto</span> end_iter = unique(first, last);

<span class="hljs-comment">// 复制不重复元素到result</span>
<span class="hljs-keyword">auto</span> end_iter = unique_copy(first, last, result);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1) 对于unique，O(n) 对于unique_copy</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>};
<span class="hljs-keyword">auto</span> it = unique(v.begin(), v.end());
v.erase(it, v.end());  <span class="hljs-comment">// v: [1, 2, 3, 4, 5]</span>

<span class="hljs-comment">// 不修改原数组</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; unique_v(v2.size());
<span class="hljs-keyword">auto</span> it2 = unique_copy(v2.begin(), v2.end(), unique_v.begin());
unique_v.resize(it2 - unique_v.begin());  <span class="hljs-comment">// unique_v: [1, 2, 3, 4]</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【去重】操作</li>
<li>【离散化】预处理</li>
</ul>
<p><strong>易错点</strong>:</p>
<ul>
<li>unique只移除连续重复元素，因此通常需要先排序</li>
<li>unique返回一个迭代器，指向不重复序列后的第一个位置，需要使用erase删除多余元素</li>
</ul>
<h3 id="rotate">rotate</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将[first, middle, last)旋转，使得middle成为序列的第一个元素</span>
<span class="hljs-keyword">auto</span> new_first = rotate(first, middle, last);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-comment">// 将3旋转到首位</span>
rotate(v.begin(), v.begin() + <span class="hljs-number">2</span>, v.end());  <span class="hljs-comment">// v: [3, 4, 5, 1, 2]</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【循环移位】操作</li>
<li>【排列组合】生成</li>
</ul>
<h3 id="reverse">reverse</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 反转[first, last)中的元素顺序</span>
reverse(first, last);

<span class="hljs-comment">// 反转并将结果保存到result</span>
reverse_copy(first, last, result);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1) 对于reverse，O(n) 对于reverse_copy</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
reverse(v.begin(), v.end());  <span class="hljs-comment">// v: [5, 4, 3, 2, 1]</span>

<span class="hljs-comment">// 不修改原数组</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; rev(v2.size());
reverse_copy(v2.begin(), v2.end(), rev.begin());  <span class="hljs-comment">// rev: [5, 4, 3, 2, 1]</span>
</code></pre>
<h2 id="排列组合算法">排列组合算法</h2>
<h3 id="nextpermutation--prevpermutation">next_permutation / prev_permutation</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 生成下一个字典序更大的排列，如果存在返回true，否则返回false</span>
<span class="hljs-keyword">bool</span> has_next = next_permutation(first, last);
<span class="hljs-keyword">bool</span> has_next = next_permutation(first, last, comp);

<span class="hljs-comment">// 生成上一个字典序更小的排列，如果存在返回true，否则返回false</span>
<span class="hljs-keyword">bool</span> has_prev = prev_permutation(first, last);
<span class="hljs-keyword">bool</span> has_prev = prev_permutation(first, last, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// 处理当前排列</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : v) <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
} <span class="hljs-keyword">while</span>(next_permutation(v.begin(), v.end()));
<span class="hljs-comment">/* 输出:
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
*/</span>

<span class="hljs-comment">// 从大到小生成排列</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>};  <span class="hljs-comment">// 注意：起始必须是最大排列</span>
<span class="hljs-keyword">do</span> {
    <span class="hljs-comment">// 处理当前排列</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : v2) <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
} <span class="hljs-keyword">while</span>(prev_permutation(v2.begin(), v2.end()));
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【排列枚举】</li>
<li>【状态搜索】</li>
<li>【组合优化】问题</li>
</ul>
<p><strong>易错点</strong>:</p>
<ul>
<li>使用next_permutation前，需要确保序列已按升序排序，否则无法生成所有排列</li>
<li>使用prev_permutation前，需要确保序列已按降序排序</li>
</ul>
<h2 id="堆操作算法">堆操作算法</h2>
<h3 id="makeheap--pushheap--popheap--sortheap">make_heap / push_heap / pop_heap / sort_heap</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 将[first, last)范围内的元素转换为一个堆</span>
make_heap(first, last);
make_heap(first, last, comp);

<span class="hljs-comment">// 将[first, last-1)已经是堆的情况下，将last-1位置的元素加入堆中</span>
push_heap(first, last);
push_heap(first, last, comp);

<span class="hljs-comment">// 将堆顶元素移到last-1位置，并将[first, last-1)调整为堆</span>
pop_heap(first, last);
pop_heap(first, last, comp);

<span class="hljs-comment">// 将一个堆转换为排序序列</span>
sort_heap(first, last);
sort_heap(first, last, comp);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>:<ul>
<li>make_heap: O(n)</li>
<li>push_heap: O(log n)</li>
<li>pop_heap: O(log n)</li>
<li>sort_heap: O(n log n)</li>
</ul>
</li>
<li><strong>空间复杂度</strong>: 均为O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>};

<span class="hljs-comment">// 创建堆（默认大顶堆）</span>
make_heap(v.begin(), v.end());  <span class="hljs-comment">// v: [9, 5, 4, 1, 1, 3]</span>

<span class="hljs-comment">// 添加元素</span>
v.push_back(<span class="hljs-number">6</span>);
push_heap(v.begin(), v.end());  <span class="hljs-comment">// v: [9, 5, 6, 1, 1, 3, 4]</span>

<span class="hljs-comment">// 移除最大元素</span>
pop_heap(v.begin(), v.end());  <span class="hljs-comment">// v: [6, 5, 4, 1, 1, 3, 9]</span>
<span class="hljs-keyword">int</span> max_val = v.back();  <span class="hljs-comment">// 9</span>
v.pop_back();

<span class="hljs-comment">// 堆排序</span>
sort_heap(v.begin(), v.end());  <span class="hljs-comment">// v: [1, 1, 3, 4, 5, 6]</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【优先队列】的手动实现</li>
<li>【TopK问题】</li>
<li>【多路归并】</li>
<li>【有序区间合并】</li>
</ul>
<p><strong>易错点</strong>:</p>
<ul>
<li>操作后需要手动维护容器大小（如pop_heap后需要pop_back）</li>
<li>STL默认实现的是大顶堆，如需小顶堆，需要自定义比较函数</li>
</ul>
<h2 id="其他实用算法">其他实用算法</h2>
<h3 id="min--max--minmax">min / max / minmax</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 返回两个值中的最小值/最大值/同时返回最小和最大值</span>
T min_val = min(a, b);
T max_val = max(a, b);
pair&lt;T, T&gt; minmax_val = minmax(a, b);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(1)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> min_val = min(a, b);  <span class="hljs-comment">// 5</span>
<span class="hljs-keyword">int</span> max_val = max(a, b);  <span class="hljs-comment">// 10</span>
<span class="hljs-keyword">auto</span> [m, M] = minmax(a, b);  <span class="hljs-comment">// m=5, M=10</span>
</code></pre>
<h3 id="minelement--maxelement--minmaxelement">min_element / max_element / minmax_element</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 返回指向[first, last)中最小/最大/最小和最大元素的迭代器</span>
<span class="hljs-keyword">auto</span> min_it = min_element(first, last);
<span class="hljs-keyword">auto</span> max_it = max_element(first, last);
<span class="hljs-keyword">auto</span> [min_it, max_it] = minmax_element(first, last);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>};
<span class="hljs-keyword">auto</span> min_it = min_element(v.begin(), v.end());  <span class="hljs-comment">// 指向第一个1</span>
<span class="hljs-keyword">auto</span> max_it = max_element(v.begin(), v.end());  <span class="hljs-comment">// 指向9</span>

<span class="hljs-keyword">int</span> min_val = *min_it;  <span class="hljs-comment">// 1</span>
<span class="hljs-keyword">int</span> min_pos = min_it - v.begin();  <span class="hljs-comment">// 1 (索引)</span>

<span class="hljs-keyword">auto</span> [min_itr, max_itr] = minmax_element(v.begin(), v.end());
<span class="hljs-comment">// *min_itr = 1, *max_itr = 9</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【区间最值】查询</li>
<li>【最优解】查找</li>
</ul>
<h3 id="allof--anyof--noneof">all_of / any_of / none_of</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 检查[first, last)中的所有/任一/没有元素是否满足pred条件</span>
<span class="hljs-keyword">bool</span> all = all_of(first, last, pred);
<span class="hljs-keyword">bool</span> any = any_of(first, last, pred);
<span class="hljs-keyword">bool</span> none = none_of(first, last, pred);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>};
<span class="hljs-keyword">bool</span> all_even = all_of(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; });  <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> any_gt_5 = any_of(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">5</span>; });  <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> none_neg = none_of(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span>; });  <span class="hljs-comment">// true</span>
</code></pre>
<h3 id="count--countif">count / count_if</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 计算[first, last)中等于value的元素个数</span>
<span class="hljs-keyword">int</span> cnt = count(first, last, value);

<span class="hljs-comment">// 计算[first, last)中满足pred的元素个数</span>
<span class="hljs-keyword">int</span> cnt = count_if(first, last, pred);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>};
<span class="hljs-keyword">int</span> count_2 = count(v.begin(), v.end(), <span class="hljs-number">2</span>);  <span class="hljs-comment">// 2</span>
<span class="hljs-keyword">int</span> count_gt_2 = count_if(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">2</span>; });  <span class="hljs-comment">// 7</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【频率统计】</li>
<li>【条件计数】</li>
</ul>
<h3 id="foreach">for_each</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 对[first, last)中的每个元素应用func操作</span>
for_each(first, last, func);
</code></pre>
<ul>
<li><strong>时间复杂度</strong>: O(n)</li>
<li><strong>空间复杂度</strong>: O(1)</li>
</ul>
<p><strong>使用示例</strong>:</p>
<pre><code class="lang-cpp"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};

<span class="hljs-comment">// 将所有元素加1</span>
for_each(v.begin(), v.end(), [](<span class="hljs-keyword">int</span>&amp; x) { x += <span class="hljs-number">1</span>; });  <span class="hljs-comment">// v: [2, 3, 4, 5, 6]</span>

<span class="hljs-comment">// 打印所有元素</span>
for_each(v.begin(), v.end(), [](<span class="hljs-keyword">int</span> x) { <span class="hljs-built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>; });  <span class="hljs-comment">// 输出: 2 3 4 5 6</span>
</code></pre>
<p><strong>ACM应用场景</strong>:</p>
<ul>
<li>【批量操作】</li>
<li>【语法简化】</li>
</ul>
<h2 id="acm竞赛中的应用技巧">ACM竞赛中的应用技巧</h2>
<h3 id="1-输入输出加速">1. 输入输出加速</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 常用输入输出优化</span>
ios::sync_with_stdio(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 取消同步</span>
<span class="hljs-built_in">cin</span>.tie(<span class="hljs-literal">nullptr</span>);             <span class="hljs-comment">// 解除cin与cout的绑定</span>
<span class="hljs-built_in">cout</span>.tie(<span class="hljs-literal">nullptr</span>);            <span class="hljs-comment">// 进一步加速</span>

<span class="hljs-comment">// 快读模板（适用于整数）</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">char</span> ch = getchar();
    <span class="hljs-keyword">while</span> (ch &lt; <span class="hljs-string">'0'</span> || ch &gt; <span class="hljs-string">'9'</span>) {
        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">'-'</span>) f = -<span class="hljs-number">1</span>;
        ch = getchar();
    }
    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">'0'</span> &amp;&amp; ch &lt;= <span class="hljs-string">'9'</span>) {
        x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">'0'</span>;
        ch = getchar();
    }
    <span class="hljs-keyword">return</span> x * f;
}
</code></pre>
<h3 id="2-算法函数组合应用">2. 算法函数组合应用</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 去重并统计不同元素</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>};
sort(v.begin(), v.end());
<span class="hljs-keyword">auto</span> it = unique(v.begin(), v.end());
<span class="hljs-keyword">int</span> unique_count = it - v.begin();  <span class="hljs-comment">// 5个不同元素</span>
v.resize(unique_count);  <span class="hljs-comment">// v: [1, 2, 3, 4, 5]</span>

<span class="hljs-comment">// 求第K大的元素（不改变原数组）</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v2 = {<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; temp = v2;
nth_element(temp.begin(), temp.begin() + <span class="hljs-number">2</span>, temp.end(), greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-keyword">int</span> third_largest = temp[<span class="hljs-number">2</span>];  <span class="hljs-comment">// 第3大的元素</span>

<span class="hljs-comment">// 区间操作：将[l,r]区间内的元素翻倍</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v3 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">3</span>;  <span class="hljs-comment">// 对应索引1-3的元素: 2,3,4</span>
transform(v3.begin() + l, v3.begin() + r + <span class="hljs-number">1</span>, v3.begin() + l, 
          [](<span class="hljs-keyword">int</span> x) { <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>; });  <span class="hljs-comment">// v3: [1, 4, 6, 8, 5]</span>

<span class="hljs-comment">// 检查一个数组是否为另一个数组的子集</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v4 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v5 = {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>};
sort(v4.begin(), v4.end());
sort(v5.begin(), v5.end());
<span class="hljs-keyword">bool</span> is_subset = includes(v4.begin(), v4.end(), v5.begin(), v5.end());  <span class="hljs-comment">// true</span>
</code></pre>
<h3 id="3-常见优化技巧">3. 常见优化技巧</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 预分配容器空间以避免频繁重分配</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v;
v.reserve(<span class="hljs-number">100000</span>);  <span class="hljs-comment">// 预分配空间</span>

<span class="hljs-comment">// 使用emplace_back代替push_back以避免额外的拷贝操作</span>
<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; pairs;
pairs.emplace_back(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 比 pairs.push_back({1, 2}) 更高效</span>

<span class="hljs-comment">// 使用引用避免不必要的拷贝</span>
for_each(v.begin(), v.end(), [](<span class="hljs-keyword">int</span>&amp; x) { x *= <span class="hljs-number">2</span>; });

<span class="hljs-comment">// 利用二分查找加速</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; v6 = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>};
<span class="hljs-comment">// 查找大于等于6的第一个元素</span>
<span class="hljs-keyword">auto</span> it = lower_bound(v6.begin(), v6.end(), <span class="hljs-number">6</span>);  <span class="hljs-comment">// 指向7</span>
</code></pre>
<h3 id="4-自定义比较函数技巧">4. 自定义比较函数技巧</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 多维度排序</span>
<span class="hljs-keyword">struct</span> Item {
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-keyword">int</span> priority;
    <span class="hljs-keyword">double</span> value;
};

<span class="hljs-built_in">vector</span>&lt;Item&gt; items = { {<span class="hljs-string">"A"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.5</span>}, {<span class="hljs-string">"B"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2.0</span>}, {<span class="hljs-string">"C"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1.5</span>} };
sort(items.begin(), items.end(), [](<span class="hljs-keyword">const</span> Item&amp; a, <span class="hljs-keyword">const</span> Item&amp; b) {
    <span class="hljs-keyword">if</span> (a.priority != b.priority) <span class="hljs-keyword">return</span> a.priority &lt; b.priority;  <span class="hljs-comment">// 首先按优先级升序</span>
    <span class="hljs-keyword">if</span> (a.value != b.value) <span class="hljs-keyword">return</span> a.value &gt; b.value;  <span class="hljs-comment">// 其次按价值降序</span>
    <span class="hljs-keyword">return</span> a.name &lt; b.name;  <span class="hljs-comment">// 最后按名称字典序</span>
});
</code></pre>
<hr></hr>
<p>通过系统掌握STL算法函数，可以大幅提高在ACM竞赛中的编码效率和问题解决能力。灵活运用这些工具可以让你的代码更简洁、更高效，从而在有限的比赛时间内解决更多的问题。</p>
<p>记住：选择合适的算法函数不仅能减少代码量，还能避免潜在的错误并提高程序的性能。在实际应用中，理解每个函数的时间复杂度和使用场景尤为重要。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="实战练习指导/实战练习概述.html" class="navigation navigation-prev " aria-label="Previous page: 实战练习指导">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="ACM常用算法.html" class="navigation navigation-next " aria-label="Next page: ACM常用算法">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"算法函数","level":"1.1.9","depth":2,"next":{"title":"ACM常用算法","level":"1.1.10","depth":2,"path":"ACM常用算法.md","ref":"ACM常用算法.md","articles":[]},"previous":{"title":"实战练习指导","level":"1.1.8","depth":2,"path":"实战练习指导/实战练习概述.md","ref":"实战练习指导/实战练习概述.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"算法函数.md","mtime":"2025-04-25T11:45:23.847Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:25:04.518Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

