
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>数学算法 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="素数筛法.html" />
    
    
    <link rel="prev" href="./" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2" data-path="数学算法概述.html">
            
                <a href="数学算法概述.html">
            
                    
                    数学算法
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="素数筛法.md">
            
                <span>
            
                    
                    素数筛法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="快速幂.html">
            
                <a href="快速幂.html">
            
                    
                    快速幂
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="最大公约数与最小公倍数.html">
            
                <a href="最大公约数与最小公倍数.html">
            
                    
                    最大公约数与最小公倍数
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >数学算法</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="数学算法概述">数学算法概述</h1>
<h2 id="什么是数学算法">什么是数学算法</h2>
<p>【数学算法】是基于数学理论和原理解决问题的算法，在算法竞赛中占有重要地位。这类算法通常涉及数论、组合数学、概率论、线性代数等数学分支，是解决特定问题的高效方法。</p>
<h2 id="为什么需要数学算法">为什么需要数学算法</h2>
<ol>
<li><strong>效率优势</strong>：数学算法通常能够提供比暴力方法更高效的解决方案</li>
<li><strong>问题转化</strong>：许多复杂问题可以转化为数学模型后更容易求解</li>
<li><strong>特殊性质利用</strong>：利用数学性质可以大幅简化问题求解过程</li>
</ol>
<h2 id="常见数学算法类型">常见数学算法类型</h2>
<h3 id="1-数论算法">1. 数论算法</h3>
<p>数论算法主要处理整数及其性质相关的问题。</p>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>质数(素数)</strong>：只有1和自身作为因子的大于1的整数</li>
<li><strong>最大公约数(GCD)</strong>：两个或多个整数共有的最大因子</li>
<li><strong>最小公倍数(LCM)</strong>：能被两个或多个整数整除的最小正整数</li>
<li><strong>模运算</strong>：处理取余后的结果，常用于大数计算</li>
</ul>
<h4 id="常用算法">常用算法</h4>
<ul>
<li><strong>素数筛法</strong>：高效地生成素数表</li>
<li><strong>欧几里得算法(辗转相除法)</strong>：计算最大公约数</li>
<li><strong>扩展欧几里得算法</strong>：求解线性丢番图方程</li>
<li><strong>快速幂</strong>：高效计算大数幂</li>
<li><strong>欧拉函数</strong>：计算小于n且与n互质的数的数量</li>
<li><strong>费马小定理与欧拉定理</strong>：用于模运算的简化</li>
</ul>
<h3 id="2-组合数学">2. 组合数学</h3>
<p>组合数学涉及计数问题和组合对象的研究。</p>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>排列(Permutation)</strong>：从n个不同元素中取出k个元素的有序排列数</li>
<li><strong>组合(Combination)</strong>：从n个不同元素中取出k个元素的无序组合数</li>
<li><strong>二项式系数</strong>：组合数学中的重要概念，表示从n个元素中选择k个的方法数</li>
</ul>
<h4 id="常用算法">常用算法</h4>
<ul>
<li><strong>组合数计算</strong>：计算C(n,k)的多种方法</li>
<li><strong>卡特兰数</strong>：解决多种计数问题</li>
<li><strong>斯特林数</strong>：与排列和组合相关的数列</li>
<li><strong>容斥原理</strong>：计算多个集合并集的大小</li>
</ul>
<h3 id="3-线性代数">3. 线性代数</h3>
<p>线性代数算法处理向量、矩阵和线性方程组相关的问题。</p>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>矩阵运算</strong>：加减乘、转置、求逆等</li>
<li><strong>行列式</strong>：方阵的一个标量值，与矩阵可逆性相关</li>
<li><strong>高斯消元</strong>：解线性方程组的方法</li>
</ul>
<h4 id="常用算法">常用算法</h4>
<ul>
<li><strong>矩阵快速幂</strong>：高效计算矩阵的幂</li>
<li><strong>高斯消元</strong>：解线性方程组</li>
<li><strong>行列式计算</strong>：计算方阵的行列式</li>
</ul>
<h3 id="4-概率与期望">4. 概率与期望</h3>
<p>概率算法处理随机事件和期望值的计算。</p>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>概率</strong>：事件发生的可能性</li>
<li><strong>期望值</strong>：随机变量的平均值</li>
<li><strong>方差与标准差</strong>：描述数据的离散程度</li>
</ul>
<h4 id="常用算法">常用算法</h4>
<ul>
<li><strong>期望值计算</strong>：根据概率分布计算随机变量的期望</li>
<li><strong>概率DP</strong>：结合动态规划解决概率问题</li>
</ul>
<h3 id="5-博弈论">5. 博弈论</h3>
<p>博弈论算法解决多方参与的策略选择问题。</p>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>零和游戏</strong>：一方的收益等于其他方的损失</li>
<li><strong>纳什均衡</strong>：没有参与者能通过单独改变策略获益的状态</li>
<li><strong>博弈状态</strong>：游戏中的一个局面</li>
</ul>
<h4 id="常用算法">常用算法</h4>
<ul>
<li><strong>极小极大算法</strong>：在零和游戏中寻找最优策略</li>
<li><strong>SG函数</strong>：解决公平组合游戏(Nim游戏)</li>
<li><strong>Alpha-Beta剪枝</strong>：优化极小极大搜索</li>
</ul>
<h2 id="数学算法的实现技巧">数学算法的实现技巧</h2>
<h3 id="1-大数运算">1. 大数运算</h3>
<p>在处理超过语言内置类型范围的数时，需要特殊处理。</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// 大整数加法示例</span>
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">addStrings</span><span class="hljs-params">(<span class="hljs-built_in">string</span> num1, <span class="hljs-built_in">string</span> num2)</span> </span>{
    <span class="hljs-built_in">string</span> result = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> i = num1.length() - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> j = num2.length() - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">int</span> sum = carry;
        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) sum += (num1[i--] - <span class="hljs-string">'0'</span>);
        <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span>) sum += (num2[j--] - <span class="hljs-string">'0'</span>);

        carry = sum / <span class="hljs-number">10</span>;
        result = to_string(sum % <span class="hljs-number">10</span>) + result;
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h3 id="2-模运算处理">2. 模运算处理</h3>
<p>模运算在大数计算、同余问题中经常使用。</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// 模运算下的加法、乘法、幂运算</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;

<span class="hljs-comment">// 模运算下的加法</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addMod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> (a + b) % MOD;
}

<span class="hljs-comment">// 模运算下的乘法</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mulMod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">1L</span>L * a * b) % MOD;  <span class="hljs-comment">// 使用long long避免溢出</span>
}

<span class="hljs-comment">// 模运算下的快速幂</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">powMod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>{
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;
    base %= MOD;

    <span class="hljs-keyword">while</span> (exponent &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (exponent &amp; <span class="hljs-number">1</span>) {
            result = mulMod(result, base);
        }
        exponent &gt;&gt;= <span class="hljs-number">1</span>;
        base = mulMod(base, base);
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h3 id="3-高精度计算">3. 高精度计算</h3>
<p>某些问题要求高精度计算，需要特殊处理浮点数误差。</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// 高精度计算示例 - 二分法求平方根</span>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> epsilon = <span class="hljs-number">1e-9</span>)</span> </span>{
    <span class="hljs-keyword">double</span> low = <span class="hljs-number">0</span>, high = max(<span class="hljs-number">1.0</span>, x);

    <span class="hljs-keyword">while</span> (high - low &gt; epsilon) {
        <span class="hljs-keyword">double</span> mid = low + (high - low) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (mid * mid &gt; x) {
            high = mid;
        } <span class="hljs-keyword">else</span> {
            low = mid;
        }
    }

    <span class="hljs-keyword">return</span> low;
}
</code></pre>
<h2 id="典型例题分析">典型例题分析</h2>
<h3 id="例题1：素数筛法">例题1：素数筛法</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 埃氏筛法求素数</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; sieveOfEratosthenes(<span class="hljs-keyword">int</span> n) {
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; isPrime(n+<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
    isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 0和1不是素数</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) {
        <span class="hljs-keyword">if</span> (isPrime[i]) {
            <span class="hljs-comment">// 将i的所有倍数标记为非素数</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j += i) {
                isPrime[j] = <span class="hljs-literal">false</span>;
            }
        }
    }

    <span class="hljs-keyword">return</span> isPrime;
}

<span class="hljs-comment">// 线性筛法(欧拉筛)求素数</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; linearSieve(<span class="hljs-keyword">int</span> n) {
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; isPrime(n+<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; primes;
    isPrime[<span class="hljs-number">0</span>] = isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) {
        <span class="hljs-keyword">if</span> (isPrime[i]) {
            primes.push_back(i);
        }

        <span class="hljs-comment">// 用已知的素数去筛</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; primes.size() &amp;&amp; i * primes[j] &lt;= n; j++) {
            isPrime[i * primes[j]] = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 保证每个合数只被其最小质因子筛掉</span>
        }
    }

    <span class="hljs-keyword">return</span> primes;
}
</code></pre>
<h3 id="例题2：快速幂">例题2：快速幂</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 二分快速幂</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fastPow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> exponent)</span> </span>{
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (exponent &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (exponent &amp; <span class="hljs-number">1</span>) {  <span class="hljs-comment">// 如果指数为奇数</span>
            result *= base;
        }

        base *= base;  <span class="hljs-comment">// 底数平方</span>
        exponent &gt;&gt;= <span class="hljs-number">1</span>;  <span class="hljs-comment">// 指数除以2</span>
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 模运算下的快速幂</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">fastPowMod</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> base, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> exponent, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mod)</span> </span>{
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> result = <span class="hljs-number">1</span>;
    base %= mod;

    <span class="hljs-keyword">while</span> (exponent &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (exponent &amp; <span class="hljs-number">1</span>) {
            result = (result * base) % mod;
        }

        base = (base * base) % mod;
        exponent &gt;&gt;= <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h3 id="例题3：组合数计算">例题3：组合数计算</h3>
<pre><code class="lang-cpp"><span class="hljs-comment">// 动态规划法计算组合数</span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; generateCombinations(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>) {
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; C(n+<span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>));

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
        C[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 从i个元素中选0个的方法数为1</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) {
            <span class="hljs-comment">// C(i,j) = C(i-1,j-1) + C(i-1,j)</span>
            C[i][j] = (C[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + C[i-<span class="hljs-number">1</span>][j]) % mod;
        }
    }

    <span class="hljs-keyword">return</span> C;
}

<span class="hljs-comment">// 逆元法计算大组合数（适用于mod为质数的情况）</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">combination</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> mod)</span> </span>{
    <span class="hljs-keyword">if</span> (k &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || k == n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

    <span class="hljs-comment">// 计算阶乘及其逆元</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt; fact(n+<span class="hljs-number">1</span>), invFact(n+<span class="hljs-number">1</span>);
    fact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
        fact[i] = (fact[i-<span class="hljs-number">1</span>] * i) % mod;
    }

    <span class="hljs-comment">// 费马小定理: a^(p-1) ≡ 1 (mod p) =&gt; a^(p-2) ≡ a^(-1) (mod p)</span>
    invFact[n] = fastPowMod(fact[n], mod - <span class="hljs-number">2</span>, mod);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        invFact[i] = (invFact[i+<span class="hljs-number">1</span>] * (i+<span class="hljs-number">1</span>)) % mod;
    }

    <span class="hljs-comment">// C(n,k) = n! / (k! * (n-k)!)</span>
    <span class="hljs-keyword">return</span> (fact[n] * ((invFact[k] * invFact[n-k]) % mod)) % mod;
}
</code></pre>
<h2 id="常见错误和注意事项">常见错误和注意事项</h2>
<ol>
<li><p><strong>整数溢出</strong>：</p>
<ul>
<li>计算过程中注意潜在的整数溢出问题</li>
<li>使用适当的数据类型(如long long)</li>
<li>适时进行模运算降低数值</li>
</ul>
</li>
<li><p><strong>浮点数精度</strong>：</p>
<ul>
<li>浮点数计算存在精度误差</li>
<li>避免直接比较两个浮点数是否相等</li>
<li>使用epsilon值进行近似比较</li>
</ul>
</li>
<li><p><strong>边界情况</strong>：</p>
<ul>
<li>处理特殊输入(如0, 1, 极限值等)</li>
<li>考虑算法适用范围</li>
</ul>
</li>
<li><p><strong>模运算性质</strong>：</p>
<ul>
<li>加法和乘法满足分配律:(a + b) % m = ((a % m) + (b % m)) % m</li>
<li>但除法需要特殊处理:(a / b) % m ≠ ((a % m) / (b % m)) % m</li>
</ul>
</li>
<li><p><strong>运算优先级</strong>：</p>
<ul>
<li>注意位运算和其他运算的优先级</li>
<li>使用括号确保运算顺序正确</li>
</ul>
</li>
</ol>
<h2 id="练习题推荐">练习题推荐</h2>
<ol>
<li><p><strong>数论基础</strong>：</p>
<ul>
<li><a href="http://poj.org/problem?id=1006" target="_blank">POJ 1006 - Biorhythms</a> (中国剩余定理)</li>
<li><a href="https://leetcode.com/problems/count-primes/" target="_blank">LeetCode 204 - Count Primes</a> (素数计数)</li>
</ul>
</li>
<li><p><strong>快速幂</strong>：</p>
<ul>
<li><a href="http://poj.org/problem?id=1995" target="_blank">POJ 1995 - Raising Modulo Numbers</a> (模幂运算)</li>
<li><a href="https://leetcode.com/problems/powx-n/" target="_blank">LeetCode 50 - Pow(x, n)</a> (快速幂实现)</li>
</ul>
</li>
<li><p><strong>组合数学</strong>：</p>
<ul>
<li><a href="http://poj.org/problem?id=2249" target="_blank">POJ 2249 - Binomial Showdown</a> (组合数计算)</li>
<li><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank">LeetCode 96 - Unique Binary Search Trees</a> (卡特兰数应用)</li>
</ul>
</li>
<li><p><strong>博弈论</strong>：</p>
<ul>
<li><a href="http://poj.org/problem?id=2068" target="_blank">POJ 2068 - Nim</a> (Nim游戏)</li>
<li><a href="http://poj.org/problem?id=1704" target="_blank">POJ 1704 - Georgia and Bob</a> (博弈策略)</li>
</ul>
</li>
<li><p><strong>线性代数</strong>：</p>
<ul>
<li><a href="http://poj.org/problem?id=3070" target="_blank">POJ 3070 - Fibonacci</a> (矩阵快速幂)</li>
<li><a href="http://poj.org/problem?id=1222" target="_blank">POJ 1222 - EXTENDED LIGHTS OUT</a> (高斯消元)</li>
</ul>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>数学算法在算法竞赛中扮演着重要角色，掌握这些算法不仅能够提高解题效率，还能帮助我们更深入地理解问题的本质。通过学习数论、组合数学、线性代数等基本理论，以及相应的算法实现，我们能够解决更广泛的问题类型。</p>
<p>在学习数学算法的过程中，理解基本原理比记忆公式更重要。通过大量练习不同类型的问题，逐步建立数学直觉，是提高解题能力的关键。在接下来的章节中，我们将更深入地探讨各种数学算法的应用场景和实现技巧。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Introduction">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="素数筛法.html" class="navigation navigation-next " aria-label="Next page: 素数筛法">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"数学算法","level":"1.2","depth":1,"next":{"title":"素数筛法","level":"1.2.1","depth":2,"path":"素数筛法.md","ref":"素数筛法.md","articles":[]},"previous":{"title":"Introduction","level":"1.1","depth":1,"path":"README.md","ref":"README.md","articles":[]},"articles":[{"title":"素数筛法","level":"1.2.1","depth":2,"path":"素数筛法.md","ref":"素数筛法.md","articles":[]},{"title":"快速幂","level":"1.2.2","depth":2,"path":"快速幂.md","ref":"快速幂.md","articles":[]},{"title":"最大公约数与最小公倍数","level":"1.2.3","depth":2,"path":"最大公约数与最小公倍数.md","ref":"最大公约数与最小公倍数.md","articles":[]}],"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"数学算法概述.md","mtime":"2025-04-08T05:26:02.000Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:25:37.547Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

