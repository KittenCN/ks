
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>九、基于智能体的模型 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="10.html" />
    
    
    <link rel="prev" href="8.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    复杂性思维
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="1.html">
            
                <a href="1.html">
            
                    
                    一、复杂性科学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="2.html">
            
                <a href="2.html">
            
                    
                    二、图
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="3.html">
            
                <a href="3.html">
            
                    
                    三、小世界图
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="4.html">
            
                <a href="4.html">
            
                    
                    四、无标度网络
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="5.html">
            
                <a href="5.html">
            
                    
                    五、细胞自动机
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="6.html">
            
                <a href="6.html">
            
                    
                    六、生命游戏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="7.html">
            
                <a href="7.html">
            
                    
                    七、物理建模
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="8.html">
            
                <a href="8.html">
            
                    
                    八、自组织临界
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.9" data-path="9.html">
            
                <a href="9.html">
            
                    
                    九、基于智能体的模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="10.html">
            
                <a href="10.html">
            
                    
                    十、兽群、鸟群和交通堵塞
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="11.html">
            
                <a href="11.html">
            
                    
                    十一、进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="12.html">
            
                <a href="12.html">
            
                    
                    十二、合作进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="a.html">
            
                <a href="a.html">
            
                    
                    附录 A、算法分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="b.html">
            
                <a href="b.html">
            
                    
                    附录 B、阅读列表
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >九、基于智能体的模型</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="九、基于智能体的模型">九、基于智能体的模型</h1>
<blockquote>
<p>原文：<a href="http://greenteapress.com/complexity2/html/thinkcomplexity2010.html" target="_blank">Chapter 9  Agent-based models</a></p>
<p>译者：<a href="https://github.com/wizardforcel" target="_blank">飞龙</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/" target="_blank">谷歌翻译</a></p>
</blockquote>
<p>我们迄今为止看到的模型可能具有“基于规则”的特征，因为它们涉及受简单规则支配的系统。 在本章和以后的章节中，我们将探索基于智能体（agent）的模型。</p>
<p>基于智能体的模型包含智能体，它旨在模拟人和其他实体，它们收集世界的信息，制定决策并采取行动。</p>
<p>智能体通常位于空间或网络中，并在本地彼此交互。 他们通常有不完整的，不全面的世界信息。</p>
<p>智能体之间经常存在差异，而不像以前的所有模型，它们的所有成分都相同。 基于智能体的模型通常包含智能体之间，或世界中的随机性。</p>
<p>自 20 世纪 70 年代以来，基于智能体的模型已成为经济学和其他社会科学，以及一些自然科学中的重要工具。</p>
<p>基于智能体的模型对非均衡系统的动态建模（尽管它们也用于研究均衡系统）非常有用。 它们对于理解个人决策和系统行为之间的关系特别有用。</p>
<p>本章的代码位于<code>chap09.ipynb</code>中，它是本书仓库中的 Jupyter 笔记本。 使用此代码的更多信息，请参见第？节。</p>
<h2 id="91-谢林模型">9.1 谢林模型</h2>
<p>1971 年，托马斯谢（Thomas Schelling）发表了《隔离的动态模型》（Dynamic Models of Segregation），该模型提出了种族隔离的简单模型。 谢林模型的世界是一个网格；每个细胞代表一栋房子。 房屋被两种智能体占用，标记为红色和蓝色，数量大致相同。 大约 10% 的房屋是空的。</p>
<p>在任何时候，智能体可能会高兴或不高兴，这取决于领域中的其他智能体，每个房屋的“邻居”是八个相邻细胞的集合。在一个版本的模型中，如果智能体至少有两个像他们一样的邻居，智能体会高兴，但如果是一个或零，他们就会不高兴。</p>
<p>模拟的过程是，随机选择一个智能体并检查他们是否高兴。 如果是这样，没有任何事情发生。如果不是，智能体随机选择其中一个未占用的细胞并移动。</p>
<p>听到这种模型导致一些隔离，你可能不会感到惊讶，但是你可能会对这个程度感到惊讶。 很快，会出现相似智能体的群落。 随着时间的推移，这些群落会不断聚合，直到有少量的大型群落，并且大多数智能体生活在同质社区中。</p>
<p>如果你不知道这个过程，只看到结果，你可能会认为智能体是种族主义者，但实际上他们都会在一个混合的社区感到非常高兴。 由于他们不愿意数量过大，所以在最坏的情况下，他们可能被认为是排外的。 当然，这些智能体是真实人物的过度简化，所以这些描述可能根本不恰当。</p>
<p>种族主义是一个复杂的人类问题; 很难想象这样简单的模型可以揭示它。 但实际上，它提供了一个强有力论据，有关系统及其各部分之间关系的：如果你观察真实城市的隔离，你不能总结为，个人的种族主义是直接原因，或者，城市居民是种族主义者。</p>
<p>当然，我们必须牢记这个论述的局限性：谢林模型证明了隔离的一个可能原因，但没有提到实际原因。</p>
<h2 id="92-谢林模型的实现">9.2 谢林模型的实现</h2>
<p>为了实现谢林模型，我编写了另一个继承<code>Cell2D</code>的类：</p>
<pre><code class="lang-py">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Schelling</span><span class="hljs-params">(Cell2D)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n, m=None, p=<span class="hljs-number">0.5</span>)</span>:</span>
        self.p = p
        m = n <span class="hljs-keyword">if</span> m <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> m
        choices = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
        probs = [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.45</span>, <span class="hljs-number">0.45</span>]
        self.array = np.random.choice(choices, (n, m), p=probs)
</code></pre>
<p>参数<code>n</code>和<code>m</code>是网格的维度，<code>p</code>是相似邻居比例的阈值。 例如，如果<code>p = 0.5</code>，也就是其邻居中少于 50% 为相同颜色，则智能体将不高兴。</p>
<p><code>array</code>是 NumPy 数组，其中每个细胞如果为空，则为 0；如果由红色智能体占用，则为1；如果由蓝色智能体占用，则为 2。 最初，10% 的细胞是空的，45% 为红色和 45% 为蓝色。</p>
<p>谢林模型的<code>step</code>函数比以前的<code>step</code>函数复杂得多。 如果你对细节不感兴趣，你可以跳到下一节。 但是如果你坚持要看，你可能需要一些 NumPy 的提示。</p>
<p>首先，我将生成逻辑数组，表明哪些细胞是红色，蓝色和占用的：</p>
<pre><code class="lang-py">
a = self.array
red = a==<span class="hljs-number">1</span>
blue = a==<span class="hljs-number">2</span>
occupied = a!=<span class="hljs-number">0</span>
</code></pre>
<p>我将使用<code>np.correlate2d</code>来计算，对于每个细胞，红色相邻细胞的数量和被占用的细胞数量。</p>
<pre><code class="lang-py">options = dict(mode=<span class="hljs-string">'same'</span>, boundary=<span class="hljs-string">'wrap'</span>)

kernel = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
                   [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
                   [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]], dtype=np.int8)

num_red = correlate2d(red, kernel, **options)
num_neighbors = correlate2d(occupied, kernel, **options)
</code></pre>
<p>现在对于每个细胞，我们可以计算出红色的邻居比例和相同颜色的比例：</p>
<pre><code class="lang-py">
frac_red = num_red / num_neighbors
frac_blue = <span class="hljs-number">1</span> - frac_red
frac_same = np.where(red, frac_red, frac_blue)
</code></pre>
<p><code>frac_red</code>只是<code>num_red</code>和<code>num_neighbors</code>的比率，而<code>frac_blue</code>是<code>frac_red</code>的补。</p>
<p><code>frac_same</code>有点复杂。 函数<code>np.where</code>就像逐元素的<code>if</code>表达式一样。 第一个参数是从第二个或第三个参数中选择元素的条件。</p>
<p>在这种情况下，如果<code>red</code>为<code>True</code>，<code>frac_same</code>获取<code>frac_red</code>的相应元素。 在红色为<code>False</code>的情况下，<code>frac_same</code>获取<code>frac_blue</code>的相应元素。</p>
<p>现在我们可以确定不满意的智能体的位置：</p>
<pre><code class="lang-py">unhappy_locs = locs_where(occupied &amp; (frac_same &lt; self.p))
</code></pre>
<p>结果<code>unhappy_locs</code>是一个 NumPy 数组，其中每行都是占用的细胞的坐标，其中<code>frac_same</code>低于阈值<code>p</code>。</p>
<p><code>locs_where</code>是<code>np.nonzero</code>的包装函数：</p>
<pre><code class="lang-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">locs_where</span><span class="hljs-params">(condition)</span>:</span>
    <span class="hljs-keyword">return</span> np.transpose(np.nonzero(condition))
</code></pre>
<p><code>np.nonzero</code>接受一个数组并返回所有非零元素的坐标，但结果是两个元组的形式。 <code>np.transpose</code>将结果转换为更有用的形式，即每行都是坐标对的数组。</p>
<p>同样，<code>empty_locs</code>是一个数组，包含空细胞的坐标：</p>
<pre><code class="lang-py">empty_locs = locs_where(a==<span class="hljs-number">0</span>)
</code></pre>
<p>现在我们到达了模拟的核心。 我们遍历不高兴的智能体并移动它们：</p>
<pre><code class="lang-py"><span class="hljs-keyword">for</span> source <span class="hljs-keyword">in</span> unhappy_locs:
    i = np.random.randint(len(empty_locs))
    dest = tuple(empty_locs[i])
    a[dest] = a[tuple(source)]
    a[tuple(source)] = <span class="hljs-number">0</span>
    empty_locs[i] = source
</code></pre>
<p><code>i</code>是一个用来随机选择空细胞的索引。</p>
<p><code>dest</code>是一个包含空细胞的坐标的元组。</p>
<p>为了移动智能体，我们将值从<code>source</code>复制到<code>dest</code>，然后将<code>source</code>的值设置为 0（因为它现在是空的）。</p>
<p>最后，我们用<code>source</code>替换<code>empty_locs</code>中的条目，以便刚刚变为空的细胞可以由下一个智能体选择。</p>
<h2 id="93-隔离">9.3 隔离</h2>
<p><img src="img/9-1.png" alt=""></img></p>
<p>图 9.1：谢林的隔离模型，<code>n = 100</code>，初始条件（左），2 步后（中）和 10 步后（右）</p>
<p>现在让我们看看我们运行模型时会发生什么。 我将以<code>n = 100</code>和<code>p = 0.3</code>开始，并运行 10 个步骤。</p>
<pre><code class="lang-py">grid = Schelling(n=<span class="hljs-number">100</span>, p=<span class="hljs-number">0.3</span>)
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
    grid.step()
</code></pre>
<p>图？展示了初始状态（左），2 步（中）后和 10 步（右）后的模拟。</p>
<p>群落迅速形成，红色和蓝色的智能体移动到隔离集群中，它们由空细胞的边界分隔。</p>
<p>对于每种状态，我们可以计算隔离度，它是相同颜色的邻居的比例。在所有细胞中的平均值：</p>
<pre><code class="lang-py">np.sum(frac_same) / np.sum(occupied)
</code></pre>
<p>在图？中，相似邻居的比例均值在初始状态中为 55%，两步后为 71%，10 步后为 80%！</p>
<p>请记住，当<code>p = 0.3</code>时，如果 8 个邻居中的 3 个是他们自己的颜色，那么智能体会很高兴，但他们最终居住在一个社区中，其中 6 或 7 个邻居是自己的颜色。</p>
<p><img src="img/9-2.png" alt=""></img></p>
<p>图 9.2：随着时间的推移，谢林模型中的隔离程度，范围为<code>p</code></p>
<p>图？显示了隔离程度如何增加，以及它在几个<code>p</code>值下的平稳位置。 当<code>p = 0.4</code>时，稳定状态下的隔离程度约为 88%，且大多数智能体没有不同颜色的邻居。</p>
<p>这些结果令许多人感到惊讶，它们成为了个人决策与系统行为之间的，复杂且不可预测的关系的鲜明示例。</p>
<h2 id="94-糖域">9.4 糖域</h2>
<p>1996年，约书亚爱泼斯坦（Joshua Epstein）和罗伯特阿克斯特尔（Robert Axtell）提出了糖域（Sugarscape），这是一个“人造社会”的智能体模型，旨在支持经济学和其他社会科学的相关实验。</p>
<p>糖域是一款多功能的模型，适用于各种主题。 作为例子，我将复制 Epstein 和 Axtell 的书《Growing Artificial Societies》的前几个实验。</p>
<p>糖域最简单的形式是一个简单的经济模型，智能体在二维网格上移动，收集和累积代表经济财富的“糖”。 网格的一些部分比其他部分产生更多的糖，并且一些智能体比其他人更容易找到它。</p>
<p>这个糖域的版本常用于探索和解释财富的分布，特别是不平等的趋势。</p>
<p>在糖域的网格中，每个细胞都有一个容量，这是它可容纳的最大糖量。 在原始状态中，有两个高糖区域，容量为 4，周围是同心环，容量分别为 3, 2 和 1。</p>
<p><img src="img/9-3.png" alt=""></img></p>
<p>图 9.3：原始糖域模型的复制品：初始状态（左），2 步后（中）和 100 步后（右）。</p>
<p>图？（左）展示了初始状态，最黑暗的区域表示容量最高的细胞，小圆圈表示智能体。</p>
<p>最初有随机放置的 400 个智能体。 每个智能体有三个随机选择的属性：</p>
<p>糖：</p>
<p>每个智能体最开始都有先天的糖分，从 5 到 25 之间均匀选择。</p>
<p>代谢：</p>
<p>在每个时间步骤中，每个智能体都必须消耗一定数量的糖，从 1 到 4 之间均匀选择。</p>
<p>视力：</p>
<p>每个智能体可以“看到”附近细胞中糖量，并移动到最多的细胞，但是与其它智能体相比，一些智能体可以看到更远的细胞。 智能体看到的距离从 1 和 6 之间均匀选择。</p>
<p>在每个时间步骤中，智能体以随机顺序一次移动一格。 每个智能体都遵循以下规则：</p>
<ul>
<li>智能体在 4 个罗盘方向的每一个方向上调查<code>k</code>个细胞，其中<code>k</code>是智能体的视野范围。</li>
<li>它选择糖分最多的未占用的细胞。 在相等的情况下，选择较近的细胞；在距离相同的细胞中，它随机选择。</li>
<li>智能体移动到选定的细胞并收获糖分，将收获增加到其积累的财富并将细胞清空。</li>
<li>智能体根据代谢消耗其财富的一部分。 如果结果总量为负数，智能体“饿死”并被删除。</li>
</ul>
<p>在所有智能体完成这些步骤之后，细胞恢复一些糖，通常为 1 单位，但每个细胞中的总糖分受其容量限制。</p>
<p>图？（中）显示两步后模型的状态。 大多数智能体正在移到糖最多的地区。 视力高的智能体移动速度最快；视力低的智能体往往会卡在高原上，随机游走，直到它们足够接近来看到下一个水平。</p>
<p>出生在糖分最少的地区的智能体可能会饿死，除非他们的视力很好，先天条件也很高。</p>
<p>在高糖地区，随着糖分的出现，智能体相互竞争，寻找和收获糖分。 消耗高或视力低的智能体最有可能挨饿。</p>
<p>当糖在每个时间步骤增加 1 个单位时，就没有足够的糖来维持我们开始的 400 个智能体。 人口起初迅速下降，然后缓慢下降，在大约 250 左右停下。</p>
<p>图？（右）显示了 100 个时间步后的模型状态，大约有 250 个智能体。 存活的智能体往往是幸运者，出生时视力高和/或代消耗低。 存活到这里的话，它们可能会永远存活，积累无限量的糖。</p>
<h2 id="95-财富的不平等">9.5 财富的不平等</h2>
<p>在目前的形式下，糖域建立了一个简单的生态学模型，可用于探索模型参数之间的关系，如增长率和智能体的属性，以及系统的承载能力（在稳定状态下生存的智能体数量）。 它模拟了一种形式的自然选择的，“适应度”较高的智能体更有可能生存下来。</p>
<p>该模型还表现出一种财富不平等，一些智能体积累糖的速度比其他智能体快。 但是对于财富分布，很难说具体的事情，因为它不是“静止的”。 也就是说，分布随着时间的推移而变化并且不会达到稳定状态。</p>
<p>然而，如果我们给智能体有限的寿命，这个模型会产生固定的财富分布。 然后我们可以运行实验，来查看参数和规则对此分布的影响。</p>
<p>在这个版本的模型中，智能体的年龄在每个时间步增加，并且从 60 到 100 之间的均匀分布中，随机选择一个寿命。如果智能体的年龄超过其寿命，它就会死亡。</p>
<p>当智能体因饥饿或年老而死亡时，它由属性随机的新智能体所取代，所以总人口是不变的。</p>
<p><img src="img/9-4.png" alt=""></img></p>
<p>图 9.4：100, 200, 300 和 400 步（灰线）和 500 步（黑线）之后的糖（财富）的分布。 线性刻度（左）和对数刻度（右）。</p>
<p>从接近承载能力的 250 个智能体开始，我运行了 500 个步骤的模型。 在每 100 步之后，我绘制了智能体积累的糖的分布。 图？在线性刻度（左）和对数刻度（右）中展示结果。</p>
<p>经过大约 200 步（这是最长寿命的两倍）后，分布变化不大。 并且它向右倾斜。</p>
<p>大多数智能体积累的财富很少：第 25 百分位数大约是 10，中位数大约是 20。但是少数智能体积累了更多：第 75 百分位数是大约 40，最大值大于 150。</p>
<p>在对数刻度上，分布的形状类似于高斯或正态分布，但右尾被截断。 如果它在对数刻度上实际上是正态的，则分布是对数正态分布，这是一种重尾分布。 实际上，几乎每个国家和全世界的财富分布都是重尾分布。</p>
<p>如果说糖域解释了为什么财富分布是重尾的，但是糖域变化中的不平等的普遍性表明，不平等是许多经济体的特征，甚至是非常简单的经济体。 一些实验表明避免或减轻并不容易，它们带有一些规则，对纳税和其他收入转移进行建模。</p>
<h2 id="96-实现糖域">9.6 实现糖域</h2>
<p>糖域比以前的模型更复杂，所以我不会在这里介绍整个实现。 我将概述代码的结构，你可以在 Jupyter 笔记本<code>chap09.ipynb</code>中查看本章的细节，它位于本书的仓库中。 如果你对细节不感兴趣，你可以跳到下一节。</p>
<p>以下是带有<code>step</code>方法的<code>Agent</code>类：</p>
<pre><code class="lang-py">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span><span class="hljs-params">(self, env)</span>:</span>
        self.loc = env.look_around(self.loc, self.vision)
        self.sugar += env.harvest(self.loc) - self.metabolism
        self.age += <span class="hljs-number">1</span>
</code></pre>
<p>在每个步骤中，智能体移动，收获糖，并增加年龄。</p>
<p>参数<code>env</code>是环境的引用，它是一个<code>Sugarscape</code>对象。 它提供了方法<code>look_around</code>和收获：</p>
<ul>
<li><code>look_around</code>获取智能体的位置，这是一个坐标元组，以及智能体的视野，它是一个整数。 它返回智能体的新位置，这是糖分最多的可见细胞。</li>
<li><code>harvest</code>需要智能体的（新）位置，并在移除并返回该位置的糖分。</li>
</ul>
<p>这里是<code>Sugarscape</code>类和它的<code>step</code>方法（不需要替换）：</p>
<pre><code class="lang-py"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sugarscape</span><span class="hljs-params">(Cell2D)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span><span class="hljs-params">(self)</span>:</span>

        <span class="hljs-comment"># loop through the agents in random order</span>
        random_order = np.random.permutation(self.agents)
        <span class="hljs-keyword">for</span> agent <span class="hljs-keyword">in</span> random_order:

            <span class="hljs-comment"># mark the current cell unoccupied</span>
            self.occupied.remove(agent.loc)

            <span class="hljs-comment"># execute one step</span>
            agent.step(self)

            <span class="hljs-comment"># if the agent is dead, remove from the list</span>
            <span class="hljs-keyword">if</span> agent.is_starving():
                self.agents.remove(agent)
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># otherwise mark its cell occupied</span>
                self.occupied.add(agent.loc)

        <span class="hljs-comment"># grow back some sugar</span>
        self.grow()
        <span class="hljs-keyword">return</span> len(self.agents)
</code></pre>
<p><code>Sugarscape</code>继承自<code>Cell2D</code>，因此它与我们所见过的其他基于网格的模型相似。</p>
<p>这些属性包括<code>agents</code>，它是<code>Agent</code>对象的列表，以及<code>occupied</code>，它是一组元组，其中每个元组包含智能体占用的细胞的坐标。</p>
<p>在每个步骤中，<code>Sugarscape</code>以随机顺序遍历智能体。 它调用每个智能体的<code>step</code>，然后检查它是否已经死亡。 所有智能体都移动后，一些糖会恢复。</p>
<p>如果你有兴趣深入了解 NumPy ，你可能需要仔细看看<code>make_visible_locs</code>，它构建一个数组，其中每行包含智能体可见的细胞坐标，按距离排序，但距离相同的细胞 是随机顺序。</p>
<p>你可能想看看<code>Sugarscape.make_capacity</code>，它初始化细胞的容量。 它演示了<code>np.meshgrid</code>的使用，这通常很有用，但需要一些时间才能理解。</p>
<h2 id="97-迁移和波动行为">9.7 迁移和波动行为</h2>
<p><img src="img/9-5.png" alt=""></img></p>
<p>图 9.5：<code>Sugarscape</code>中的波动行为：初始状态（左），6 步后（中）和 12 步后（右）</p>
<p>虽然<code>Sugarscape</code>的主要目的不是探索空间中的智能体的移动，但 Epstein 和 Axtell 在智能体迁移时，观察到一些有趣的模式。</p>
<p>如果我们开始把所有智能体放在左下角，他们会迅速走向最近的高容量细胞的“山峰”。 但是如果有更多的智能体，单个山峰不足以支持它们的话，他们很快就会耗尽糖分，智能体被迫进入低容量地区。</p>
<p>视野最长的那些，首先穿过山峰之间的山谷，并且像波一样向东北方向传播。 因为他们在身后留下一些空细胞，所以其他智能体不会追随，直到糖分恢复。</p>
<p>结果是一系列离散的迁移波，每个波都像一个连贯的物体，就像我们在规则 110 CA 和生命游戏中看到的飞船（参见第？节）。</p>
<p>图？显示了初始条件下（左），6 个步骤（中）和 12 个步骤（右）之后的模型状态。 你可以看到，前两个波到达并穿过第二个山峰，留下了一串空细胞。 你还可以看到这个模型的动画版本，其中波形更清晰可见。</p>
<p>虽然这些波动由智能体组成，但我们可以将他们视为自己的实体，就像我们在“生命游戏”中想到的滑翔机一样。</p>
<p>这些波动的一个有趣的属性是，它们沿对角线移动，这可能是令人惊讶的，因为这些智能体本身只是向北或向东移动，从不向东北方移动。 像这样的结果 - 团队或“集合”拥有智能体没有的属性和行为 - 在基于智能体的模型中很常见。 我们将在下一章看到更多的例子。</p>
<h2 id="98-涌现">9.8 涌现</h2>
<p>本章中的例子展示了复杂性科学中最重要的想法之一：涌现。 涌现性是系统的一个特征，由它的成分相互作用而产生，而不是它们的属性。</p>
<p>为了澄清什么是涌现，考虑它不是什么会有帮助。 例如，砖墙很硬，因为砖和砂浆很硬，所以这不是涌现。 再举一个例子，一些刚性结构是由柔性部件构成的，所以这看起来像是一种涌现。 但它至多是一种弱例，因为结构特性遵循已知的力学定律。</p>
<p>相反，我们在谢林模型中看到的隔离是一种涌现，因为它不是由种族主义智能体造成的。 即使智能体只是轻微排外，系统的结果与智能体的决策意图有很大不同。</p>
<p>糖域中的财富分配可能是涌现，但它是一个弱例，因为我们可以根据视力，代谢和寿命的分布合理预测它。 我们在最后一个例子中看到的波动行为可能是一个更强的例子，因为波动显示出智能体显然没有的能力 - 对角线运动。</p>
<p>涌现性令人惊讶：即使我们知道所有规则，也很难预测系统的行为。难度不是偶然的；事实上，它可能是涌现的决定性特征。</p>
<p>正如沃尔夫勒姆在“新科学”中所讨论的那样，传统科学是基于这样的公理：如果你知道管理系统的规则，那么你可以预测它的行为。 我们所谓的“法律”通常是计算的捷径，它使我们能够预测系统的结果而不用建立或观察它。</p>
<p>但是许多细胞自动机在计算上是不可减少的，这意味着没有捷径。 获得结果的唯一方法是实现该系统。</p>
<p>一般而言，复杂系统可能也是如此。 对于具有多个成分的物理系统，通常没有产生解析解的模型。 数值方法提供了一种计算捷径，但仍存在质的差异。</p>
<p>解析解通常提供用于预测的恒定时间算法；也就是说，计算的运行时间不取决于预测的时间尺度<code>t</code>。 但数值方法，模拟，模拟计算和类似方法需要的时间与<code>t</code>成正比。 对于许多系统来说，我们无法计算出可靠的预测。</p>
<p>这些观察表明，涌现性基本上是不可预测的，对于复杂系统我们不应该期望，通过计算捷径来找到自然规律。</p>
<p>对某些人来说，“涌现”是无知的另一个名字; 根据这种思维，如果我们针对它没有还原论的解释，那么这个属性就是涌现的，但如果我们在将来更好地理解它，它就不再是涌现的。</p>
<p>涌现性的状况是有争议的话题，所以对此持怀疑态度是恰当的。 当我们看到明显的涌现性时，我们不应该假设永远不会有还原论解释。但我们也不应该假设必须有。</p>
<p>本书中的例子和计算等价原理提供了很好的理由，认为至少有些涌现性永远不会被古典还原论模型“解释”。</p>
<p>你可以在这里深入了解涌现：<a href="http://en.wikipedia.org/wiki/Emergence" target="_blank">http://en.wikipedia.org/wiki/Emergence</a>。</p>
<h2 id="99-练习">9.9 练习</h2>
<p>练习 1</p>
<p>本章的代码位于本书仓库的 Jupyter 笔记本<code>chap09.ipynb</code>中。打开这个笔记本，阅读代码，然后运行单元格。你可以使用这个笔记本来练习本章的练习。我的解决方案在<code>chap09soln.ipynb</code>中。</p>
<p>练习 2</p>
<p>《The Big Sort》的作者 Bill Bishop 认为，美国社会越来越由政见所隔离，因为人们选择生活在志趣相投的邻居之中。</p>
<p>Bishop 所假设的机制并不是像谢林模型中的智能体那样，如果他们是孤立的，他们更有可能移动，但是当他们出于任何原因移动时，他们可能会选择一个社区，其中的人与他们自己一样。</p>
<p>修改谢林模型的实现来模拟这种行为，看看它是否会产生类似程度的隔离。</p>
<p>有几种方法可以模拟 Bishop 的假设。在我的实现中，随机选择的智能体会在每个步骤中移动。每个智能体考虑<code>k</code>个随机选择的空位置，并选择相似邻居的比例最高的位置。隔离程度和<code>k</code>有什么关系？</p>
<p>练习 3</p>
<p>在糖域的第一个版本中，我们从不添加智能体，所以一旦人口下降，它就不会恢复。 在第二个版本中，我们只是在智能体死亡时才取代，所以人口是不变的。 现在让我们看看如果我们增加一些“人口压力”会发生什么。</p>
<p>编写糖域的一个版本，在每一步结束时添加一个新的智能体。 添加代码来计算每个步骤结束时，智能体的平均视力和平均消耗。 运行模型几百步，绘制人口，平均视力和平均消耗随时间的变化。</p>
<p>你应该能够通过继承<code>SugarScape</code>并覆盖<code>__init__</code>和<code>step</code>来实现这个模型。</p>
<p>练习 4</p>
<p>在心灵哲学中，强人工智能是这样的理论，即受到适当编程的计算机可以拥有思想，与人类拥有的思想相同。</p>
<p>约翰·塞尔（John Searle）提出了一个名为“中文房间”的思想实验，旨在表明强 AI 是虚假的。 你可以在 <a href="http://en.wikipedia.org/wiki/Chinese_room" target="_blank">http://en.wikipedia.org/wiki/Chinese_room</a> 上阅读。</p>
<p>对中文房间的论述的系统回复是什么？ 你对涌现的认识如何影响你对系统回复的反应？</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="8.html" class="navigation navigation-prev " aria-label="Previous page: 八、自组织临界">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="10.html" class="navigation navigation-next " aria-label="Next page: 十、兽群、鸟群和交通堵塞">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"九、基于智能体的模型","level":"1.1.9","depth":2,"next":{"title":"十、兽群、鸟群和交通堵塞","level":"1.1.10","depth":2,"path":"10.md","ref":"10.md","articles":[]},"previous":{"title":"八、自组织临界","level":"1.1.8","depth":2,"path":"8.md","ref":"8.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"9.md","mtime":"2018-04-15T08:25:49.000Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:24:59.048Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

