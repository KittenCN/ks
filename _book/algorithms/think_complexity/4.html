
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>四、无标度网络 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="5.html" />
    
    
    <link rel="prev" href="3.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    复杂性思维
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="1.html">
            
                <a href="1.html">
            
                    
                    一、复杂性科学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="2.html">
            
                <a href="2.html">
            
                    
                    二、图
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="3.html">
            
                <a href="3.html">
            
                    
                    三、小世界图
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.4" data-path="4.html">
            
                <a href="4.html">
            
                    
                    四、无标度网络
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="5.html">
            
                <a href="5.html">
            
                    
                    五、细胞自动机
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="6.html">
            
                <a href="6.html">
            
                    
                    六、生命游戏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="7.html">
            
                <a href="7.html">
            
                    
                    七、物理建模
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="8.html">
            
                <a href="8.html">
            
                    
                    八、自组织临界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="9.html">
            
                <a href="9.html">
            
                    
                    九、基于智能体的模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="10.html">
            
                <a href="10.html">
            
                    
                    十、兽群、鸟群和交通堵塞
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="11.html">
            
                <a href="11.html">
            
                    
                    十一、进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="12.html">
            
                <a href="12.html">
            
                    
                    十二、合作进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="a.html">
            
                <a href="a.html">
            
                    
                    附录 A、算法分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="b.html">
            
                <a href="b.html">
            
                    
                    附录 B、阅读列表
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >四、无标度网络</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="四、无标度网络">四、无标度网络</h1>
<blockquote>
<p>原文：<a href="http://greenteapress.com/complexity2/html/thinkcomplexity2005.html" target="_blank">Chapter 4  Scale-free networks</a></p>
<p>译者：<a href="https://github.com/wizardforcel" target="_blank">飞龙</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/" target="_blank">谷歌翻译</a></p>
</blockquote>
<p>在本章中，我们将处理来自在线社交网络的数据，并使用 WS 图对其进行建模。WS 模型像数据一样，具有小世界网络的特点，但是与数据不同，它的节点到节点的邻居数目变化很小。</p>
<p>这种差异是 Barabási 和 Albert 开发的网络模型的动机。BA 模型捕捉到邻居数量的观察到的变化，它具有小的世界属性之一，短路径长度，但它没有一个小世界网络的高聚类。</p>
<p>本章最后讨论了 WS 和 BA 图，作为小世界网络的解释模型。</p>
<p>本章的代码位于本书的仓库中的<code>chap04.ipynb</code>中。使用代码的更多信息，请参见第（？）章。</p>
<h2 id="41-社交网络数据">4.1 社交网络数据</h2>
<p>WS 图的目的是，模拟自然科学和社会科学中的网络。Watts 和 Strogatz 在他们最初的论文中，查看了电影演员的网络（如果他们出现在同一部电影中，就是连接的）。美国西部的电网；和 C. elegans 线虫脑中的神经元网络 。他们发现，所有这些网络都具有小世界图的高群聚性和短路径长度特征。</p>
<p>在本节中，我们将使用不同的数据集，Facebook 用户及其朋友的数据集，来进行相同的分析。如果你对 Facebook 不熟悉，那么彼此连接的用户被称为“朋友”，而不管他们在现实世界中的关系的性质如何。</p>
<p>我将使用来自斯坦福网络分析项目（SNAP）的数据，该项目分享了来自在线社交网络和其他来源的大型数据集。具体来说，我将使用他们的 Facebook 数据集 [1]，其中包括 4039 个用户和 88,234 个朋友关系。该数据集位于本书的仓库中，但也可以从 <a href="https://snap.stanford.edu/data/egonets-Facebook.html" target="_blank">SNAP 网站</a>上获取。</p>
<blockquote>
<p>[1] J. McAuley and J. Leskovec. Learning to Discover Social Circles in Ego Networks. NIPS, 2012.</p>
</blockquote>
<p>数据文件为每条边包含一行，用户由 0 到 4038 之间的整数标识。下面是读取文件的代码：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_graph</span><span class="hljs-params">(filename)</span>:</span>
    G = nx.Graph()
    array = np.loadtxt(filename, dtype=int)
    G.add_edges_from(array)
    <span class="hljs-keyword">return</span> G
</code></pre>
<p>NumPy 提供了函数<code>loadtext</code>，它读取给定的文件，并以 NumPy 数组的形式返回内容。参数<code>dtype</code>指定数组元素的类型。</p>
<p>然后我们可以使用<code>add_edges_from</code>迭代数组的行，并创建边。结果如下：</p>
<pre><code class="lang-py"><span class="hljs-prompt">&gt;&gt;&gt; </span>fb = read_graph(<span class="hljs-string">'facebook_combined.txt.gz'</span>)
<span class="hljs-prompt">&gt;&gt;&gt; </span>n = len(fb)
<span class="hljs-prompt">&gt;&gt;&gt; </span>m = len(fb.edges())
<span class="hljs-prompt">&gt;&gt;&gt; </span>n, m
(<span class="hljs-number">4039</span>, <span class="hljs-number">88234</span>)
</code></pre>
<p>节点和边的数量与数据集的文档一致。</p>
<p>现在我们可以检查这个数据集是否具有小世界图的特征：高群聚性和短路径长度。</p>
<p>第（？）节中，我们编写了一个函数，来计算网络平均群聚系数。NetworkX 提供了一个叫做的函数<code>average_clustering</code>，它可以更快地完成相同的工作。</p>
<p>但是对于更大的图，它们都太慢，需要与<code>nk^2</code>成正比的时间，其中<code>n</code>是节点数，<code>k</code>是每个节点的邻居数。</p>
<p>幸运的是，<code>NetworkX</code>提供了一个通过随机抽样来估计群聚系数的函数。你可以像这样调用它：</p>
<pre><code class="lang-py">
    <span class="hljs-keyword">from</span> networkx.algorithms.approximation <span class="hljs-keyword">import</span> average_clustering
    average_clustering(G, trials=<span class="hljs-number">1000</span>)
</code></pre>
<p>下面函数对路径长度做了类似的事情：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_path_lengths</span><span class="hljs-params">(G, nodes=None, trials=<span class="hljs-number">1000</span>)</span>:</span>
    <span class="hljs-keyword">if</span> nodes <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
        nodes = G.nodes()
    <span class="hljs-keyword">else</span>:
        nodes = list(nodes)

    pairs = np.random.choice(nodes, (trials, <span class="hljs-number">2</span>))
    lengths = [nx.shortest_path_length(G, *pair)
               <span class="hljs-keyword">for</span> pair <span class="hljs-keyword">in</span> pairs]
    <span class="hljs-keyword">return</span> lengths
</code></pre>
<p><code>G</code>是一个图，<code>nodes</code>是节点列表，我们应该从中抽样，<code>trials</code>是要抽样的随机路径的数量。如果<code>nodes</code>是<code>None</code>，我们从整个图表中进行抽样。</p>
<p><code>pairs</code>是随机选择的节点的 NumPy 数组，对于每个采样有一行两列。</p>
<p>列表推导式枚举数组中的行，并计算每对节点之间的最短距离。结果是路径长度的列表。</p>
<p><code>estimate_path_length</code>生成一个随机路径长度列表，并返回它们的平均值：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">estimate_path_length</span><span class="hljs-params">(G, nodes=None, trials=<span class="hljs-number">1000</span>)</span>:</span>
    <span class="hljs-keyword">return</span> np.mean(random_path_lengths(G, nodes, trials))
</code></pre>
<p>我会使用<code>average_clustering</code>来计算<code>C</code>：</p>
<pre><code class="lang-py">C = average_clustering(fb)
</code></pre>
<p>并使用<code>estimate_path_lengths</code>来计算<code>L</code>：</p>
<pre><code class="lang-py">L = estimate_path_lengths(fb)
</code></pre>
<p>群聚系数约为<code>0.61</code>，这是较高的，正如我们所期望的那样，如果这个网络具有小世界特性。</p>
<p>平均路径为<code>3.7</code>，在 4000 多个用户的网络中相当短。毕竟这是一个小世界。</p>
<p>现在让我们看看是否可以构建一个 WS 图，与此网络具有相同特征。</p>
<h2 id="42-ws-模型">4.2 WS 模型</h2>
<p>在 Facebook 数据集中，每个节点的平均边数约为 22。由于每条边都连接到两个节点，度的均值是每个节点边数的两倍：</p>
<pre><code class="lang-py">
<span class="hljs-prompt">&gt;&gt;&gt; </span>k = int(round(<span class="hljs-number">2</span>*m/n))
<span class="hljs-prompt">&gt;&gt;&gt; </span>k
<span class="hljs-number">44</span>
</code></pre>
<p>我们可以用<code>n=4039</code>和<code>k=44</code>创建一个 WS 图。<code>p=0</code>时，我们会得到一个环格。</p>
<pre><code class="lang-py">
lattice = nx.watts_strogatz_graph(n, k, <span class="hljs-number">0</span>)
</code></pre>
<p>在这个图中，群聚较高：<code>C</code>是 0.73，而在数据集中是 0.61。但是<code>L</code>为 46，远远高于数据集！</p>
<p>使用<code>p=1</code>我们得到一个随机图：</p>
<pre><code class="lang-py">random_graph = nx.watts_strogatz_graph(n, k, <span class="hljs-number">1</span>)
</code></pre>
<p>在随机图中，<code>L</code>是 2.6，甚至比数据集（3.7）短，但<code>C</code>只有 0.011，所以这是不好的。</p>
<p>通过反复试验，我们发现，当<code>p=0.05</code>时，我们得到一个高群聚和短路径长度的 WS 图：</p>
<pre><code class="lang-py">
ws = nx.watts_strogatz_graph(n, k, <span class="hljs-number">0.05</span>, seed=<span class="hljs-number">15</span>)
</code></pre>
<p>在这个图中<code>C</code>是<code>0.63</code>，比数据集高一点，<code>L</code>是 3.2，比数据集低一点。所以这个图很好地模拟了数据集的小世界特征。</p>
<p>到现在为止还不错。</p>
<h2 id="43-度">4.3 度</h2>
<p><img src="img/4-1.png" alt=""></img></p>
<blockquote>
<p>图 4.1：Facebook 数据集和 WS 模型中的度的 PMF。</p>
</blockquote>
<p>回想一下，节点的度是它连接到的邻居的数量。如果 WS 图是 Facebook 网络的一个很好的模型，它应该具有相同的总（或平均）度，理想情况下不同节点的度数相同。</p>
<p>这个函数返回图中的度的列表，每个节点对应一项：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">degrees</span><span class="hljs-params">(G)</span>:</span>
    <span class="hljs-keyword">return</span> [G.degree(u) <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> G]
</code></pre>
<p>数据集中的度的均值是 43.7；WS 模型中的度的均值是 44。到目前为止还不错。</p>
<p>但是，WS 模型中的度的标准差为 1.5；数据中的标准差是 52.4。有点糟。</p>
<p>这里发生了什么？为了更好地查看，我们必须看看度的 分布，而不仅仅是均值和标准差。</p>
<p>我将用一个 Pmf 对象来表示度的分布，它在<code>thinkstats2</code>模块中定义。Pmf 代表“概率质量函数”；如果你不熟悉这个概念，你可以阅读 Think Stats 第二版的第三章，网址是 <a href="http://greenteapress.com/thinkstats2/html/thinkstats2004.html" target="_blank">http://greenteapress.com/thinkstats2/html/thinkstats2004.html</a>。</p>
<p>简而言之，Pmf 是值到概率的映射。Pmf 是每个可能的度<code>d</code>，到度为<code>d</code>的节点比例的映射。</p>
<p>作为一个例子，我将构建一个图，拥有节点<code>1, 2, 3</code>，连接到中心节点<code>0</code>：</p>
<pre><code class="lang-py">G = nx.Graph()
G.add_edge(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
G.add_edge(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)
G.add_edge(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)
nx.draw(G)
</code></pre>
<p>这里是图中的度的列表：</p>
<pre><code class="lang-py">
<span class="hljs-prompt">&gt;&gt;&gt; </span>degrees(G)
[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
</code></pre>
<p>节点<code>0</code>度为 3，其它度为 1。现在我可以生成一个 Pmf，它表示这个度的分布：</p>
<pre><code class="lang-py"><span class="hljs-prompt">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> thinkstats2 <span class="hljs-keyword">import</span> Pmf
<span class="hljs-prompt">&gt;&gt;&gt; </span>Pmf(degrees(G))
Pmf({<span class="hljs-number">1</span>: <span class="hljs-number">0.75</span>, <span class="hljs-number">3</span>: <span class="hljs-number">0.25</span>})
</code></pre>
<p>产生的<code>Pmf</code>是一个对象，将每个度映射到一个比例或概率。在这个例子中，75％的节点度为 1，25％度为 3。</p>
<p>现在我们生成一个<code>Pmf</code>，包含来自数据集的节点的度，并计算均值和标准差：</p>
<pre><code class="lang-py">
<span class="hljs-prompt">&gt;&gt;&gt; </span>pmf_ws = Pmf(degrees(ws))
<span class="hljs-prompt">&gt;&gt;&gt; </span>pmf_ws.mean(), pmf_ws.std()
(<span class="hljs-number">44.000</span>, <span class="hljs-number">1.465</span>)
</code></pre>
<p>我们可以使用<code>thinkplot</code>模块来绘制结果：</p>
<pre><code class="lang-py">thinkplot.Pdf(pmf_fb, label=<span class="hljs-string">'Facebook'</span>)
thinkplot.Pdf(pmf_ws, label=<span class="hljs-string">'WS graph'</span>)
</code></pre>
<p>图（？）显示了这两个分布。他们是非常不同的。</p>
<p>在 WS 模型中，大多数用户有大约 44 个朋友；最小值是 38，最大值是 50。这个变化不大。在数据集中，有很多用户只有 1 或 2 个朋友，但有一个人有 1000 多个！</p>
<p>像这样的分布，有许多小的值和一些非常大的值，被称为重尾。</p>
<h2 id="44-重尾分布">4.4 重尾分布</h2>
<p><img src="img/4-2.png" alt=""></img></p>
<blockquote>
<p>图 4.2：Facebook 数据集和 WS 模型中的度的 PMF，在双对数刻度下。</p>
</blockquote>
<p>在复杂性科学的许多领域中，重尾分布是一个常见特征，它们将成为本书的一个反复出现的主题。</p>
<p>我们可以在双对数轴绘制它，来获得重尾分布的更清晰的图像，就像上面那副图那样。这种转换突显了分布的尾巴；也就是较大值的概率。</p>
<p>在这种转换下，数据大致在一条直线上，这表明分布的最大值与概率之间存在“幂律”关系。在数学上，</p>
<pre><code>PMF(k) ~ k^(−α)
</code></pre><p>其中<code>PMF(k)</code>是度为<code>k</code>的节点的比例，<code>α</code>是一个参数，符号<code>~</code>表示当<code>k</code>增加时，PMF 渐近于<code>k^(−α)</code>。</p>
<p>如果我们把对两边取对数，我们得到：</p>
<pre><code>
logPMF(k) ~ −α logk
</code></pre><p>因此，如果一个分布遵循幂律，并且我们在双对数刻度上绘制<code>PMF(k)</code>与<code>k</code>的关系，那么我们预计至少对于<code>k</code>的较大值，将有一条斜率为<code>-α</code>的直线。</p>
<p>所有的幂律分布都是重尾的，但是还有其他重尾分布不符合幂律。我们将很快看到更多的例子。</p>
<p>但首先，我们有一个问题：WS 模型拥有高群聚性和短路径长度，我们在数据中也看到了，但度的分布根本不像数据。这种差异就启发了我们下一个主题，Barabási-Albert 模型。</p>
<h2 id="45-barabási-albert-模型">4.5 Barabási-Albert 模型</h2>
<p>1999 年，Barabási 和 Albert 发表了一篇论文“随机网络中的标度的出现”（Emergence of Scaling in Random Networks），描述了几个现实世界的网络的结构特征，包含一些图，它们展示了电影演员，万维网（WWW）页面和美国西部电网设施的互联性。你可以从 <a href="http://www.sciencemag.org/content/286/5439/509" target="_blank">http://www.sciencemag.org/content/286/5439/509</a> 下载该论文。</p>
<p>他们测量每个节点的度并计算<code>PMF(k)</code>，即节点度为<code>k</code>的比例。然后他们在双对数标度上绘制<code>PMF(k)</code>与<code>k</code>的关系。这些曲线可用一条直线拟合，至少对于<code>k</code>的较大数值；所以他们得出结论，这些分布是重尾的。</p>
<p>他们还提出了一个模型，生成了属性相同的图。模型的基本特征与 WS 模型不同，它们是：</p>
<p>增长：</p>
<p>BA 模型不是从固定数量的顶点开始，而是从一个较小图开始，每次添加一个顶点。</p>
<p>优先连接：</p>
<p>当创建一个新的边时，它更可能连接到一个已经有很多边的节点。这种“富者更富”的效应是一些现实世界网络增长模式的特征。</p>
<p>最后，他们表明，由 Barabási-Albert（BA）模型模型生成的图，度的分布遵循幂律。</p>
<p>具有这个属性的图有时被称为无标度网络，原因我不会解释；如果你好奇，可以在 <a href="http://en.wikipedia.org/wiki/Scale-free_network" target="_blank">http://en.wikipedia.org/wiki/Scale-free_network</a> 上阅读更多内容。</p>
<p>NetworkX 提供了一个生成 BA 图的函数。我们将首先使用它；然后我会告诉你它的工作原理。</p>
<pre><code class="lang-py">ba = nx.barabasi_albert_graph(n=<span class="hljs-number">4039</span>, k=<span class="hljs-number">22</span>)
</code></pre>
<p>参数是<code>n</code>要生成的节点数量，<code>k</code>是每个节点添加到图形时的起始边数。我选择<code>k=22</code>，是因为这是数据集中每个节点的平均边数。</p>
<p><img src="img/4-3.png" alt=""></img></p>
<blockquote>
<p>图 4.3：Facebook 数据集和 BA 模型中的节点的 PMF，在双对数刻度上。</p>
</blockquote>
<p>所得图形拥有 4039 个节点，每个节点有 21.9 个边。由于每条边连接两个节点，度的均值为 43.8，非常接近数据集中的度的均值 43.7。</p>
<p>度的标准差为 40.9，略低于数据集 52.4，但比我们从 WS 图得到的数值好 1.5 倍。</p>
<p>图（？）以双对数刻度展示了 Facebook 网络和 BA 模型的度的分布。模型并不完美；特别<code>k</code>是在小于 10 时偏离了数据。但尾巴看起来像是一条直线，这表明这个过程产生了遵循幂律的度的分布。</p>
<p>所以在重现度的分布时，BA 模型比 WS 模型更好。但它有小世界的属性？</p>
<p>在这个例子中，平均路径长度<code>L</code>是 2.5，这比实际的网络的<code>L = 3.69</code>更小。所以这很好，虽然可能太好了。</p>
<p>另一方面，群聚系数<code>C</code>为 0.037，并不接近数据集中的值 0.61。所以这是一个问题。</p>
<p>下表总结了这些结果。WS 模型捕获了小世界的特点，但没有度的分布。BA 模型捕获了度的分布，和平均路径长度，至少是近似的，但没有群聚系数。</p>
<p>在本章最后的练习中，你可以探索其他可以捕获所有这些特征的模型。</p>
<table>
<thead>
<tr>
<th></th>
<th>Facebook</th>
<th>WS 模型</th>
<th>BA 模型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C</code></td>
<td>0.61</td>
<td>0.63</td>
<td>0.037</td>
</tr>
<tr>
<td><code>L</code></td>
<td>3.69</td>
<td>3.23</td>
<td>2.51</td>
</tr>
<tr>
<td>度的均值</td>
<td>43.7</td>
<td>44</td>
<td>43.7</td>
</tr>
<tr>
<td>度的标准差</td>
<td>52.4</td>
<td>1.5</td>
<td>40.1</td>
</tr>
<tr>
<td>幂律？</td>
<td>可能</td>
<td>不是</td>
<td>是</td>
</tr>
</tbody>
</table>
<blockquote>
<p>表 4.1：与两个模型相比，Facebook 网络的特征。</p>
</blockquote>
<h2 id="46-生成-ba-图">4.6 生成 BA 图</h2>
<p>在前面的章节中，我们使用了 NetworkX 函数来生成BA图。现在让我们看看它的工作原理。这是一个<code>barabasi_albert_graph</code>的版本，我做了一些更改，使其更易于阅读：</p>
<pre><code class="lang-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">barabasi_albert_graph</span><span class="hljs-params">(n, k)</span>:</span>

    G = nx.empty_graph(k)
    targets = list(range(k))
    repeated_nodes = []

    <span class="hljs-keyword">for</span> source <span class="hljs-keyword">in</span> range(k, n):

        G.add_edges_from(zip([source]*k, targets))

        repeated_nodes.extend(targets)
        repeated_nodes.extend([source] * k)

        targets = _random_subset(repeated_nodes, k)

    <span class="hljs-keyword">return</span> G
</code></pre>
<p><code>n</code>是我们想要的节点的数量，<code>k</code>是每个新节点边的数量（近似为每个节点的边的数量）。</p>
<p>我们从一个<code>k</code>个节点和没有边的图开始。然后我们初始化两个变量：</p>
<p><code>targets</code>：</p>
<p><code>k</code>个节点的列表，它们将被连接到下一个节点。最初<code>targets</code>包含原来的<code>k</code>个节点；之后它将包含节点的随机子集。</p>
<p><code>repeated_nodes</code>：</p>
<p>一个现有节点的列表，如果一个节点有<code>k</code>条边，那么它出现<code>k</code>次。当我们从<code>repeated_nodes</code>选择时，选择任何节点的概率与它所具有的边数成正比。</p>
<p>每次循环中，我们添加源节点到<code>targets</code>中的节点的边。然后我们更新<code>repeated_nodes</code>，通过添加每个目标一次，以及新的节点<code>k</code>次。</p>
<p>最后，我们选择节点的子集作为下一次迭代的目标。以下是<code>_random_subset</code>的定义：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_random_subset</span><span class="hljs-params">(repeated_nodes, k)</span>:</span>
    targets = set()
    <span class="hljs-keyword">while</span> len(targets) &lt; k:
        x = random.choice(repeated_nodes)
        targets.add(x)
    <span class="hljs-keyword">return</span> targets
</code></pre>
<p>每次循环中，<code>_random_subset</code>从<code>repeated_nodes</code>选择，并将所选节点添加到<code>targets</code>。因为<code>targets</code>是一个集合，它会自动丢弃重复项，所以只有当我们选择了<code>k</code>不同的节点时，循环才会退出。</p>
<h2 id="47-累积分布函数（cdf）">4.7 累积分布函数（CDF）</h2>
<p><img src="img/4-4.png" alt=""></img></p>
<blockquote>
<p>图 4.4：Facebook 数据集中的度的 CDF，以及 WS 模型（左边）和 BA 模型（右边），在双对数刻度上。</p>
</blockquote>
<p>图 4.3 通过在双对数刻度上绘制概率质量函数（PMF）来表示度的分布。这就是 Barabási 和 Albert 呈现他们的结果的方式，这是幂律分布的文章中最常使用的表示。但是，这不是观察这样的数据的最好方法。</p>
<p>更好的选择是累积分布函数 （CDF），它将<code>x</code>值映射为小于或等于<code>x</code>的值的比例。</p>
<p>给定一个 Pmf，计算累积概率的最简单方法是将<code>x</code>的概率加起来，包括<code>x</code>：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cumulative_prob</span><span class="hljs-params">(pmf, x)</span>:</span>
    ps = [pmf[value] <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> pmf <span class="hljs-keyword">if</span> value&lt;=x]
    <span class="hljs-keyword">return</span> sum(ps)
</code></pre>
<p>例如，给定数据集中的度的分布，<code>pmf_pf</code>，我们可以计算好友数小于等于 25 的比例：</p>
<pre><code class="lang-py">
<span class="hljs-prompt">&gt;&gt;&gt; </span>cumulative_prob(pmf_fb, <span class="hljs-number">25</span>)
<span class="hljs-number">0.506</span>
</code></pre>
<p>结果接近 0.5，这意味着好友数的中位数约为 25。</p>
<p>因为 CDF 的噪音比 PMF 少，所以 CDF 更适合可视化。一旦你习惯了 CDF 的解释，它们可以提供比 PMF 更清晰的分布图像。</p>
<p><code>thinkstats</code>模块提供了一个称为<code>Cdf</code>的类，代表累积分布函数。我们可以用它来计算数据集中的度的 CDF。</p>
<pre><code class="lang-py">
<span class="hljs-keyword">from</span> thinkstats2 <span class="hljs-keyword">import</span> Cdf
cdf_fb = Cdf(degrees(fb), label=<span class="hljs-string">'Facebook'</span>)
</code></pre>
<p><code>thinkplot</code>提供了一个函数，叫做<code>Cdf</code>，绘制累积分布函数。</p>
<pre><code class="lang-py">
thinkplot.Cdf(cdf_fb)
</code></pre>
<p>图 4.4 显示了 Facebook 数据集的度的 CDF ，以及 WS 模型（左边）和 BA 模型（右边）。<code>x</code>轴是对数刻度。</p>
<p>显然，WS 模型和数据集的 CDF 很大不同。BA 模式更好，但还不是很好，特别是对于较小数值。</p>
<p>在分布的尾部（值大于 100），BA 模型看起来与数据集匹配得很好，但是很难看出来。我们可以使用另一个数据视图，更清楚地观察数据：在对数坐标上绘制互补 CDF。</p>
<p>互补 CDF（CCDF）定义为：</p>
<pre><code>
CCDF(x) = 1 − CDF(x)
</code></pre><p>它很有用，因为如果 PMF 服从幂律，CCDF 也服从：</p>
<pre><code>CCDF(x) =(x/x_m)^(-α)
</code></pre><p>其中<code>x_m</code>是最小可能值，<code>α</code>是确定分布形状的参数。</p>
<p>对两边取对数：</p>
<pre><code>
logCCDF(x) = −α (logx − logx_m)
</code></pre><p>因此，如果分布服从幂定律，在双对数刻度上，我们预计 CCDF 是斜率为<code>-α</code>的直线。</p>
<p>图 4.5 以双对数刻度显示 Facebook 数据的度的 CCDF，以及 WS 模型（左边）和 BA 模型（右边）。</p>
<p>通过这种查看数据的方式，我们可以看到 BA 模型与分布的尾部（值大于 20）匹配得相当好。WS 模型没有。</p>
<h2 id="48-解释性模型">4.8 解释性模型</h2>
<p><img src="img/4-6.png" alt=""></img></p>
<blockquote>
<p>图 4.6：解释性模型的逻辑结构</p>
</blockquote>
<p>我们以 Milgram 的小世界实验开始讨论网络，这表明社交网络中的路径长度是惊人的小；因此，有了“六度分离”。</p>
<p>当我们看到令人惊讶的事情时，自然会问“为什么”，但有时候我们不清楚我们正在寻找什么样的答案。一种答案是解释性模型（见图 4.6）。解释性模型的逻辑结构是：</p>
<ol>
<li><p>在一个系统<code>S</code>中，我们看到一些可观察的东西<code>O</code>，值得解释。</p>
</li>
<li><p>我们构建一个与系统类似的模型<code>M</code>，也就是说，模型与系统之间的元素/组件/原理是对应的。</p>
</li>
<li><p>通过模拟或数学推导，我们表明，该模型展现出类似于<code>O</code>的行为<code>B</code>。</p>
</li>
<li><p>我们得出这样的结论：<code>S</code>表现<code>O</code>，因为 <code>S</code>类似于<code>M</code>，<code>M</code>表示<code>B</code>，而<code>B</code>类似于<code>O</code>。</p>
</li>
</ol>
<p>其核心是类比论证，即如果两个事物在某些方面相似，那么它们在其他方面可能是相似的。</p>
<p>类比论证是有用的，解释模型可以令人满意，但是它们并不构成数学意义上的证明。</p>
<p>请记住，所有的模型都有所忽略，或者“抽象掉”我们认为不重要的细节。对于任何系统都有很多可能的模型，它们包括或忽略不同的特性。而且可能会出现不同的行为模式，<code>B</code>，<code>B'</code>和<code>B''</code>，这些模式与<code>O</code>不同。在这种情况下，哪个模型解释了<code>O</code>？</p>
<p>小世界现象就是一个例子：Watts-Strogatz（WS）模型和 Barabási-Albert（BA）模型都展现出小世界行为的元素，但是它们提供了不同的解释：</p>
<ul>
<li>WS 模型表明，社交网络是“小”的，因为它们包括强连通的集群，和连接群集的“弱关系”（参见 <a href="http://en.wikipedia.org/wiki/Mark_Granovetter#The_strength_of_weak_ties" target="_blank">http://en.wikipedia.org/wiki/Mark_Granovetter#The_strength_of_weak_ties</a>）。</li>
<li>BA 模型表明，社交网络很小，因为它们包括度较高的节点，作为中心，并且随着时间的推移，由于优先添加，中心​​会增长。</li>
</ul>
<p>在科学的新兴领域，往往是这样，问题不是我们没有解释，而是它们太多。</p>
<h2 id="49：练习">4.9：练习</h2>
<p>练习 1：</p>
<p>上一节中，我们讨论了小世界现象的两种解释，“弱关系”和“中心”。这些解释是否兼容？也就是说，他们能都对吗？你觉得哪一个解释更令人满意？为什么？</p>
<p>是否有可以收集的数据或可以执行的实验，它们可以提供有利于一种模型的证据？</p>
<p>竞争模型中的选择，是托马斯·库恩（Thomas Kuhn）的论文“客观性，价值判断和理论选择”（Objectivity, Value Judgment, and Theory Choice）的主题，你可以在 <a href="https://github.com/AllenDowney/ThinkComplexity2/blob/master/papers/kuhn.pdf" target="_blank">https://github.com/AllenDowney/ThinkComplexity2/blob/master/papers/kuhn.pdf</a> 上阅读。</p>
<p>对于竞争模型中的选择，库恩提出了什么标准？这些标准是否会影响你对 WS 和 BA 模型的看法？你认为还有其他标准应该考虑吗？</p>
<p>练习 2：</p>
<p>NetworkX 提供了一个叫做<code>powerlaw_cluster_graph</code>的函数，实现了 Holme 和 Kim 算法，用于使用度的幂律分布和近似平均聚类，使图增长。阅读该函数的文档，看看是否可以使用它来生成一个图，节点数、度的均值和群聚系数与 Facebook 数据集相同。与实际分布相比较，模型中的度的分布如何？</p>
<p>练习 3：</p>
<p>来自 Barabási 和 Albert 论文的数据文件可从  <a href="http://www3.nd.edu/~networks/resources.htm" target="_blank">http://www3.nd.edu/~networks/resources.htm</a> 获得。他们的演员协作数据包含在名为<code>actor.dat.gz</code>的文件中。以下函数读取文件并构建图。</p>
<pre><code class="lang-py">
<span class="hljs-keyword">import</span> gzip

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_actor_network</span><span class="hljs-params">(filename, n=None)</span>:</span>
    G = nx.Graph()
    <span class="hljs-keyword">with</span> gzip.open(filename) <span class="hljs-keyword">as</span> f:
        <span class="hljs-keyword">for</span> i, line <span class="hljs-keyword">in</span> enumerate(f):
            nodes = [int(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> line.split()]
            G.add_edges_from(thinkcomplexity.all_pairs(nodes))
            <span class="hljs-keyword">if</span> n <span class="hljs-keyword">and</span> i &gt;= n:
                <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> G
</code></pre>
<p>计算图中的演员数量和度的均值。以双对数刻度绘制度的 PMF。同时在对数-线性刻度上绘制度的 CDF，来观察分布的一般形状，并在双对数刻度上观察，尾部是否服从幂律。</p>
<p>注意：演员的网络不是连通的，因此你可能想要使用<code>nx.connected_component_subgraphs</code>查找节点的连通子集。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="3.html" class="navigation navigation-prev " aria-label="Previous page: 三、小世界图">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="5.html" class="navigation navigation-next " aria-label="Next page: 五、细胞自动机">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"四、无标度网络","level":"1.1.4","depth":2,"next":{"title":"五、细胞自动机","level":"1.1.5","depth":2,"path":"5.md","ref":"5.md","articles":[]},"previous":{"title":"三、小世界图","level":"1.1.3","depth":2,"path":"3.md","ref":"3.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"4.md","mtime":"2018-04-15T08:25:49.000Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:24:59.048Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

