
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>七、物理建模 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="8.html" />
    
    
    <link rel="prev" href="6.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    复杂性思维
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="1.html">
            
                <a href="1.html">
            
                    
                    一、复杂性科学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="2.html">
            
                <a href="2.html">
            
                    
                    二、图
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="3.html">
            
                <a href="3.html">
            
                    
                    三、小世界图
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="4.html">
            
                <a href="4.html">
            
                    
                    四、无标度网络
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="5.html">
            
                <a href="5.html">
            
                    
                    五、细胞自动机
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="6.html">
            
                <a href="6.html">
            
                    
                    六、生命游戏
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.7" data-path="7.html">
            
                <a href="7.html">
            
                    
                    七、物理建模
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="8.html">
            
                <a href="8.html">
            
                    
                    八、自组织临界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="9.html">
            
                <a href="9.html">
            
                    
                    九、基于智能体的模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="10.html">
            
                <a href="10.html">
            
                    
                    十、兽群、鸟群和交通堵塞
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="11.html">
            
                <a href="11.html">
            
                    
                    十一、进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="12.html">
            
                <a href="12.html">
            
                    
                    十二、合作进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="a.html">
            
                <a href="a.html">
            
                    
                    附录 A、算法分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="b.html">
            
                <a href="b.html">
            
                    
                    附录 B、阅读列表
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >七、物理建模</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="七、物理建模">七、物理建模</h1>
<blockquote>
<p>原文：<a href="http://greenteapress.com/complexity2/html/thinkcomplexity2008.html" target="_blank">Chapter 7  Physical modeling</a></p>
<p>译者：<a href="https://github.com/wizardforcel" target="_blank">飞龙</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/" target="_blank">谷歌翻译</a></p>
</blockquote>
<p>到目前为止，我们所看到的细胞自动机不是物理模型；也就是说，他们不打算描述现实世界中的系统。 但是一些 CA 用作物理模型。</p>
<p>在本章中，我们考虑一个 CA，它模拟扩散（散开）并相互反应的化学物质，这是 Alan Turing 提出的过程，用于解释一些动物模式如何发展。</p>
<p>我们将试验一种 CA，它模拟通过多孔材料的渗透液体，例如通过咖啡渣的水。 这个模型是展示相变行为和分形几何的几个模型中的第一个，我将解释这两者的含义。</p>
<p>本章的代码位于本书仓库的<code>chap07.ipynb</code>中。 使用代码的更多信息，请参见第？节。</p>
<h2 id="71-扩散">7.1 扩散</h2>
<p>1952 年，艾伦图灵发表了一篇名为“形态发生的化学基础”的论文，该论文描述了涉及两种化学物质的系统行为，它们在空间中扩散并相互反应。 他表明，这些系统根据扩散和反应速率产生了广泛的模式，并推测像这样的系统可能是生物生长过程中的重要机制，特别是动物着色模式的发展。</p>
<p>图灵模型基于微分方程，但也可以使用细胞自动机来实现。</p>
<p>但在我们开始使用图灵模型之前，我们先从简单的事情开始：只有一种化学物质的扩散系统。 我们将使用 2-D CA，其中每个细胞的状态是连续的数量（通常在 0 和 1 之间），表示化学物质的浓度。</p>
<p>我们将通过比较每个细胞与其邻居的均值，来建模扩散过程。 如果中心细胞的浓度超过领域均值，则化学物质从中心流向邻居。 如果中心细胞的浓度较低，则化学物质以另一种方式流动。</p>
<p>以下核计算每个细胞与其邻居均值之间的差异：</p>
<pre><code class="lang-py">
kernel = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
                   [<span class="hljs-number">1</span>,-<span class="hljs-number">4</span>, <span class="hljs-number">1</span>],
                   [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])
</code></pre>
<p>使用<code>np.correlate2d</code>，我们可以将这个核应用于数组中的每个细胞：</p>
<pre><code class="lang-py">
c = correlate2d(array, kernel, mode=<span class="hljs-string">'same'</span>)
</code></pre>
<p>我们将使用一个扩散常数<code>r</code>，它关联了浓度差与流速：</p>
<pre><code class="lang-py">array += r * c
</code></pre>
<p><img src="img/7-1.png" alt=""></img></p>
<p>图 7.1：0，5 和 10 步后的简单扩散模型</p>
<p>图？显示 CA 的结果，其中<code>n=9, r=0.1</code>，除了中间的“岛”外，初始浓度为 0。 该图显示了 CA 的启动状态，以及 5 步和 10 步之后的状态。 化学物质从中心向外扩散，直到各处浓度相同。</p>
<h2 id="72-反应扩散">7.2 反应扩散</h2>
<p>现在我们添加第二种化学物。 我将定义一个新对象<code>ReactionDiffusion</code>，它包含两个数组，每个化学物对应一个：</p>
<pre><code class="lang-py">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReactionDiffusion</span><span class="hljs-params">(Cell2D)</span>:</span>

   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n, m, params)</span>:</span>
        self.params = params
        self.array = np.ones((n, m), dtype=float)
        self.array2 = np.zeros((n, m), dtype=float)
        island(self.array2, val=<span class="hljs-number">0.1</span>, noise=<span class="hljs-number">0.1</span>)
</code></pre>
<p><code>n</code>和<code>m</code>是数组中的行数和列数。 <code>params</code>是参数元组，下面我会解释它。</p>
<p>数组代表第一种化学物质<code>A</code>的浓度，它最初是无处不在的。</p>
<p><code>array2</code>表示<code>B</code>的浓度，除了中间的一个岛屿，它初始为零，并且由<code>island</code>初始化：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">island</span><span class="hljs-params">(a, val, noise)</span>:</span>
    n, m = a.shape
    r = min(n, m) // <span class="hljs-number">20</span>
    a[n//<span class="hljs-number">2</span>-r:n//<span class="hljs-number">2</span>+r, m//<span class="hljs-number">2</span>-r:m//<span class="hljs-number">2</span>+r] = val
    a += noise * np.random.random((n, m))
</code></pre>
<p>岛的半径<code>r</code>是<code>n</code>或<code>m</code>的二十分之一，以较小者为准。 岛的高度是<code>val</code>，在这个例子中是<code>0.1</code>。 此外，随机均匀噪声（值为 0 到<code>noise</code>）添加到整个数组。</p>
<p>这里是更新数组的<code>step</code>函数：</p>
<pre><code class="lang-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span><span class="hljs-params">(self)</span>:</span>
    <span class="hljs-string">"""Executes one time step."""</span>
    A = self.array
    B = self.array2
    ra, rb, f, k = self.params

    cA = correlate2d(A, self.kernel, **self.options)
    cB = correlate2d(B, self.kernel, **self.options)

    reaction = A * B**<span class="hljs-number">2</span>
    self.array += ra * cA - reaction + f * (<span class="hljs-number">1</span>-A)
    self.array2 += rb * cB + reaction - (f+k) * B
</code></pre>
<p>参数是</p>
<p><code>ra</code>：</p>
<p><code>A</code>的扩散速率（类似于前一节中的<code>r</code>）。</p>
<p><code>rb</code>：</p>
<p><code>B</code>的扩散速率。在该模型的大多数版本中，<code>rb</code>约为<code>ra</code>的一半。</p>
<p><code>f</code>：</p>
<p>进给速率，控制着<code>A</code>添加到系统的速度。</p>
<p><code>k</code>：</p>
<p>移除速率，控制<code>B</code>从系统中移除的速度。</p>
<p>现在让我们仔细看看更新语句：</p>
<pre><code class="lang-py">
reaction = A * B**<span class="hljs-number">2</span>
self.array += ra * cA - reaction + f * (<span class="hljs-number">1</span>-A)
self.array2 += rb * cB + reaction - (f+k) * B
</code></pre>
<p>数组<code>cA</code>和<code>cB</code>是将扩散核应用于<code>A</code>和<code>B</code>的结果。乘以<code>ra</code>和<code>rb</code>得出进入或离开每个细胞的扩散速率。</p>
<p>表达式<code>A * B ** 2</code>表示<code>A</code>和<code>B</code>相互反应的比率。 假设反应消耗<code>A</code>并产生<code>B</code>，我们在第一个方程中减去这个项并在第二个方程中加上它。</p>
<p>表达式<code>f * (1-A)</code>决定<code>A</code>加入系统的速率。 当<code>A</code>接近 0 时，最大进给速率为<code>f</code>。 当<code>A</code>接近 1 时，进给速率下降到零。</p>
<p>最后，表达式<code>(f+k) * B</code>决定<code>B</code>从系统中移除的速率。 当<code>B</code>接近 0 时，该比率变为零。</p>
<p>只要速率参数不太高，<code>A</code>和<code>B</code>的值通常保持在 0 和 1 之间。</p>
<p><img src="img/7-2.png" alt=""></img></p>
<p>图 7.2：1000，2000 和 4000 步之后的反应扩散模型，参数为<code>f=0.035</code>和<code>k=0.057</code></p>
<p>使用不同的参数，该模型可以产生类似于各种动物身上的条纹和斑点的图案。 在某些情况下，相似性是惊人的，特别是当进给和移除参数在空间上变化时。</p>
<p>对于本节中的所有模拟，<code>ra = 0.5</code>，<code>rb = 0.25</code>。</p>
<p>图？显示了<code>f=0.035</code>和<code>k=0.057</code>的结果，<code>B</code>的浓度以较暗的颜色显示。 有了这些参数，系统就向稳定状态演化，在<code>B</code>的黑色背景上有<code>A</code>的光点。</p>
<p><img src="img/7-3.png" alt=""></img></p>
<p>图 7.3：1000，2000 和 4000 步之后的反应扩散模型，参数为<code>f=0.055</code>和<code>k=0.062</code></p>
<p>图？显示了<code>f = 0.055</code>和<code>k = 0.062</code>的结果，在<code>A</code>的背景上产生了珊瑚样的<code>B</code>。</p>
<p><img src="img/7-4.png" alt=""></img></p>
<p>图 7.4：1000，2000 和 4000 步之后的反应扩散模型，参数为<code>f=0.039</code>和<code>k=0.065</code></p>
<p>图？显示了<code>f = 0.039</code>和<code>k = 0.065</code>的结果。 在类似于有丝分裂的过程中，这些参数产生的<code>B</code>点生长和分裂，最后形成稳定的等距点图案。</p>
<p>1952 年以来，观察和实验为图灵猜想提供了一些支持。 目前为止，看起来许多动物图案实际上由某种反应扩散过程形成，但尚未证实。</p>
<h2 id="73-渗流">7.3 渗流</h2>
<p>渗流是流体流过半多孔材料的过程。 实例包括岩层中的油，纸中的水和微孔中的氢气。 渗流模型也用于研究不是严格渗滤的系统，包括流行病和电阻网络。 请见 <a href="http://en.wikipedia.org/wiki/Percolation_theory" target="_blank">http://en.wikipedia.org/wiki/Percolation_theory</a>。</p>
<p>渗流模型常常用随机图来表示，就像我们在第？章中看到的那样，但它们也可以用细胞自动机表示。 在接下来的几节中，我们将探索模拟渗流的 2-D CA。</p>
<p>在这个模型中：</p>
<ul>
<li>最初，每个细胞是概率为<code>p</code>的“多孔”或者“无孔”，并且除了顶部那行是“湿的”之外，所有单元都是“干的”。</li>
<li>在每个时间步骤中，如果多孔细胞至少有一个湿的邻居，它会变湿。 非多孔细胞保持干燥。</li>
<li>模拟运行直至达到不再有细胞改变状态的“固定点”。</li>
</ul>
<p>如果存在从顶部到底部的湿细胞路径，我们说 CA 具有“渗流簇”。</p>
<p>渗流的一个主要问题是，找到渗流簇的概率以及它如何依赖于<code>p</code>。 这个问题可能会让你想起第？节，其中我们计算了随机 ER 图连接的概率。 我们会看到这两个模型之间的几个关系。</p>
<p>我定义了一个新类来表示渗流模型：</p>
<pre><code class="lang-py">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percolation</span><span class="hljs-params">(Cell2D)</span>:</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n, m, p)</span>:</span>
        self.p = p
        self.array = np.random.choice([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], (n, m), p=[<span class="hljs-number">1</span>-p, p])
        self.array[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>
</code></pre>
<p><code>n</code>和<code>m</code>是 CA 中的行数和列数。 <code>p</code>是细胞为多孔的概率。</p>
<p>CA 的状态存储在数组中，该数组使用<code>np.random.choice</code>初始化，以概率<code>p</code>选择 1（多孔），以概率<code>1-p</code>选择 0（无孔）。 顶部那行的状态设置为 5，表示一个湿细胞。</p>
<p>在每个时间步骤中，我们使用 4 细胞邻域（不包括对角线）来检查任何多孔细胞是否拥有湿的邻居。 这是核：</p>
<pre><code class="lang-py">
kernel = np.array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
                   [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
                   [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])
</code></pre>
<p>这里是<code>step</code>函数：</p>
<p><code>correlate2d</code>将邻居的状态相加，如果至少有一个邻居是湿的，那么至少大于 5。 最后一行寻找多孔的细胞，<code>a == 1</code>，并且至少有一个湿邻居，<code>c &gt;= 5</code>，并将它们的状态设置为 5，这代表湿的。</p>
<p><img src="img/7-5.png" alt=""></img></p>
<p>图 7.5：渗流模型的前三个步骤，其中<code>n=10</code>和<code>p=0.5</code></p>
<p>图？显示了<code>n = 10</code>和<code>p = 0.5</code>的渗流模型的前几个步骤。 非多孔细胞为白色，多孔细胞为浅色，湿细胞为深色。</p>
<h2 id="74-相变">7.4 相变</h2>
<p>现在让我们测试 CA 是否包含渗流簇。</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_perc</span><span class="hljs-params">(perc)</span>:</span>
    num_wet = perc.num_wet()

    num_steps = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
        perc.step()
        num_steps += <span class="hljs-number">1</span>

        <span class="hljs-keyword">if</span> perc.bottom_row_wet():
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>, num_steps

        new_num_wet = perc.num_wet()
        <span class="hljs-keyword">if</span> new_num_wet == num_wet:
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>, num_steps

        num_wet = new_num_wet
</code></pre>
<p><code>test_perc</code>接受<code>Percolation</code>对象作为参数。 每次循环中，它都会使 CA 前进一个时间步骤。 它检查底部那行，看看有没有湿的细胞；如果有，它返回<code>True</code>，表示存在渗透簇，以及<code>num_steps</code>，它是到达底部所需的时间步数。</p>
<p>在每个时间步骤中，它还计算湿细胞的数量并检查自上一步以来数量是否增加。 如果没有，我们已经到达了固定点，而没有找到一个渗流簇，所以我们返回<code>False</code>。</p>
<p>为了估计渗流簇的概率，我们生成许多随机初始状态并测试它们：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">estimate_prob_percolating</span><span class="hljs-params">(p=<span class="hljs-number">0.5</span>, n=<span class="hljs-number">100</span>, iters=<span class="hljs-number">100</span>)</span>:</span>
    count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(iters):
        perc = Percolation(n, p=p)
        flag, _ = test_perc(perc)
        <span class="hljs-keyword">if</span> flag:
            count += <span class="hljs-number">1</span>

    <span class="hljs-keyword">return</span> count / iters
</code></pre>
<p><code>estimate_prob_percolating</code>使用给定的<code>p</code>和<code>n</code>值生成 100 个 CA，并调用<code>test_perc</code>来查看其中有多少个具有渗流簇。 返回值是拥有的 CA 的比例。</p>
<p>当<code>p = 0.55</code>时，渗滤簇的概率接近于 0。<code>p = 0.60</code>时，它约为 70%，而在<code>p = 0.65</code>时，它接近于 1。这种快速转变表明<code>p</code>的临界值接近 0.6。</p>
<p>我们可以更精确地使用随机游走来估计临界值。 从<code>p</code>的初始值开始，我们构造一个<code>Percolation</code>对象并检查它是否具有渗透簇。 如果是这样，<code>p</code>可能太高，所以我们减少它。 如果不是，<code>p</code>可能太低，所以我们增加它。</p>
<p>这里是代码：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_critical</span><span class="hljs-params">(p=<span class="hljs-number">0.6</span>, n=<span class="hljs-number">100</span>, iters=<span class="hljs-number">100</span>)</span>:</span>
    ps = [p]
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(iters):
        perc = Percolation(n=n, p=p)
        flag, _ = test_perc(perc)
        <span class="hljs-keyword">if</span> flag:
            p -= <span class="hljs-number">0.005</span>
        <span class="hljs-keyword">else</span>:
            p += <span class="hljs-number">0.005</span>
        ps.append(p)
    <span class="hljs-keyword">return</span> ps
</code></pre>
<p><code>find_critical</code>以<code>p</code>的给定值开始并上下调整，返回值的列表。 当<code>n = 100</code>时，<code>ps</code>的平均值约为 0.59，对于从 50 到 400 的<code>n</code>值，这个临界值似乎是一样的。</p>
<p>临界值附近的行为的快速变化称为相变，类似于物理系统中的相变，例如水在冰点处从液体变为固体的方式。</p>
<p>在处于或接近临界点时，各种各样的系统展示了一组共同的行为和特征。这些行为被统称为临界现象。 在下一节中，我们将探究其中的一个：分形几何。</p>
<h2 id="75-分形">7.5 分形</h2>
<p>为了理解分形，我们必须从维度开始。</p>
<p>对于简单的几何对象，维度根据缩放行为而定义。 例如，如果正方形的边长为<code>l</code>，则其面积为<code>l ** 2</code>。 指数 2 表示正方形是二维的。 同样，如果立方体的边长为<code>l</code>，则其体积为<code>l ** 3</code>，这表示立方体是三维的。</p>
<p>更一般来说，我们可以通过测量一个对象的“尺寸”（通过一些定义），将对象的维度估计为线性度量的函数。</p>
<p>例如，我将通过测量一维细胞自动机的面积（“开”细胞的总数），将它的维度估计为行数的函数。</p>
<p><img src="img/7-6.png" alt=""></img></p>
<p>图 7.6：32 个时间步之后，规则为 20，50 和 18 的一维 CA。</p>
<p>图？展示了三个一维 CA，就像我们在第？节中看到的那样。 规则 20（左）产生一组看似线性的细胞，所以我们预计它是一维的。 规则 50（中）产生类似于三角形的东西，所以我们预计它是二维的。 规则 18（右）也产生类似三角形的东西，但密度不均匀，所以其缩放行为并不明显。</p>
<p>我将用以下函数来估计这些 CA 的维度，该函数计算每个时间步之后的细胞数。 它返回一个元组列表，其中每个元组包含<code>i</code>和<code>i ** 2</code>，用于比较，以及细胞总数。</p>
<pre><code class="lang-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_cells</span><span class="hljs-params">(rule, n=<span class="hljs-number">500</span>)</span>:</span>
    ca = Cell1D(rule, n)
    ca.start_single()

    res = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):
        cells = np.sum(ca.array)
        res.append((i, i**<span class="hljs-number">2</span>, cells))
        ca.step()

    <span class="hljs-keyword">return</span> res
</code></pre>
<p><img src="img/7-7.png" alt=""></img></p>
<p>图 7.7：规则 20，50 和 18 的“开”细胞的数量与时间步数。</p>
<p>图？展示以双对数刻度绘制的结果。</p>
<p>在每幅图中，顶部虚线表示<code>y = i ** 2</code>。 两边取对数，我们得到<code>logy = 2logi</code>。 由于该数字在双对数刻度上，因此直线的斜率为2。</p>
<p>同样，底部的虚线表示<code>y = i</code>。 在双对数刻度上，直线的斜率为 1。</p>
<p>规则 20（左）每两个时间步骤产生三个细胞，所以<code>i</code>步后的细胞总数为<code>y = 1.5 i</code>。 两边取对数，我们得到<code>logy = log1.5 + logi</code>，所以在双对数刻度上，我们期待一条斜率为 1 的线。实际上，线的估计的斜率为 1.01。</p>
<p>规则 50（中）在第<code>i</code>个时间步骤中产生<code>i + 1</code>个新细胞，因此<code>i</code>步之后的细胞总数为<code>y = i ** 2 + i</code>。 如果我们忽略第二项并取两边的对数，我们有<code>logy ~ 2 logi</code>，所以当<code>i</code>变大时，我们预计看到一条斜率为 2 的线。事实上，估计的斜率为 1.97。</p>
<p>最后，对于规则 18（右），估计的斜率大约是 1.57，这显然不是 1，2 或任何其他整数。 这表明规则 18 生成的图案具有“分数维度”；也就是说，它是一个分形。</p>
<h2 id="76-分形和渗流模型">7.6 分形和渗流模型</h2>
<p><img src="img/7-8.png" alt=""></img></p>
<p>图 7.8：<code>p=0.6</code>和<code>n=100, 200, 300</code>的渗流模型</p>
<p>现在让我们回到渗透模型。 图？展示了<code>p = 0.6</code>和<code>n = 100, 200, 300</code>的渗流模型中的湿细胞簇。非正式来说，它们类似于在自然界和数学模型中看到的分形模式。</p>
<p>为了估计它们的分形维度，我们可以运行一系列尺寸的 CA，计算每个渗流簇中湿细胞的数量，然后看看随着我们增加 CA 的大小，细胞计数的规模如何增长。</p>
<p>以下循环运行了模拟：</p>
<pre><code class="lang-py">
<span class="hljs-keyword">for</span> size <span class="hljs-keyword">in</span> sizes:
    perc = Percolation(size, p=p)
    flag, _ = test_perc(perc)
    <span class="hljs-keyword">if</span> flag:
        num_filled = perc.num_wet() - size
        res.append((size, size**<span class="hljs-number">2</span>, num_filled))
</code></pre>
<p>结果是元组列表，其中每个元组包含<code>size</code>和<code>size ** 2</code>，用于比较，以及渗流簇中的细胞数（不包括顶行中的初始湿细胞）。</p>
<p><img src="img/7-9.png" alt=""></img></p>
<p>图 7.9：渗流簇中的细胞数量与 CA 大小</p>
<p>图？展示了 10 到 100 范围内的结果。点展示了每个渗流簇中的细胞数。 拟合这些点的线的斜率大约为 1.85，这表明当<code>p</code>接近临界值时，渗滤簇实际上是分形的。</p>
<p>当<code>p</code>大于临界值时，几乎每个多孔细胞都被填充，因此湿单元的数量仅为<code>p * size ** 2</code>，它的维度为 2。</p>
<p>当<code>p</code>远小于临界值时，湿细胞的数量与 CA 的线性大小成比例，因此它的维度为 1。</p>
<h2 id="77-练习">7.7 练习</h2>
<p>练习 1</p>
<p>在第？节中，我们发现 CA 规则 18 产生了一个分形。 你能找到其他产生分形的一维 CA 吗？</p>
<p>注意：<code>Cell1D.py</code>中的<code>Cell1D</code>对象不会从左边绕到右边，对于某些规则它在边界上创建了手工艺品 [?]。你可能想要使用<code>Wrap1D</code>，它是<code>Cell1D</code>的子类。 它也在<code>Cell1D.py</code>中定义。</p>
<p>练习 2</p>
<p>1990 年，Bak，Chen 和 Tang 提出了一种细胞自动机，它是一种森林火灾的抽象模型。 每个细胞处于三种状态之一：空，被树占用或着火。</p>
<p>CA 的规则是：</p>
<ul>
<li>空细胞以概率<code>p</code>被占用。</li>
<li>如果任何一个邻居着火，那么带有树的细胞就会燃烧。</li>
<li>即使没有邻居着火，带有树的细胞自发燃烧，概率为<code>f</code>。</li>
<li>在下一个时间步骤中，着火的细胞变为空细胞。</li>
</ul>
<p>编写一个实现这个模型的程序。 你可能想要继承<code>Cell2D</code>。 参数的常用值为<code>p = 0.01</code>和<code>f = 0.001</code>，但你可能想要尝试其他值。</p>
<p>从随机初始条件开始，运行 CA 直到它达到稳定状态，树的数量不再持续增加或减少。</p>
<p>在稳定状态下，森林分形的几何形状是什么？ 它的分形维度是多少？</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="6.html" class="navigation navigation-prev " aria-label="Previous page: 六、生命游戏">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="8.html" class="navigation navigation-next " aria-label="Next page: 八、自组织临界">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"七、物理建模","level":"1.1.7","depth":2,"next":{"title":"八、自组织临界","level":"1.1.8","depth":2,"path":"8.md","ref":"8.md","articles":[]},"previous":{"title":"六、生命游戏","level":"1.1.6","depth":2,"path":"6.md","ref":"6.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"7.md","mtime":"2018-04-15T08:25:49.000Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:24:59.048Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

