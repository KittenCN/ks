
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>二、图 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="3.html" />
    
    
    <link rel="prev" href="1.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    复杂性思维
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="1.html">
            
                <a href="1.html">
            
                    
                    一、复杂性科学
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.2" data-path="2.html">
            
                <a href="2.html">
            
                    
                    二、图
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="3.html">
            
                <a href="3.html">
            
                    
                    三、小世界图
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="4.html">
            
                <a href="4.html">
            
                    
                    四、无标度网络
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="5.html">
            
                <a href="5.html">
            
                    
                    五、细胞自动机
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="6.html">
            
                <a href="6.html">
            
                    
                    六、生命游戏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="7.html">
            
                <a href="7.html">
            
                    
                    七、物理建模
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="8.html">
            
                <a href="8.html">
            
                    
                    八、自组织临界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="9.html">
            
                <a href="9.html">
            
                    
                    九、基于智能体的模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="10.html">
            
                <a href="10.html">
            
                    
                    十、兽群、鸟群和交通堵塞
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="11.html">
            
                <a href="11.html">
            
                    
                    十一、进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="12.html">
            
                <a href="12.html">
            
                    
                    十二、合作进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="a.html">
            
                <a href="a.html">
            
                    
                    附录 A、算法分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="b.html">
            
                <a href="b.html">
            
                    
                    附录 B、阅读列表
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >二、图</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="二、图">二、图</h1>
<blockquote>
<p>原文：<a href="http://greenteapress.com/complexity2/html/thinkcomplexity2003.html" target="_blank">Chapter 2  Graphs</a></p>
<p>译者：<a href="https://github.com/wizardforcel" target="_blank">飞龙</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/" target="_blank">谷歌翻译</a></p>
</blockquote>
<p>本书的前三章有关一些模型，它们描述了由组件和组件之间的连接组成的系统。例如，在生态食物网中，组件是物种，连接代表捕食者和猎物的关系。</p>
<p>在本章中，我介绍了 NetworkX，一个用于构建和研究这些模型的 Python 包。我们从 Erdős-Rényi 模型开始，它具有一些有趣的数学属性。在下一章中，我们将介绍更有用的，解释现实系统的模型。</p>
<p>本章的代码在本书仓库中的<code>chap02.ipynb</code>中。使用代码的更多信息请参见第（？）章。</p>
<h2 id="21-图是什么？">2.1 图是什么？</h2>
<p><img src="img/2-1.png" alt=""></img></p>
<blockquote>
<p>图 2.1：表示社交网络的有向图</p>
</blockquote>
<p>对于大多数人来说，图是数据集的视觉表示，如条形图或股票价格对于时间的绘图。这不是本章的内容。</p>
<p>在本章中，图是一个系统的表示，它包含离散的互连元素。元素由节点表示，互连由边表示。</p>
<p>例如，你可以表示一个路线图，每个城市都是一个节点，每个城市之间的路线是一条边。或者你可以表示一个社交网络，每个人是节点，如果他们是朋友，两个人之间有边，否则没有。</p>
<p>在某些图中，边具有长度，成本或权重等属性。例如，在路线图中，边的长度可能代表两个城市之间的距离，或旅行时间。在社交网络中，可能会有不同的边来表示不同种类的关系：朋友，商业伙伴等。</p>
<p>边可以是有向或无向的，这取决于它们表示的关系是不对称的还是对称的。在路线图中，你可能会使用有向边表示单向街道，使用无向边表示双向街道。在某些社交网络，如 Facebook，好友是对称的：如果 A 是 B 的朋友，那么 B 也是 A 的朋友。但在 Twitter 上，“关注”关系并不对称；如果 A 关注了 B，这并不意味着 B  关注 A。因此，你可以使用无向边来表示 Facebook 网络，并将有向边用于 Twitter。</p>
<p>图具有有趣的数学属性，并且有一个称为图论的数学分支，用于研究它们。</p>
<p>图也很有用，因为有许多现实世界的问题可以使用图的算法来解决。例如，Dijkstra 的最短路径算法，是从图中找到某个节点到所有其他节点的最短路径的有效方式。路径是两个节点之间的，带有边的节点序列。</p>
<p>图的节点通常以圆形或方形绘制，边通常以直线绘制。例如，上面的有向图中，节点可能代表在 Twitter 上彼此“关注”的三个人。线的较厚部分表示边的方向。在这个例子中，爱丽丝和鲍勃相互关注，都关注查克，但查克没有关注任何人。</p>
<p>下面的无向图展示了美国东北部的四个城市；边上的标签表示驾驶时间，以小时为单位。在这个例子中，节点的位置大致对应于城市的地理位置，但是通常图的布局是任意的。</p>
<h2 id="22-networkx">2.2 NetworkX</h2>
<p><img src="img/2-2.png" alt=""></img></p>
<blockquote>
<p>图 2.2：表示城市和高速公路的无向图</p>
</blockquote>
<p>为了表示图，我们将使用一个名为 NetworkX 的包，它是 Python 中最常用的网络库。你可以在 <a href="https://networkx.github.io/" target="_blank">https://networkx.github.io/</a> 上阅读更多信息，但是我们之后会解释。</p>
<p>我们可以通过导入 NetworkX 和实例化<code>nx.DiGraph</code>来创建有向图：</p>
<pre><code class="lang-py">
<span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx
G = nx.DiGraph()
</code></pre>
<p>通常将 NetworkX 导入为<code>nx</code>。此时，<code>G</code>是一个<code>DiGraph</code>对象，不包含节点和边。我们可以使用<code>add_node</code>方法添加节点：</p>
<pre><code class="lang-py">
G.add_node(<span class="hljs-string">'Alice'</span>)
G.add_node(<span class="hljs-string">'Bob'</span>)
G.add_node(<span class="hljs-string">'Chuck'</span>)
</code></pre>
<p>现在我们可以使用<code>nodes</code>方法获取节点列表：</p>
<pre><code class="lang-py">
<span class="hljs-prompt">&gt;&gt;&gt; </span>G.nodes()
[<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Chuck'</span>]
</code></pre>
<p>添加边的方式几乎相同：</p>
<pre><code class="lang-py">
G.add_edge(<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>)
G.add_edge(<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Chuck'</span>)
G.add_edge(<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Alice'</span>)
G.add_edge(<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Chuck'</span>)
</code></pre>
<p>我们可以使用<code>edges</code>来获取边的列表：</p>
<pre><code class="lang-py"><span class="hljs-prompt">&gt;&gt;&gt; </span>G.edges()
[(<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Bob'</span>), (<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'Chuck'</span>),
 (<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Alice'</span>), (<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Chuck'</span>)]
</code></pre>
<p>NetworkX 提供了几个绘图的功能；<code>draw_circular</code>将节点排列成一个圆，并使用边将它们连接：</p>
<pre><code class="lang-py">
nx.draw_circular(G,
                 node_color=COLORS[<span class="hljs-number">0</span>],
                 node_size=<span class="hljs-number">2000</span>,
                 with_labels=<span class="hljs-keyword">True</span>)
</code></pre>
<p>这就是我用来生成图（？）的代码。<code>with_labels</code>选项标注了节点；在下一个例子中，我们将看到如何标注边。</p>
<p>为了产生图（？），我们以一个字典开始，它将每个城市的名称，映射为对应的经纬度：</p>
<pre><code class="lang-py">
pos = dict(Albany=(-<span class="hljs-number">74</span>, <span class="hljs-number">43</span>),
           Boston=(-<span class="hljs-number">71</span>, <span class="hljs-number">42</span>),
           NYC=(-<span class="hljs-number">74</span>, <span class="hljs-number">41</span>),
           Philly=(-<span class="hljs-number">75</span>, <span class="hljs-number">40</span>))
</code></pre>
<p>因为这是个无向图，我实例化了<code>nx.Graph</code>：</p>
<pre><code class="lang-py">
G = nx.Graph()
</code></pre>
<p>之后我可以使用<code>add_nodes_from</code>来迭代<code>pos</code>的键，并将它们添加为节点。</p>
<pre><code class="lang-py">
G.add_nodes_from(pos)
</code></pre>
<p>下面我会创建一个字典，将每条边映射为对应的驾驶时间。</p>
<pre><code class="lang-py">
drive_times = {(<span class="hljs-string">'Albany'</span>, <span class="hljs-string">'Boston'</span>): <span class="hljs-number">3</span>,
               (<span class="hljs-string">'Albany'</span>, <span class="hljs-string">'NYC'</span>): <span class="hljs-number">4</span>,
               (<span class="hljs-string">'Boston'</span>, <span class="hljs-string">'NYC'</span>): <span class="hljs-number">4</span>,
               (<span class="hljs-string">'NYC'</span>, <span class="hljs-string">'Philly'</span>): <span class="hljs-number">2</span>}
</code></pre>
<p>现在我可以使用<code>add_edges_from</code>，它迭代了<code>drive_times</code>的键，并将它们添加为边：</p>
<pre><code class="lang-py">G.add_edges_from(drive_times)
</code></pre>
<p>现在我不使用<code>draw_circular</code>，它将节点排列成一个圆圈，而是使用<code>draw</code>，它接受<code>pos</code>作为第二个参数：</p>
<pre><code class="lang-py">
nx.draw(G, pos,
        node_color=COLORS[<span class="hljs-number">1</span>],
        node_shape=<span class="hljs-string">'s'</span>,
        node_size=<span class="hljs-number">2500</span>,
        with_labels=<span class="hljs-keyword">True</span>)
</code></pre>
<p><code>pos</code>是一个字典，将每个城市映射为其坐标；<code>draw</code>使用它来确定节点的位置。</p>
<p>要添加边的标签，我们使用<code>draw_networkx_edge_labels</code>：</p>
<pre><code class="lang-py">
nx.draw_networkx_edge_labels(G, pos,
                             edge_labels=drive_times)
</code></pre>
<p><code>drive_times</code>是一个字典，将每条边映射为它们之间的驾驶距离，每条边表示为城市名称的偶对。这就是我生成图（？）的方式。</p>
<p>在这两个例子中，这些节点是字符串，但是通常它们可以是任何可哈希的类型。</p>
<h2 id="23-随机图">2.3 随机图</h2>
<p>随机图就像它的名字一样：一个随机生成的节点和边的图。当然，有许多随机过程可以生成图，所以有许多种类的随机图。</p>
<p>其中一个更有趣的是 Erdős-Rényi 模型，PaulErdős 和 AlfrédRényi 在 20 世纪 60 年代研究过它。</p>
<p>Erdős-Rényi 图（ER 图）的特征在于两个参数：<code>n</code>是节点的数量，<code>p</code>是任何两个节点之间存在边的概率。见 <a href="http://en.wikipedia.org/wiki/Erdos-Renyi_model" target="_blank">http://en.wikipedia.org/wiki/Erdos-Renyi_model</a>。</p>
<p>Erdős 和 Rényi 研究了这些随机图的属性；其令人惊奇的结果之一就是，随着随机的边被添加，随机图的属性会突然变化。</p>
<p>展示这类转变的一个属性是连通性。如果每个节点到每个其他节点都存在路径，那么无向图是连通的。</p>
<p>在 ER 图中，当<code>p</code>较小时，图是连通图的概率非常低，而<code>p</code>较大时接近<code>1</code>。在这两种状态之间，在<code>p</code>的特定值处存在快速转变，表示为<code>p*</code>。</p>
<p>Erdős 和 Rényi 表明，这个临界值是<code>p* = lnn / n</code>，其中<code>n</code>是节点数。如果<code>p &lt; p*</code>，随机图<code>G(n, p)</code>不太可能连通，并且如果<code>p &gt; p*</code>，则很可能连通。</p>
<p>为了测试这个说法，我们将开发算法来生成随机图，并检查它们是否连通。</p>
<h2 id="24-生成图">2.4 生成图</h2>
<p><img src="img/2-3.png" alt=""></img></p>
<p>我将首先生成一个完全图，这是一个图，其中每个节点都彼此连接。</p>
<p>这是一个生成器函数，它接收节点列表并枚举所有不同的偶对。如果你不熟悉生成器函数，你可能需要阅读附录？，然后回来。</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">all_pairs</span><span class="hljs-params">(nodes)</span>:</span>
    <span class="hljs-keyword">for</span> i, u <span class="hljs-keyword">in</span> enumerate(nodes):
        <span class="hljs-keyword">for</span> j, v <span class="hljs-keyword">in</span> enumerate(nodes):
            <span class="hljs-keyword">if</span> i&gt;j:
                <span class="hljs-keyword">yield</span> u, v
</code></pre>
<p>你可以使用<code>all_pairs</code>来构造一个完全图。</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_complete_graph</span><span class="hljs-params">(n)</span>:</span>
    G = nx.Graph()
    nodes = range(n)
    G.add_nodes_from(nodes)
    G.add_edges_from(all_pairs(nodes))
    <span class="hljs-keyword">return</span> G
</code></pre>
<p><code>make_complete_graph</code>接受节点数<code>n</code>，并返回一个新的<code>Graph</code>，拥有<code>n</code>个节点，所有节点之间都有边。</p>
<p>以下代码生成了一个包含 10 个节点的完全图，并绘制出来。</p>
<pre><code class="lang-py">
complete = make_complete_graph(<span class="hljs-number">10</span>)
nx.draw_circular(complete,
                 node_color=COLORS[<span class="hljs-number">2</span>],
                 node_size=<span class="hljs-number">1000</span>,
                 with_labels=<span class="hljs-keyword">True</span>)
</code></pre>
<p>图（？）显示了结果。不久之后，我们将修改此代码来生成 ER 图，但首先我们将开发函数来检查图是否是连通的。</p>
<h2 id="25-连通图">2.5 连通图</h2>
<p>如果每个节点到每个其他节点都存在路径，这个图就是连通图。请见<a href="http://en.wikipedia.org/wiki/Connectivity_(graph_theory)" target="_blank">http://en.wikipedia.org/wiki/Connectivity_(graph_theory)</a>。</p>
<p>对于许多涉及图的应用，检查图是否连通是很有用的。幸运的是，有一个简单的算法。</p>
<p>你可以从任何节点起步，并检查是否可以到达所有其他节点。如果你可以到达一个节点<code>v</code>，你可以到达<code>v</code>的任何一个邻居，他们是<code>v</code>通过边连接的任何节点。</p>
<p><code>Graph</code>类提供了一个称为<code>neighbors</code>的方法，返回给定节点的邻居列表。例如，在上一节中我们生成的完全图中：</p>
<pre><code class="lang-py"><span class="hljs-prompt">&gt;&gt;&gt; </span>complete.neighbors(<span class="hljs-number">0</span>)
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]
</code></pre>
<p>假设我们从节点<code>s</code>起步。我们可以将<code>s</code>标记为“已访问”，然后我们可以标记它的邻居。然后我们标记邻居的邻居，依此类推，直到你无法再到达任何节点。如果访问了所有节点，则图是连通图。</p>
<p>以下是 Python 中的样子：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reachable_nodes</span><span class="hljs-params">(G, start)</span>:</span>
    seen = set()
    stack = [start]
    <span class="hljs-keyword">while</span> stack:
        node = stack.pop()
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
            seen.add(node)
            stack.extend(G.neighbors(node))
    <span class="hljs-keyword">return</span> seen
</code></pre>
<p><code>reachable_nodes</code>接受<code>Graph</code>和起始节点<code>start</code>，并返回可以从<code>start</code>到达的节点集合，他们。</p>
<p>最初，已访问的集合是空的，我们创建一个名为<code>stack</code>的列表，跟踪我们发现但尚未处理的节点。最开始，栈包含单个节点<code>start</code>。</p>
<p>现在，每次在循环中，我们：</p>
<ul>
<li>从栈中删除一个节点。</li>
<li>如果节点已在<code>seen</code>中，我们返回到步骤 1。</li>
<li>否则，我们将节点添加到<code>seen</code>，并将其邻居添加到栈。</li>
</ul>
<p>当栈为空时，我们无法再到达任何节点，所以我们终止了循环并返回。</p>
<p>例如，我们可以找到从节点<code>0</code>可到达的，完全图中的所有节点：</p>
<pre><code class="lang-py">
<span class="hljs-prompt">&gt;&gt;&gt; </span>reachable_nodes(complete, <span class="hljs-number">0</span>)
{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>}
</code></pre>
<p>最初，栈包含节点<code>0</code>，<code>seen</code>是空的。第一次循环中，节点<code>0</code>添加到了<code>seen</code>，所有其他节点添加到了栈中（因为它们都是节点<code>0</code>的邻居）。</p>
<p>下一次循环中，<code>pop</code>返回栈中的最后一个元素，即节点<code>9.</code>因此，节点<code>9</code>被添加到<code>seen</code>，并且其邻居被添加到栈。</p>
<p>请注意，同一个节点在栈中可能会出现多次；实际上，具有<code>k</code>个邻居的节点将添加到栈<code>k</code>次。稍后我们将寻找方法，来使此算法更有效率。</p>
<p>我们可以使用<code>reachable_nodes</code>来编写<code>is_connected</code>：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_connected</span><span class="hljs-params">(G)</span>:</span>
    start = next(G.nodes_iter())
    reachable = reachable_nodes(G, start)
    <span class="hljs-keyword">return</span> len(reachable) == len(G)
</code></pre>
<p><code>is_connected</code>通过调用<code>nodes_iter</code>来选择一个起始节点，<code>node_iter</code>返回一个迭代器对象，并将结果传递给<code>next</code>，返回第一个节点。</p>
<p><code>reachable</code>获取了一组节点，它们可以从<code>start</code>到达。如果这个集合的大小与图的大小相同，那意味着我们可以访问所有节点，也就是这个图是连通的。</p>
<p>一个完全图是连通的，毫不奇怪：</p>
<pre><code class="lang-py"><span class="hljs-prompt">&gt;&gt;&gt; </span>is_connected(complete)
<span class="hljs-keyword">True</span>
</code></pre>
<p>下一节中，我们会生成 ER 图，并检查它们是否是连通的。</p>
<h2 id="26-生成-er图">2.6 生成 ER图</h2>
<p><img src="img/2-4.png" alt=""></img></p>
<blockquote>
<p>图 2.4：ER 图，<code>n=10</code>，<code>p=0.3</code></p>
</blockquote>
<p>ER 图<code>G(n, p)</code>包含<code>n</code>个节点，每对节点以概率为<code>p</code>的边连接。生成 ER 图类似于生成完全图。</p>
<p>以下生成器函数枚举所有可能的边，并使用辅助函数<code>flip</code>，来选择哪些应添加到图中：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_pairs</span><span class="hljs-params">(nodes, p)</span>:</span>
    <span class="hljs-keyword">for</span> i, u <span class="hljs-keyword">in</span> enumerate(nodes):
        <span class="hljs-keyword">for</span> j, v <span class="hljs-keyword">in</span> enumerate(nodes):
            <span class="hljs-keyword">if</span> i&gt;j <span class="hljs-keyword">and</span> flip(p):
                <span class="hljs-keyword">yield</span> u, v
</code></pre>
<p><code>flip</code>以给定概率<code>p</code>返回<code>True</code>，以互补的概率<code>1-p</code>返回<code>False</code>。</p>
<pre><code class="lang-py">
<span class="hljs-keyword">from</span> numpy.random <span class="hljs-keyword">import</span> random

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flip</span><span class="hljs-params">(p)</span>:</span>
    <span class="hljs-keyword">return</span> random() &lt; p
</code></pre>
<p>最后，<code>make_random_graph</code>生成并返回 ER 图<code>G(n, p)</code>。</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_random_graph</span><span class="hljs-params">(n, p)</span>:</span>
    G = nx.Graph()
    nodes = range(n)
    G.add_nodes_from(nodes)
    G.add_edges_from(random_pairs(nodes, p))
    <span class="hljs-keyword">return</span> G
</code></pre>
<p><code>make_random_graph</code>几乎和<code>make_complete_graph</code>，唯一的不同是它使用<code>random_pairs</code>而不是<code>all_pairs</code>。</p>
<p>这里是<code>p=0.3</code>的例子：</p>
<pre><code class="lang-py">random_graph = make_random_graph(<span class="hljs-number">10</span>, <span class="hljs-number">0.3</span>)
</code></pre>
<p>图（？）展示了结果。这个图是连通图；事实上，大多数<code>p=10</code>并且<code>p=3</code>的 ER 图都是连通图。在下一节中，我们将看看有多少。</p>
<h2 id="27-连通性的概率">2.7 连通性的概率</h2>
<p><img src="img/2-5.png" alt=""></img></p>
<blockquote>
<p>图 2.5：连通性的概率，<code>n=10</code>，<code>p</code>是一个范围。竖直的线展示了预测的临界值。</p>
</blockquote>
<p><img src="img/2-6.png" alt=""></img></p>
<blockquote>
<p>图 2.6：连通性的概率，<code>n</code>是多个值，<code>p</code>是一个范围。</p>
</blockquote>
<p>对于<code>n</code>和<code>p</code>的给定值，我们想知道<code>G(n, p)</code>连通的概率。我们可以通过生成大量随机图，来计算有多少个来估计它。就是这样：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prob_connected</span><span class="hljs-params">(n, p, iters=<span class="hljs-number">100</span>)</span>:</span>
    count = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(iters):
        random_graph = make_random_graph(n, p)
        <span class="hljs-keyword">if</span> is_connected(random_graph):
            count += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> count/iters
</code></pre>
<p><code>iters</code>是我们生成的随机图的数量。随着我们增加<code>iter</code>，估计的概率就会更加准确。</p>
<pre><code class="lang-py">
<span class="hljs-prompt">&gt;&gt;&gt; </span>prob_connected(<span class="hljs-number">10</span>, <span class="hljs-number">0.3</span>, iters=<span class="hljs-number">10000</span>)
<span class="hljs-number">0.6454</span>
</code></pre>
<p>在具有这些参数的 10000 个 ER 图中，6498 个是连通的，因此我们估计其中65％是连通的。所以 0.3 接近临界值，在这里连通概率从接近 0 变为接近 1。根据 Erdős 和 Rényi，<code>p* = lnn / n = 0.23</code>。</p>
<p>我们可以通过估计一系列<code>p</code>值的连通概率，来更清楚地了解转变：</p>
<pre><code class="lang-py">
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

n = <span class="hljs-number">10</span>
ps = np.logspace(-<span class="hljs-number">2.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>)
ys = [prob_connected(n, p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps]
</code></pre>
<p>这是我们看到的使用 NumPy 的第一个例子。按照惯例，我将 NumPy 导入为<code>np</code>。函数<code>logspace</code>返回从<code>10 ** -2.5</code>到<code>10 ** 0 = 1</code>的 11 个元素的数组，在对数刻度上等间隔。</p>
<p>为了计算<code>y</code>，我使用列表推导来迭代<code>ps</code>的元素，并计算出每个值为<code>p</code>的随机图的连通概率。</p>
<p>图（？）展示了结果，竖直的线为<code>p*</code>。从 0 到 1 的转变发生在预测的临界值附近。在对数刻度上，这个转变大致对称。</p>
<p>对于较大的<code>n</code>值，图（？）展示了类似的结果。随着<code>n</code>的增加，临界值越来越小，转变越来越突然。</p>
<p>这些实验与 Erdős 和 Rényi 在其论文中证明的结果一致。</p>
<h2 id="28-图的算法分析">2.8 图的算法分析</h2>
<p>这一章中，我提出了一个检查图是否连通的算法；在接下来的几章中，我们将再次看到更多的图的算法。并且我们要分析这些算法的性能，了解它们的运行时间如何随着图大小的增加而增长。</p>
<p>如果你还不熟悉算法分析，在你继续之前，你应该阅读附录一。</p>
<p>图算法的增长级别通常表示为顶点数量<code>n</code>，以及边数量<code>m</code>的函数。</p>
<p>作为一个例子，我们分析从前面的<code>reachable_nodes</code>：</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reachable_nodes</span><span class="hljs-params">(G, start)</span>:</span>
    seen = set()
    stack = [start]
    <span class="hljs-keyword">while</span> stack:
        node = stack.pop()
        <span class="hljs-keyword">if</span> node <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
            seen.add(node)
            stack.extend(G.neighbors(node))
    <span class="hljs-keyword">return</span> seen
</code></pre>
<p>每次循环，我们从栈中弹出一个节点；默认情况下，<code>pop</code>删除并返回列表的最后一个元素，这是一个常数时间的操作。</p>
<p>接下来我们检查节点是否被已访问，这是一个集合，所以检查成员是常数时间。</p>
<p>如果节点还没有访问，我们添加它是常量时间，然后将邻居添加到栈中，这相对于邻居数量是线性的。</p>
<p>为了使用<code>n</code>和<code>m</code>表达运行时间，我们可以将每个节点添加到<code>seen</code>和<code>stack</code>的总次数加起来。</p>
<p>每个节点只添加一次，所以添加的总数为<code>n</code>。</p>
<p>但是节点可能多次被添加到栈，具体取决于它们有多少邻居。如果节点具有<code>k</code>个邻居，则它会被添加到栈<code>k</code>次。当然，如果它有<code>k</code>个邻居，那意味着它拥有<code>k</code>个边。</p>
<p>所以添加到栈的总数是边的数量<code>m</code>的两倍，由于我们考虑每个边两次。</p>
<p>因此，这个函数的增长级别为<code>O(n + m)</code>，我们可以说，即运行时间与<code>n</code>或<code>m</code>成正比，以较大者为准。</p>
<p>如果我们知道<code>n</code>和<code>m</code>之间的关系，我们可以简化这个表达式。例如，在完全图中，边数是<code>n(n-1)/ 2</code>，它属于<code>O(n^2)</code>。所以对于一个完全图，<code>reachable_nodes</code>是二次于<code>n</code>的。</p>
<h2 id="29-练习">2.9 练习</h2>
<p>本章的代码在<code>chap02.ipynb</code>中，它是本书的仓库中的 Jupyter 笔记本。使用此代码的更多信息，请参阅第（？）节。</p>
<p>练习 1：启动<code>chap02.ipynb</code>并运行代码。笔记本中嵌入了一些简单的练习，你可能想尝试一下。</p>
<p>练习 2：我们分析了<code>reachable_nodes</code>的性能，并将其分类为<code>O(n + m)</code>，其中<code>n</code>是节点数，<code>m</code>是边数。继续分析，<code>is_connected</code>的增长级别是什么？</p>
<pre><code class="lang-py">
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_connected</span><span class="hljs-params">(G)</span>:</span>
    start = next(G.nodes_iter())
    reachable = reachable_nodes(G, start)
    <span class="hljs-keyword">return</span> len(reachable) == len(G)
</code></pre>
<p>练习 3 ：在我实现<code>reachable_nodes</code>时，你可能很困惑，因为向栈中添加所有邻居而不检查它们是否已访问，明显是低效的。编写一个该函数的版本，在将邻居添加到栈之前检查它们。这个“优化”是否改变了增长级别？它是否使函数更快？</p>
<blockquote>
<p>译者注：在弹出节点时将其添加到<code>seen</code>，在遍历邻居时检查它们是否已访问。</p>
</blockquote>
<p>练习 4：</p>
<p>实际上有两种 ER 图。我们在本章中生成的一种，<code>G(n，p)</code>的特征是两个参数，节点数量和节点之间的边的概率。</p>
<p>一种替代定义表示为<code>G(n，m)</code>，也以两个参数为特征：节点数<code>n</code>和边数<code>m</code>。在这个定义中，边数是固定的，但它们的位置是随机的。</p>
<p>使用这个替代定义，重复这一章的实验。这里是几个如何处理它的建议：</p>
<ol>
<li><p>编写一个名为<code>m_pairs</code>的函数，该函数接受节点列表和边数<code>m</code>，并返回随机选择的<code>m</code>个边。一个简单的方法是，生成所有可能的边的列表，并使用<code>random.sample</code>。</p>
</li>
<li><p>编写一个名为<code>make_m_graph</code>的函数，接受<code>n</code>和<code>m</code>，并返回<code>n</code>个节点和<code>m</code>个边的随机图。</p>
</li>
<li><p>创建一个<code>prob_connected</code>的版本，使用<code>make_m_graph</code>而不是<code>make_random_graph</code>。</p>
</li>
<li><p>计算一系列<code>m</code>值的连通概率。</p>
</li>
</ol>
<p>与第一类 ER 图的结果相比，该实验的结果如何？</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="1.html" class="navigation navigation-prev " aria-label="Previous page: 一、复杂性科学">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="3.html" class="navigation navigation-next " aria-label="Next page: 三、小世界图">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"二、图","level":"1.1.2","depth":2,"next":{"title":"三、小世界图","level":"1.1.3","depth":2,"path":"3.md","ref":"3.md","articles":[]},"previous":{"title":"一、复杂性科学","level":"1.1.1","depth":2,"path":"1.md","ref":"1.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"2.md","mtime":"2025-04-19T14:57:45.148Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-09T01:07:17.042Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

