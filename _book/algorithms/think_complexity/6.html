
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>六、生命游戏 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="CoderFAN 资料库 算法资料 复杂性思维">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="7.html" />
    
    
    <link rel="prev" href="5.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    复杂性思维
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="1.html">
            
                <a href="1.html">
            
                    
                    一、复杂性科学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="2.html">
            
                <a href="2.html">
            
                    
                    二、图
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="3.html">
            
                <a href="3.html">
            
                    
                    三、小世界图
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="4.html">
            
                <a href="4.html">
            
                    
                    四、无标度网络
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="5.html">
            
                <a href="5.html">
            
                    
                    五、细胞自动机
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.6" data-path="6.html">
            
                <a href="6.html">
            
                    
                    六、生命游戏
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="7.html">
            
                <a href="7.html">
            
                    
                    七、物理建模
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="8.html">
            
                <a href="8.html">
            
                    
                    八、自组织临界
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="9.html">
            
                <a href="9.html">
            
                    
                    九、基于智能体的模型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="10.html">
            
                <a href="10.html">
            
                    
                    十、兽群、鸟群和交通堵塞
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="11.html">
            
                <a href="11.html">
            
                    
                    十一、进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="12.html">
            
                <a href="12.html">
            
                    
                    十二、合作进化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="a.html">
            
                <a href="a.html">
            
                    
                    附录 A、算法分析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="b.html">
            
                <a href="b.html">
            
                    
                    附录 B、阅读列表
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >六、生命游戏</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h2 id="六、生命游戏">六、生命游戏</h2>
<blockquote>
<p>原文：<a href="http://greenteapress.com/complexity2/html/thinkcomplexity2007.html" target="_blank">Chapter 6  Game of Life</a></p>
<p>译者：<a href="https://github.com/wizardforcel" target="_blank">飞龙</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/" target="_blank">谷歌翻译</a></p>
</blockquote>
<p>在本章中，我们考虑二维细胞自动机，特别是 John Conway 的生命游戏（GoL）。 像上一章中的一些 CA 一样，GoL 遵循简单的规则并产生令人惊讶的复杂行为。 就像沃尔夫勒姆的规则 110 一样，事实证明 GoL 是通用的；也就是说，至少在理论上它可以计算任何可计算的函数。</p>
<p>GoL 的复杂行为引发了科学哲学问题，特别是科学现实主义和工具主义的相关问题。 我讨论这些问题并提出扩展阅读的建议。</p>
<p>在本章的最后，我演示了如何在 Python 中高效实现 GoL。</p>
<p>本章的代码位于本书仓库的<code>chap06.ipynb</code>中。 使用代码的更多信息，请参见第？节。</p>
<h2 id="61-conway-的生命游戏">6.1 Conway 的生命游戏</h2>
<p>首先要研究的细胞自动机之一，也许是有史以来最受欢迎的一种，是称为“生命游戏”的二维 CA，简称 GoL。 它由 John H. Conway 开发并于 1970 年在《科学美国人》（Scientific American）的马丁加德纳（Martin Gardner）专栏中推广。 请参阅 <a href="http://en.wikipedia.org/wiki/Conway_Game_of_Life" target="_blank">http://en.wikipedia.org/wiki/Conway_Game_of_Life</a>。</p>
<p>GoL 中的细胞排列在一个二维网格中，两个方向上都有限，或者首尾相接。 双向首尾相接的网格称为环面，因为它在地形上等同于多纳圈的表面。 见 <a href="http://en.wikipedia.org/wiki/Torus" target="_blank">http://en.wikipedia.org/wiki/Torus</a>。</p>
<p>每个细胞有两个状态 - 生存和死亡 - 和八个邻居 - 东西南北和四个对角线。 这些邻居有时被称为“摩尔邻域”。</p>
<p>就像前面章节中的一维 CA 一样，生命游戏按照规则演变，这就像物理学的简单定律。</p>
<p>在 GoL 中，每个单元格的下一个状态取决于其当前状态和活动邻居的数量。 如果一个细胞是活的，如果它有两个或三个活动邻居就会生存，否则就会死亡。 如果一个细胞是死的，它将保持死亡，除非它恰好有三个邻居。</p>
<p>下表总结了这些规则：</p>
<table>
<thead>
<tr>
<th>当前状态</th>
<th>邻居数量</th>
<th>下一个状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>生存</td>
<td>2–3</td>
<td>生存</td>
</tr>
<tr>
<td>生存</td>
<td>0–1, 4–8</td>
<td>死亡</td>
</tr>
<tr>
<td>死亡</td>
<td>3</td>
<td>生存</td>
</tr>
<tr>
<td>死亡</td>
<td>0–2, 4–8</td>
<td>死亡</td>
</tr>
</tbody>
</table>
<p>这种行为与真正的细胞生长大致类似：分离或过度拥挤的细胞死亡；它们在中等密度下蓬勃成长。</p>
<p>GoL 很受欢迎，因为：</p>
<p>有简单的初始条件产生令人惊讶的复杂行为。</p>
<p>有许多有趣的稳定图案：有些摆动（以不同的周期），有些像 Wolfram 的 CA 规则 110 中的飞船一样移动。
和规则 110 一样，GoL 是图灵完整的。</p>
<p>另一个产生兴趣的因素是康威的猜测 - 没有可以使活细胞数量无限增长的初始条件 - 以及他向任何可以证明或否定它的人提供的 50 美元赏金。</p>
<p>最后，计算机日益增加的可用性，使得自动化计算并以图形方式显示结果成为可能。</p>
<h2 id="62-生命图案">6.2 生命图案</h2>
<p><img src="img/6-1.png" alt=""></img></p>
<p>图 6.1：一个静态图案，叫做“蜂巢”（beehive）</p>
<p><img src="img/6-2.png" alt=""></img></p>
<p>图 6.2：一个振荡图案，叫做“蟾蜍”（toad）</p>
<p><img src="img/6-3.png" alt=""></img></p>
<p>图 6.3：一个飞船，叫做“滑翔机”（glider）</p>
<p>如果从随机起始状态运行 GoL，可能会出现一些稳定图案。随着时间的推移，人们已经确定了这些图案并给了它们名字</p>
<p>例如，图？展示了一种称为“蜂巢”的稳定图案。蜂巢中的每个细胞都有两个或三个邻居，所以它们都能存活下来，蜂巢旁边的死细胞都没有三个邻居，所以没有新细胞诞生。</p>
<p>其他图案在“振荡”；也就是说，它们随着时间而改变，但最终返回到它们的起始状态（只要它们不与另一个图案冲突）。例如，图？展示了一种称为“蟾蜍”的图案，它是在两种状态之间交替的振荡图案。这个振荡图案的“周期”是二。</p>
<p>最后，一些图案振荡并返回到起始状态，但在空间中移动。因为这些图案似乎在移动，所以它们被称为“飞船”。</p>
<p>图？展示了一艘名为“滑翔机”的飞船。经过四段时间后，滑翔机回到起始位置，并向下和向右移动一个单位。</p>
<p>根据起始方向，滑翔机可以沿着四条对角线中的任何一条移动。还有其它的水平和垂直移动的飞船。</p>
<p>人们花费了大量时间来查找和命名这些图案。如果你搜索网页，你会发现很多收藏品。</p>
<h2 id="63-conwey-的推测">6.3 Conwey 的推测</h2>
<p>从最初的条件来看，GoL 迅速达到稳定状态，活细胞数量几乎不变（可能带有一些振荡）。</p>
<p><img src="img/6-4.png" alt=""></img></p>
<p>图 6.4：r-pentomino 的开始和最终状态</p>
<p>但是一些简单的开始条件，需要很长时间才能稳定下来，并产生令人惊讶的活细胞数量。 这些模式被称为“Methuselahs”，因为它们很长寿。</p>
<p>其中最简单的是 r-pentomino，它只有五个细胞，形状大致为字母“r”。 图？显示了 r-pentomino 的初始状态和 1103 步后的最终状态。</p>
<p>这种状态是“最终的”，因为所有剩余图案是稳定的，振荡的或滑翔机，它们永远不会与另一种图案相冲突。 r-pentomino 总共产生 6 个滑翔机，8 个积木（block），4 个闪光灯（blinker），4 个蜂巢，1 个小艇（boat），1 个轮船（ship）和 1 个面包（loaf）。</p>
<p><img src="img/6-5.png" alt=""></img></p>
<p>图 6.5：Gosper 的滑翔机枪，产生滑翔机流。</p>
<p>长寿图案的存在，使得康威怀疑是否存在从未稳定的初始图案。 他猜想没有，但他描述了两种证明他是错误的图案，“枪”（gun）和“蒸汽火车”（puffer train）。 枪是稳定的模式，定期产生飞船 - 随着飞船流从源位置移动，活细胞的数量无限增长。 蒸汽火车是一种将活细胞留在尾部的平移图案。</p>
<p>事实证明，这两种模式都存在。 由 Bill Gosper 领导的一个小组发现了第一个，它是现在称为 Gosper's Gun 的滑翔枪，如图所示。 Gosper 还发现了第一个蒸汽火车。</p>
<p>这两种类型都有很多图案，但它们很难设计或找到。 这不是巧合。 Conway 选择了 GoL 的规则，这样他的猜想就不会明显为真或假。 在二维 CA 的所有可能规则中，大多数产生简单的行为：大多数初始条件快速稳定或无限增长。 通过避免无趣的 CA，Conway 也避免了 Wolfram 的一类和二类行为，并且可能还有三类。</p>
<p>如果我们相信 Wolfram 的计算等价原则，我们预计 GoL 会属于第四类，而且是这样。 生命游戏在 1982 年被证明了图灵的完整性（1983年也是独立的）。 从那时起，几个人构建了 GoL 模式，实现了图灵机或另一台已知图灵完备的机器。</p>
<h2 id="64-现实主义">6.4 现实主义</h2>
<p>GoL中的稳定模式很难不被注意，特别是那些移动的模式。 将它们视为持久的实体是很自然的事，但请记住，CA 是由细胞构成的；没有蟾蜍或面包这样的东西。 滑翔机和其他飞船甚至更不真实，因为随着时间的推移，它们甚至不由相同的细胞组成。 所以这些图案就像星座一样。 我们这样看待他们，因为我们善于观察图案，或者因为我们有活跃的想象力，但他们不是真实的。</p>
<p>对嘛？</p>
<p>好吧，不是那样。 我们认为“真实”的许多实体，也是规模较小的实体的持久图案。 飓风只是气流的模式，但我们给了他们个人名称。 而人就像滑翔机，随着时间的推移不是由相同细胞组成的。 但即使你更换了你体内的每一个细胞，我们也认为你是同一个人。</p>
<p>这不是一个新观察 - 大约在 2500 年前，赫拉克利特（Heraclitus）指出你不能在同一条河流中两次 - 但是出现在生命游戏中的实体，是思考哲学现实主义的实用测试用例。</p>
<p>在哲学的背景下，现实主义是这样一种观点，即世界中的实体存在与人类的感知和概念无关。 “感知”是指我们从感官中获得的信息，而“概念”是指我们形成的世界的心智模式。 例如，我们的视觉系统将一些东西感知为场景的二维投影，我们的大脑使用该图像构建场景中物体的三维模型。</p>
<p>科学实在论与科学理论和他们所假设的实体有关。 如果一个理论使用实体的属性和行为来表达，那么这个理论假设了一个实体。 例如，电磁学的理论用电场和磁场表示。 经济学的一些理论以供给，需求和市场力量来表达。 生物学的理论是用基因来表达的。</p>
<p>但这些实体是真实的吗？ 也就是说，它们存在于独立于我们和我们的理论的世界吗？</p>
<p>再次，我发现，在一系列强度中陈述哲学立场是有用的；这里有四个科学现实主义的陈述，强度逐渐增加：</p>
<p>SR1：</p>
<p>对于它们接近现实的程度，科学理论为真或假，但没有理论是完全正确的。 一些所假设的实体可能是真实的，但没有原则性的方式来说出哪些是真实的。</p>
<p>SR2：</p>
<p>随着科学的进步，我们的理论会变得更加逼近现实。 至少有一些所假定的实体是已知真实的。</p>
<p>SR3：</p>
<p>有些理论是完全正确的；其他近似真实。 真实理论所假设的实体，以及近似真实理论中的一些实体是真实的。</p>
<p>SR4：</p>
<p>如果一个理论正确地描述了现实，那么这个理论就是真的，否则就是假。真实理论所假设的实体是真实的；其他不是。</p>
<p>SR4 非常强，可能是站不住脚的；通过这样一个严格的标准，几乎所有当前的理论都被认为是错误的。 大多数现实主义者会接受 SR1 和 SR3 之间的东西。</p>
<h2 id="65-工具主义">6.5 工具主义</h2>
<p>但 SR1 很弱以至于它接近工具主义，这是一种观点，我们不能说理论是真是假，因为我们不知道理论是否符合现实。 理论是我们用于我们的目的的工具；在适用于其目的的程度上，理论是有用的，或者不是。</p>
<p>要看看你是否对工具主义感到满意，请考虑以下陈述：</p>
<p>“生命游戏中的实体并不是真实的；他们只是人们赋予可爱的名字的细胞图案。”</p>
<p>“飓风只是一种气流模式，但它是一种有用的描述，因为它可以让我们进行有关天气的预测和沟通。”</p>
<p>“像本我和超我这样的弗洛伊德实体并不是真实的，但它们是思考和交流心理学的有用工具（或者至少有些人是这么认为的）。”</p>
<p>“电磁场是我们最好的电磁理论中的假设实体，但它们并不真实。 我们可以构建其他理论，而不用场的假设，这也是一样有用的。”</p>
<p>“我们认为，世界上的许多物体都是像星座一样的任意集合。 例如，蘑菇只是真菌的子实体，其中大部分是在地下生长的，几乎不连续的细胞网络。 我们由于实际原因专注于蘑菇，如可见性和可爱。”</p>
<p>“有些物体边界清晰，但很多都是模糊的。 例如，哪些分子是你身体的一部分：你的肺里的空气？ 你的胃里的食物？ 你血液中的营养物质？ 细胞中的营养物质？ 细胞中的水？ 细胞的结构部分？ 头发？ 死皮？ 污垢？ 你的皮肤上的细菌？ 你的肠道细菌？线粒体？ 当你称量自己时，你包含了多少这些分子？ 根据离散对象构想世界是有用的，但我们确定的实体并不是真实的。”</p>
<p>对于每一个你同意的陈述，给自己一分。 如果你的分数超过 4 分，你可能会成为一名工具主义者！</p>
<p>如果你比其他人更喜欢这些陈述，那么问问你自己为什么。 这些情景中的哪些差异会影响你的反应？ 你能否在他们之间做出原则性区分？</p>
<p>工具主义的更多信息，请参阅 <a href="http://en.wikipedia.org/wiki/Instrumentalism" target="_blank">http://en.wikipedia.org/wiki/Instrumentalism</a>。</p>
<h2 id="66-实现">6.6 实现</h2>
<p>本章最后的练习要求你尝试和修改生命游戏，并实现其他二维细胞自动机。 本节介绍 GoL 的实现，你可以将其用作实验的起始位置。</p>
<p>为了表示细胞的状态，我使用类型为<code>uint8</code>的 NumPy 数组，它是一个 8 位无符号整数。 例如，下面这行创建一个 10 乘 10 的数组，并用 0 和 1 的随机值进行初始化。</p>
<pre><code class="lang-py">a = np.random.randint(<span class="hljs-number">2</span>, size=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)).astype(np.uint8)
</code></pre>
<p>我们可以用几种方法计算 GoL 规则。 最简单的方法是使用<code>for</code>循环遍历数组的行和列：</p>
<pre><code class="lang-py">
b = np.zeros_like(a)
rows, cols = a.shape
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, rows-<span class="hljs-number">1</span>):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, cols-<span class="hljs-number">1</span>):
        state = a[i, j]
        neighbors = a[i-<span class="hljs-number">1</span>:i+<span class="hljs-number">2</span>, j-<span class="hljs-number">1</span>:j+<span class="hljs-number">2</span>]
        k = np.sum(neighbors) - state
        <span class="hljs-keyword">if</span> state:
            <span class="hljs-keyword">if</span> k==<span class="hljs-number">2</span> <span class="hljs-keyword">or</span> k==<span class="hljs-number">3</span>:
                b[i, j] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">if</span> k == <span class="hljs-number">3</span>:
                b[i, j] = <span class="hljs-number">1</span>
</code></pre>
<p>最初，<code>b</code>是一个与<code>a</code>大小相同的零数组。 每次循环中，状态是中心细胞的条件，邻居是<code>3×3</code>的邻域。 <code>k</code>是活动邻居的数量（不包括中心细胞）。 嵌套的<code>if</code>语句评估 GoL 规则并相应地激活<code>b</code>中的细胞。</p>
<p>这个实现是规则的直接翻译，但它是冗长而缓慢的。 我们可以使用互相关做得更好，正如我们在第？节中看到的那样。 在那里，我们使用<code>np.correlate</code>来计算一维相关。 现在，为了计算二维相关，我们将使用<code>scipy.signal</code>中的<code>correlate2d</code>，它是一个 SciPy 模块，提供信号处理的相关函数：</p>
<pre><code class="lang-py">
<span class="hljs-keyword">from</span> scipy.signal <span class="hljs-keyword">import</span> correlate2d

kernel = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
                   [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
                   [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]])

c = correlate2d(a, kernel, mode=<span class="hljs-string">'same'</span>)
</code></pre>
<p>在一维相关的背景下，我们称之为“窗口”的内容，在二维相关的背景下被称为“核”，但其想法是相同的：<code>correlate2d</code>将核和数组相乘来选择一个邻域，然后将结果加起来。 这会核选择中心细胞周围的 8 个邻居。</p>
<p><code>correlate2d</code>将核应用于数组中的每个位置。 使用<code>mode ='same'</code>时，结果与<code>a</code>的大小相同。</p>
<p>现在我们可以使用逻辑运算符来计算规则：</p>
<pre><code class="lang-py">
b = (c==<span class="hljs-number">3</span>) | (c==<span class="hljs-number">2</span>) &amp; a
b = b.astype(np.uint8)
</code></pre>
<p>第一行计算了一个布尔数组，其中应该有活细胞的地方为<code>True</code>，其他地方为<code>False</code>。 然后，<code>astype</code>将布尔数组转换为整数数组。</p>
<p>这个版本更快，也许够好，但是我们可以通过修改核来简化它：</p>
<pre><code class="lang-py">kernel = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
                   [<span class="hljs-number">1</span>,<span class="hljs-number">10</span>, <span class="hljs-number">1</span>],
                   [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]])

c = correlate2d(a, kernel, mode=<span class="hljs-string">'same'</span>)
b = (c==<span class="hljs-number">3</span>) | (c==<span class="hljs-number">12</span>) | (c==<span class="hljs-number">13</span>)
b = b.astype(np.uint8)
</code></pre>
<p>这个版本核的包含中心单元并赋予其权重 10。如果中心单元为 0，则结果介于 0 和 8 之间; 如果中心单元为 1，则结果在 10 到 18 之间。使用这个核，我们可以简化逻辑运算，只选择值为 3，12 和 13 的细胞。</p>
<p>这看起来可能不是什么大的改进，但它允许进一步简化：使用这个核，我们可以使用一个表来查找细胞的值，就像我们在第？节中所做的那样。</p>
<pre><code class="lang-py">
table = np.zeros(<span class="hljs-number">20</span>, dtype=np.uint8)
table[[<span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>]] = <span class="hljs-number">1</span>
c = correlate2d(a, kernel, mode=<span class="hljs-string">'same'</span>)
b = table[c]
</code></pre>
<p>除了位置 3，12 和 13 以外，表格中的任何位置都为零。当我们使用<code>c</code>作为表格中的索引时，NumPy 执行逐元素查找；也就是说，它从<code>c</code>中获取每个值，在表中查找它并将结果放入<code>b</code>中。</p>
<p>这个版本比其他版本更快更简洁， 唯一的缺点是需要更多的解释。</p>
<p>包含在本书仓库中的<code>Life.py</code>提供了一个封装规则实现的<code>Life</code>类。 如果你执行<code>Life.py</code>，你应该看到一个“蒸汽火车”的动画，这是一种飞船，在其尾部留下一串碎屑。</p>
<h2 id="67-练习">6.7 练习</h2>
<p>练习 1</p>
<p>本章的代码位于本书仓库的 Jupyter 笔记本<code>chap06.ipynb</code>中。 打开这个笔记本，阅读代码，然后运行单元格。 你可以使用这个笔记本来练习本章的练习。 我的解决方案在<code>chap06soln.ipynb</code>中。</p>
<p>练习 2</p>
<p>以随机状态启动 GoL 并运行它直至稳定。 你可以识别哪些稳定的图案？</p>
<p>练习 3</p>
<p>许多命名图案都以便携式文件格式提供。 修改<code>Life.py</code>来解析其中一种格式并初始化网格。</p>
<p>练习 4</p>
<p>一种最长寿的小型图案是“兔子”，它以 9 个活动细胞开始，需要 17 331 个步骤来稳定。 你可以在 <a href="http://www.conwaylife.com/wiki/Rabbits" target="_blank">http://www.conwaylife.com/wiki/Rabbits</a> 获取各种格式的初始状态。 加载此状态并运行它。</p>
<p>练习 5</p>
<p>在我的实现中，<code>Life</code>类基于一个名为<code>Cell2D</code>的父类，<code>LifeViewer</code>基于<code>Cell2DViewer</code>。 你可以使用这些基类来实现其他二维细胞自动机。</p>
<p>例如，GoL 的一个变体叫做“Highlife”，与 GoL 规则相同，另外还有一条规则：有 6 个邻居的死亡细胞会变活。</p>
<p>编写一个名为<code>Highlife</code>的类，该类继承自<code>Cell2D</code>并实现这个版本的规则。 另外编写一个名为<code>HighlifeViewer</code>的类，该类继承自<code>Cell2DViewer</code>并尝试以不同的方式来展示结果。 作为一个简单的例子，使用不同的颜色表。</p>
<p><code>Highlife</code>中更有趣的图案之一是复制器（replicator）。 使用<code>add_cells</code>和复制器初始化<code>Highlife</code>并查看它做了什么。</p>
<p>练习 6</p>
<p>如果将图灵机扩展到两个维度，或者将读写头添加到二维 CA，则结果是称为 Turmite 的细胞自动机。由于读写头移动的方式，它以白蚁（termite）命名，但拼写错误是对 Alan Turing 的敬意。</p>
<p>最着名的 Turmite 是 1986 年由 Chris Langton 发现的兰顿的蚂蚁（Langton's Ant）。请见 <a href="http://en.wikipedia.org/wiki/Langton_ant" target="_blank">http://en.wikipedia.org/wiki/Langton_ant</a>。</p>
<p>蚂蚁（ant）是一个具有四种状态的读写头，你可以将其视为面向东、西、南或北。细胞有两种状态，黑色和白色。</p>
<p>规则很简单。在每个时间步骤中，蚂蚁检查它所在单元格的颜色。如果是黑色，蚂蚁转向右转，将细胞变成白色，并向前移动一个格子。如果细胞是白色的，蚂蚁会向左转，将细胞变成黑色，然后向前移动。</p>
<p>给定一个简单的世界，一组简单的规则，并且只有一个可移动的部分，你可能会期望看到简单的行为 - 但你现在应该更清楚。从所有的白色细胞开始，在进入周期为 104 步的循环之前，兰顿的蚂蚁以看似随机的方式移动超过 10000 步。每个循环后，蚂蚁都会沿对角线平移，因此会留下一条称为“高速路”的踪迹。</p>
<p>编写兰顿的蚂蚁的实现。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="5.html" class="navigation navigation-prev " aria-label="Previous page: 五、细胞自动机">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="7.html" class="navigation navigation-next " aria-label="Next page: 七、物理建模">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"CoderFAN 资料库 算法资料 复杂性思维","title":"六、生命游戏","level":"1.1.6","depth":2,"next":{"title":"七、物理建模","level":"1.1.7","depth":2,"path":"7.md","ref":"7.md","articles":[]},"previous":{"title":"五、细胞自动机","level":"1.1.5","depth":2,"path":"5.md","ref":"5.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*","description":"CoderFAN 资料库 算法资料 复杂性思维"},"file":{"path":"6.md","mtime":"2025-05-12T03:21:13.339Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-12T03:24:01.935Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

