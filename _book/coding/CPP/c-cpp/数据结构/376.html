
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>迪克斯特拉算法 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="375.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    数据结构
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="343.html">
            
                <a href="343.html">
            
                    
                    数据结构和算法基础知识
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="344.html">
            
                <a href="344.html">
            
                    
                    数据结构和算法导论
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="345.html">
            
                <a href="345.html">
            
                    
                    渐近符号
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="346.html">
            
                <a href="346.html">
            
                    
                    算法的空间复杂度
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="347.html">
            
                <a href="347.html">
            
                    
                    算法的时间复杂度
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="348.html">
            
                <a href="348.html">
            
                    
                    基本算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="349.html">
            
                <a href="349.html">
            
                    
                    搜索算法简介
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="350.html">
            
                <a href="350.html">
            
                    
                    线性搜索算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="351.html">
            
                <a href="351.html">
            
                    
                    二分搜索算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="352.html">
            
                <a href="352.html">
            
                    
                    排序介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="353.html">
            
                <a href="353.html">
            
                    
                    冒泡排序算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="354.html">
            
                <a href="354.html">
            
                    
                    插入排序算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="355.html">
            
                <a href="355.html">
            
                    
                    选择排序算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="356.html">
            
                <a href="356.html">
            
                    
                    快速排序算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.15" data-path="357.html">
            
                <a href="357.html">
            
                    
                    归并排序算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.16" data-path="358.html">
            
                <a href="358.html">
            
                    
                    堆排序算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.17" data-path="359.html">
            
                <a href="359.html">
            
                    
                    数据结构
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.18" data-path="360.html">
            
                <a href="360.html">
            
                    
                    什么是栈数据结构？
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.19" data-path="361.html">
            
                <a href="361.html">
            
                    
                    什么是队列数据结构？
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.20" data-path="362.html">
            
                <a href="362.html">
            
                    
                    使用栈实现队列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.21" data-path="363.html">
            
                <a href="363.html">
            
                    
                    链表介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.22" data-path="364.html">
            
                <a href="364.html">
            
                    
                    线性链表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.23" data-path="365.html">
            
                <a href="365.html">
            
                    
                    循环链表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.24" data-path="366.html">
            
                <a href="366.html">
            
                    
                    双端队列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.25" data-path="367.html">
            
                <a href="367.html">
            
                    
                    使用队列实现栈
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.26" data-path="368.html">
            
                <a href="368.html">
            
                    
                    使用链表实现栈
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.27" data-path="369.html">
            
                <a href="369.html">
            
                    
                    双向链表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.28" data-path="370.html">
            
                <a href="370.html">
            
                    
                    二叉树介绍
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.29" data-path="371.html">
            
                <a href="371.html">
            
                    
                    二叉查找树
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.30" data-path="372.html">
            
                <a href="372.html">
            
                    
                    贪心算法或技巧
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.31" data-path="373.html">
            
                <a href="373.html">
            
                    
                    活动选择问题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.32" data-path="374.html">
            
                <a href="374.html">
            
                    
                    Prim 最小生成树
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.33" data-path="375.html">
            
                <a href="375.html">
            
                    
                    霍夫曼编码算法
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.34" data-path="376.html">
            
                <a href="376.html">
            
                    
                    迪克斯特拉算法
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >迪克斯特拉算法</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="迪克斯特拉算法">迪克斯特拉算法</h1>
<blockquote>
<p>原文：<a href="https://www.studytonight.com/data-structures/dijkstras-algorithm" target="_blank">https://www.studytonight.com/data-structures/dijkstras-algorithm</a></p>
</blockquote>
<p>迪杰斯特拉的算法发表于 1959 年，以其发现者埃德格·迪杰斯特拉的名字命名，他是一名荷兰计算机科学家。该算法旨在寻找具有非负边权重的有向或无向图中的最短路径。</p>
<p>在我们研究这个算法的细节之前，让我们先简单了解一下以下内容:</p>
<ul>
<li><strong>图</strong>:图是定义为 G=(V，E)的非线性数据结构，其中 V 是顶点的有限集合，E 是边的有限集合，使得每条边都是连接任意两个顶点的直线或圆弧。</li>
<li><strong>加权图</strong>:这是一种特殊类型的图，其中每条边都被赋予一个数值，称为权重</li>
<li><strong>连通图</strong>:这类图中每对顶点之间都存在一条路径</li>
<li><strong>图 G 的生成树</strong>是一个子图 G ’,它包括 G 的所有顶点，这些顶点与最小数量的边相连。因此，对于具有 n 个顶点的图 G，生成树 G’将具有 n 个顶点和最大 n-1 条边。</li>
</ul>
<hr></hr>
<h3 id="问题陈述">问题陈述</h3>
<p>给定一个加权图 G，目标是找到从给定源顶点到 G 的所有其他顶点的最短路径。该图具有以下特征-</p>
<ul>
<li>顶点集<code>V</code></li>
<li>加权边组<code>E</code>，使得<code>(q,r)</code>表示<strong>顶点</strong> q 和 r 之间的<strong>边</strong>，成本(q，r)表示其权重</li>
</ul>
<h3 id="迪克斯特拉算法">迪克斯特拉算法:</h3>
<ul>
<li>这是一种单源最短路径算法，旨在找到给定问题陈述的解决方案</li>
<li>该算法适用于有向图和无向图</li>
<li>它只适用于连通图</li>
<li>该图不应包含负边权重</li>
<li>该算法主要遵循贪心方法寻找局部最优解。但是，它也使用动态规划方法来构建全局最优解，因为先前的解被存储并进一步添加，以获得到源顶点的最终距离</li>
<li>该算法的主要逻辑基于以下公式-
<code>dist[r]=min(dist[r], dist[q]+cost[q][r])</code></li>
</ul>
<p>该公式规定，当且仅当<code>dist[q]+cost[q][r] is less than dist[r]</code>的值为时，与顶点 q 相邻的距离顶点 r 将被更新。这里</p>
<ul>
<li>dist 是一个一维数组，它在每一步跟踪从源顶点到所有其他顶点的最短距离，并且</li>
<li>成本是一个二维数组，表示图的成本邻接矩阵</li>
<li>这个公式同时使用了贪心和动态方法。贪心方法用于寻找最小距离值，而动态方法用于组合先前的解( <strong>dist[q]</strong> 已经被计算并用于计算 <strong>dist[r]</strong> )</li>
</ul>
<h3 id="算法-">算法-</h3>
<p><strong>Input Data-</strong></p>
<ul>
<li>图 G 的成本邻接矩阵，比如成本</li>
<li>源顶点，比如 s</li>
</ul>
<p><strong>Output Data-</strong></p>
<ul>
<li>从 s 到 G 中所有其他顶点的最短路径的生成树</li>
</ul>
<h3 id="以下是寻找解决方案的步骤-">以下是寻找解决方案的步骤-</h3>
<p><strong>第一步</strong>；Set dist[s]=0，S=ϕ // s 是源顶点，s 是包含所有访问顶点的一维数组</p>
<p><strong>第二步</strong>:对于除 s 之外的所有节点 v，设置 dist[v]= ∞</p>
<p><strong>第三步</strong>:找到 q 不在 S，这样 dist[q]最小//顶点 q 不应该被访问</p>
<p><strong>步骤 4</strong> :将 q 添加到 S //将顶点 q 添加到 S，因为它现在已经被访问过了</p>
<p><strong>第 5 步</strong>:更新与 q 相邻的所有 r 的距离【r】，使得 r 不在 S 中//不应访问顶点 r <code>dist[r]=min(dist[r], dist[q]+cost[q][r])</code> //贪心和动态方法</p>
<p><strong>第 6 步</strong>:重复第 3 步到第 5 步，直到所有节点都在 S //中，重复，直到所有顶点都被访问过</p>
<p><strong>第 7 步</strong>:打印从源顶点 u 到所有其他顶点的最短路径的数组距离</p>
<p><strong>第 8 步</strong>:退出</p>
<h3 id="让我们试着用下面的例子来理解这个算法的工作原理">让我们试着用下面的例子来理解这个算法的工作原理</h3>
<p><img src="img/ab6ae9c34df9e8bede832ff861101a7c.png" alt="weight graph"></img>图 1:输入图(加权和连通)</p>
<p>给定上述加权连通图和源顶点 s，以下步骤用于寻找表示 s 和所有其他顶点之间最短路径的树-</p>
<p><strong>步骤 A</strong> -使用以下算法步骤初始化距离数组–</p>
<ul>
<li><p><strong>步骤 1</strong> -设置 dist[s]=0，S=ϕ // u 是源顶点，s 是具有所有访问顶点的一维数组</p>
</li>
<li><p><strong>步骤 2</strong> -对于除 s 之外的所有节点 v，设置 dist[v]=∠</p>
</li>
</ul>
<p>| 访问顶点集 | S | A | B | C | D |
|  | Zero | ∞ | ∞ | ∞ | ∞ |</p>
<p><img src="img/edd3346bd6e65740ca720d1fe7b64cd1.png" alt="graph "></img>图 2:初始化 dist[]后的图形</p>
<p><strong>步骤 B</strong> - a)选择源顶点 s，因为距离[s]最小，s 不在 s 中</p>
<p><strong>第 3 步</strong> -发现 q 不在 S 中，这样 dist[q]最小//不应访问顶点</p>
<p><strong>通过将其添加到 S</strong> 来访问 S</p>
<p><strong>步骤 4</strong> -将 q 添加到 S //将顶点 q 添加到 S，因为它现在已经被访问过了</p>
<p><strong>步骤 c)</strong> 对于所有尚未被访问(不在 S 中)的 S 的相邻顶点，即 A 和 C，使用以下算法步骤更新距离数组-</p>
<p><strong>第 5 步</strong> -更新与 q 相邻的所有 r 的距离【r】，使得 r 不在 S 中//不应访问顶点 r <code>dist[r]=min(dist[r], dist[q]+cost[q][r])</code> //贪心和动态方法</p>
<p><code>dist[A]= min(dist[A], dist[s]+cost(s, A)) = min(∞, 0+9) = 9</code>
<code>dist[C] = min(dist[C], dist[s]+cost(s, C)) = min(∞, 0+5) = 5</code></p>
<p><strong>因此 dist[]更新如下-</strong></p>
<p>| 访问顶点集 | S | A | B | C | D |
| [s] | Zero | nine | ∞ | five | ∞ |</p>
<p><strong>步骤 C</strong> -重复步骤 B</p>
<ol>
<li>选择并访问顶点 C，因为它没有被访问过(不在 S 中)，距离[C]是最小的</li>
<li>更新 C 的相邻顶点(即 A、B 和 D)的距离数组</li>
</ol>
<p><strong>第 6 步</strong> -重复第 3 步到第 5 步，直到所有节点都在 S</p>
<p><code>dist[A]=min(dist[A], dist[C]+cost(C,A)) = min(9, 5+2)= 7</code></p>
<p><code>dist[B]= min(dist[B], dist[C]+cost(C,B)) = min(∞, 5+9)= 14</code></p>
<p><code>dist[D]= min(dist[D], dist[C]+cost(C,D))= min((∞,5+4)=9</code></p>
<p><strong>这将更新 dist[]如下-</strong></p>
<p>| 访问顶点集 | S | A | B | C | D |
| [s] | Zero | nine | ∞ | five | ∞ |
| [南、北] | Zero | seven | Fourteen | five | nine |</p>
<p>继续类似的路线，重复步骤 B，直到所有的顶点都被访问(添加到 S)。<code>dist[]</code>也会在每次迭代中更新，结果如下–</p>
<p>| 访问顶点集 | S | A | B | C | D |
| [s] | Zero | nine | ∞ | five | ∞ |
| [南、北] | Zero | seven | Fourteen | five | nine |
| [南、中、北] | Zero | seven | eight | five | nine |
| [南、中、南、北] | Zero | seven | eight | five | nine |
| [南、中、北、南] | Zero | seven | eight | five | nine |</p>
<p>dist[]的最后一次更新给出了从 s 到所有其他顶点的最短路径值</p>
<p><strong>给定图的合成最短路径生成树如下-</strong></p>
<p><img src="img/3b671028a1e83561de054b08a21a5bc4.png" alt="shortest path"></img>图 3:最短路径生成树</p>
<p><strong>Note-</strong></p>
<ul>
<li>取决于源顶点，同一图可以有多个最短路径生成树</li>
</ul>
<p><strong>Implementation-</strong></p>
<p>下面是迪克斯特拉算法的 C++ 实现</p>
<p><strong>注:</strong>
算法可以根据需要映射到任意编程语言。</p>
<pre><code class="lang-cpp">     <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> V <span class="hljs-number">5</span>  <span class="hljs-comment">//Defines total number of vertices in the graph</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> INFINITY <span class="hljs-number">999</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min_Dist</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dist[], <span class="hljs-keyword">bool</span> visited[])</span>   
<span class="hljs-comment">//This method used to find the vertex with minimum distance and is not yet visited</span>
</span>{
    <span class="hljs-keyword">int</span> min=INFINITY,index;                 <span class="hljs-comment">//Initialize min with infinity</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v=<span class="hljs-number">1</span>;v&lt;=V;v++)
    {
        <span class="hljs-keyword">if</span>(visited[v]==<span class="hljs-literal">false</span> &amp;&amp;dist[v]&lt;=min)      
        {
            min=dist[v];
            index=v;
        }
    }
    <span class="hljs-keyword">return</span> index;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cost[V][V],<span class="hljs-keyword">int</span> src)</span> <span class="hljs-comment">//Method to implement shortest path algorithm</span>
</span>{
    <span class="hljs-keyword">int</span> dist[V];                             
    <span class="hljs-keyword">bool</span> visited[V];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=V;i++)                    <span class="hljs-comment">//Initialize dist[] and visited[] </span>
    {
        dist[i]=INFINITY;
        visited[i]=<span class="hljs-literal">false</span>;    
    }
    <span class="hljs-comment">//Initialize distance of the source vertec to zero</span>
    dist[src]=<span class="hljs-number">0</span>;                                   
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c=<span class="hljs-number">2</span>;c&lt;=V;c++)                           
    {
        <span class="hljs-comment">//u is the vertex that is not yet included in visited and is having minimum </span>
        <span class="hljs-keyword">int</span> u=min_Dist(dist,visited);            distance
        visited[u]=<span class="hljs-literal">true</span>;                          <span class="hljs-comment">//vertex u is now visited </span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v=<span class="hljs-number">1</span>;v&lt;=V;v++)                    
<span class="hljs-comment">//Update dist[v] for vertex v which is not yet included in visited[] and</span>
<span class="hljs-comment">//there is a path from src to v through u that has smaller distance than</span>
<span class="hljs-comment">// current value of dist[v]</span>
        {
            <span class="hljs-keyword">if</span>(!visited[v] &amp;&amp; cost[u][v] &amp;&amp;dist[u]+cost[u][v]&lt;dist[v])
            dist[v]=dist[u]+cost[u][v];
        }
    }
     <span class="hljs-comment">//will print the vertex with their distance from the source</span>
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"The shortest path  "</span>&lt;&lt;src&lt;&lt;<span class="hljs-string">" to all the other vertices is: \n"</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=V;i++)                      
    {
       <span class="hljs-keyword">if</span>(i!=src)
       <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"source:"</span>&lt;&lt;src&lt;&lt;<span class="hljs-string">"\t destination:"</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">"\t MinCost is:"</span>&lt;&lt;dist[i]&lt;&lt;<span class="hljs-string">"\n"</span>;
    }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> cost[V][V], i,j, s;
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"\n Enter the cost matrix weights"</span>;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=V;i++)      <span class="hljs-comment">//Indexing ranges from 1 to n</span>
          <span class="hljs-keyword">for</span>(j=<span class="hljs-number">1</span>;j&lt;=V;j++)
          {
<span class="hljs-built_in">cin</span>&gt;&gt;cost[i][j];
            <span class="hljs-comment">//Absence of edge between vertices i and j is represented by INFINITY</span>
             <span class="hljs-keyword">if</span>(cost[i][j]==<span class="hljs-number">0</span>)     
               cost[i][j]=INFINITY;    
           }
<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"\n Enter the Source Vertex"</span>; 
<span class="hljs-built_in">cin</span>&gt;&gt;s;

    Dijkstra(cost,s);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    
}
</code></pre>
<p>该程序使用与图 1 中相同的输入图来执行。这将有助于用实际输出来验证结果解集。</p>
<p><img src="img/b5cb10b3a43117a7a88ac3b8497f5eb2.png" alt="Output of program"></img>图 4:输出</p>
<h3 id="时间复杂度分析-">时间复杂度分析-</h3>
<p>以下是计算迪克斯特拉算法时间复杂度的例子</p>
<ul>
<li><strong>案例 1</strong> -当图 G 使用邻接矩阵表示时-这个场景在上面的 <strong>C++</strong> 基础程序中实现。由于实现包含两个嵌套的 for 循环，每个循环的复杂度为 <strong>O(n)</strong> ，因此迪克斯特拉算法的复杂度为 <strong>O(n2)</strong> 。请注意，这里的 n 指的是给定图中的顶点总数</li>
<li><strong>情况 2</strong> -当使用邻接表表示图 G 时-时间复杂度，在这种情况下降低到 <strong>O(|E| + |V| log |V|)</strong> 其中|E|表示图中的边数，|V|表示图中的顶点数</li>
</ul>
<h3 id="迪克斯特拉算法的缺点-">迪克斯特拉算法的缺点-</h3>
<p>迪克斯特拉算法不能获得正确的具有负边的加权图的最短路径。让我们考虑下面的例子来解释这个场景-</p>
<p><img src="img/8b36b4296bceeded0beed84b0398cc24.png" alt="disadvantages of algorithm"></img>图 5:负边加权图</p>
<p>选择源顶点为 A，算法工作如下-</p>
<p><strong>步骤 A</strong> -初始化距离数组(dist)-</p>
<p>| 访问顶点集 | A | B | C | D |
|  | Zero | ∞ | ∞ | ∞ |</p>
<p><strong>步骤 B</strong> -选择顶点 A，因为<code>dist[A]</code>是最小值，A 不在 S 中。访问 A 并将其添加到 S 中。对于 A 的所有尚未访问(不在 S 中)的相邻顶点，即 C、B 和 D，更新距离数组</p>
<p><code>dist[C]= min(dist[C], dist[A]+cost(A, C)) = min(∞, 0+0) = 0</code></p>
<p><code>dist[B] = min(dist[B], dist[A]+cost(A, B)) = min(∞, 0+1) = 1</code></p>
<p><code>dist[D]= min(dist[D], dist[A]+cost(A, D)) = min(∞, 0+99) = 99</code></p>
<p><strong>因此 dist[]更新如下-</strong></p>
<p>| 访问顶点集 | A | B | C | D |
| [答] | Zero | one | Zero | Ninety-nine |</p>
<p><strong>步骤 C</strong> -重复步骤 B</p>
<ol>
<li>选择并访问顶点 C，因为它没有被访问过(不在 S 中)，距离[C]是最小的</li>
<li>距离数组不会更新，因为 C 没有相邻的顶点</li>
</ol>
<p>| 访问顶点集 | A | B | C | D |
| [答] | Zero | one | Zero | Ninety-nine |
| [甲、丙] | Zero | one | Zero | Ninety-nine |</p>
<p>继续类似的路线，重复步骤 B，直到所有的顶点都被访问(添加到 S)。<code>dist[]</code>也会在每次迭代中更新，结果如下–</p>
<p>| 访问顶点集 | A | B | C | D |
| [答] | Zero | one | Zero | Ninety-nine |
| [甲、丙] | Zero | one | Zero | Ninety-nine |
| [甲、丙、乙] | Zero | one | Zero | Ninety-nine |
| [甲、丙、乙、丁] | Zero | one | Zero | Ninety-nine |</p>
<p><strong>因此，以下是从 A 到 B、C 和 D 的最短距离-</strong></p>
<p><code>A-&gt;C = 0</code> <code>A-&gt;B = 1</code> <code>A-&gt;D = 99</code></p>
<p>但是这些值是不正确的，因为我们可以有另一条路径从 <strong>A</strong> 到 <strong>C，A- &gt; D- &gt; B- &gt; C</strong> 有<strong>总成本= -200</strong> 小于 0。发生这种情况是因为一旦访问了一个顶点并将其添加到集合 S 中，它就再也不会“回头”了。因此，迪克斯特拉的算法并不试图找到一条更短的路径到达已经被添加到 s 的顶点。</p>
<ul>
<li>它执行盲搜索来寻找最短路径，因此，消耗大量时间并浪费其他资源</li>
</ul>
<h3 id="迪克斯特拉算法的应用">迪克斯特拉算法的应用</h3>
<ul>
<li>交通信息系统使用迪克斯特拉算法从给定的源位置跟踪目的地</li>
<li><strong>开源路径优先(OSPF)</strong> 是一种基于互联网的路由协议，使用 Dijkstra 算法来寻找从源路由器到网络中其他路由器的最佳路由</li>
<li>它被<strong>电话和蜂窝网络</strong>用于路由管理</li>
<li>它也被<strong>地理信息系统(GIS)</strong> 使用，例如谷歌映射，用于寻找从 A 点到 B 点的最短路径</li>
</ul>
<hr></hr>
<hr></hr>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="375.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: 霍夫曼编码算法">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"迪克斯特拉算法","level":"1.1.34","depth":2,"previous":{"title":"霍夫曼编码算法","level":"1.1.33","depth":2,"path":"375.md","ref":"375.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"376.md","mtime":"2025-04-30T01:08:58.899Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:24:10.684Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

