
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>十七、更新预测 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="计算与推断思维">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="16.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    计算与推断思维
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="READ_ME.html">
            
                <a href="READ_ME.html">
            
                    
                    计算与推断思维
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="1.html">
            
                <a href="1.html">
            
                    
                    一、数据科学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="2.html">
            
                <a href="2.html">
            
                    
                    二、因果和实验
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="3.html">
            
                <a href="3.html">
            
                    
                    三、Python 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="4.html">
            
                <a href="4.html">
            
                    
                    四、数据类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="5.html">
            
                <a href="5.html">
            
                    
                    五、表格
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="6.html">
            
                <a href="6.html">
            
                    
                    六、可视化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="7.html">
            
                <a href="7.html">
            
                    
                    七、函数和表格
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="8.html">
            
                <a href="8.html">
            
                    
                    八、随机性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="9.html">
            
                <a href="9.html">
            
                    
                    九、经验分布
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="10.html">
            
                <a href="10.html">
            
                    
                    十、假设检验
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="11.html">
            
                <a href="11.html">
            
                    
                    十一、估计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="12.html">
            
                <a href="12.html">
            
                    
                    十二、为什么均值重要
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="13.html">
            
                <a href="13.html">
            
                    
                    十三、预测
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.15" data-path="14.html">
            
                <a href="14.html">
            
                    
                    十四、回归的推断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.16" data-path="15.html">
            
                <a href="15.html">
            
                    
                    十五、分类
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.17" data-path="16.html">
            
                <a href="16.html">
            
                    
                    十六、比较两个样本
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.18" data-path="17.html">
            
                <a href="17.html">
            
                    
                    十七、更新预测
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >十七、更新预测</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h2 id="十七、更新预测">十七、更新预测</h2>
<blockquote>
<p>原文：<a href="https://github.com/data-8/textbook/tree/gh-pages/chapters/17" target="_blank">Updating Predictions</a></p>
<p>译者：<a href="https://github.com/wizardforcel" target="_blank">飞龙</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/" target="_blank">谷歌翻译</a></p>
</blockquote>
<p>我们知道如何使用训练数据将一个点划分为两类之一。 我们的分类只是对类别的预测，基于最接近我们的新点的，训练点中最常见的类别。</p>
<p>假设我们最终发现了我们的新点的真实类别。 然后我们会知道我们的分类是否正确。 另外，我们将会有一个新点，可以加入到我们的训练集中，因为我们知道它的类别。 这就更新了我们的训练集。 所以，我们自然希望，根据新的训练集更新我们的分类器。</p>
<p>本章将介绍一些简单的情况，其中新的数据会使我们更新我们的预测。 虽然本章中的例子在计算方面较简单，但是更新方法可以推广到复杂的设定，是机器学习最强大的工具之一。</p>
<h2 id="更可能的二分类器">“更可能”的二分类器</h2>
<p>让我们尝试使用数据，将一个点划分为两个类别之一，选择我们认为更可能的类别。 为此，我们不仅需要数据，而且还要清楚地描述几率是什么样。</p>
<p>我们将从一个简单的人造情况开始，开发主要的技术，然后跳到更有趣的例子。</p>
<p>假设有个大学班级，其组成如下：</p>
<ul>
<li>60% 的学生为二年级，其余的 40% 是三年级</li>
<li>50% 二年级学生已经声明了他们的专业</li>
<li>80% 三年级学生已经声明了他们的专业</li>
</ul>
<p>现在假设我从班上随机挑选一个学生。 你能否用“更可能”的标准，将学生划分为二年级或三年级？</p>
<p>你可以，因为这个学生是随机挑选的，所以你知道这个学生是二年级的几率是 60%。 这比三年级的 40% 的可能性更大，所以你会把学生划分为二年级。</p>
<p>专业的信息是无关紧要的，因为我们已经知道班上二，三年的比例。</p>
<p>我们有了非常简单的分类器！ 但是现在假设我给了你一些被挑选的学生的更多信息：</p>
<p>这个学生已经声明了专业。</p>
<p>这个知识会改变你的分类吗？</p>
<h2 id="基于新信息更新预测">基于新信息更新预测</h2>
<p>现在我们知道学生已经宣布了专业，重要的是要看看年级和专业声明的关系。 二年级的学生比三年级多，这仍然正确。 但是，三年级的学生，比二年级的学生，声明专业的比例更高，这也是事实。 我们的分类器必须考虑到这两个观察。</p>
<p>为了使这个可视化，我们将使用<code>students</code>表，它包含 100 个学生，每个学生一行，学生的年级和专业比例和数据中相同。</p>
<pre><code class="lang-py">students.show(<span class="hljs-number">3</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Year</th>
<th>Major</th>
</tr>
</thead>
<tbody>
<tr>
<td>Second</td>
<td>Undeclared</td>
</tr>
<tr>
<td>Second</td>
<td>Undeclared</td>
</tr>
<tr>
<td>Second</td>
<td>Undeclared</td>
</tr>
</tbody>
</table>
<p>（省略了 97 行）</p>
<p>为了检查比例是否正确，我们使用<code>pivot</code>，按照这两个变量对每个学生进行交叉分类。</p>
<pre><code class="lang-py">students.pivot(<span class="hljs-string">'Major'</span>, <span class="hljs-string">'Year'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Year</th>
<th>Declared</th>
<th>Undeclared</th>
</tr>
</thead>
<tbody>
<tr>
<td>Second</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>Third</td>
<td>32</td>
<td>8</td>
</tr>
</tbody>
</table>
<p><img src="img/17-1.png" alt=""></img></p>
<p>总人数为 100 人，其中二年级 60 人，三年级 40 人。 二年级中，每个专业类别有 50%。 三年级的 40 人中，20% 是未声明的，80% 已声明。 因此，这 100 人的比例和我们问题中的班级相同，我们可以假定，我们的学生是从 100 名学生中随机抽取的。</p>
<p>我们必须选择学生最可能进入的那一行。当我们对这个学生一无所知时，他或她可能在四个单元格中的任何一个，因此更可能在第一行（二年级），因为那里包含更多的学生。</p>
<p>但是现在我们知道这个学生已经声明了专业，所以可能结果的空间已经减少了：现在学生只能在两个已声明的单元格中的一个。</p>
<p>这些单元格共有 62 名学生，其中 32 名是三年级。 这是一半以上，即使不是太多。</p>
<p>所以，考虑到学生专业的新信息，我们必须更新我们的预测，现在将学生划分为三年级。</p>
<p>我们的分类的正确几率是多少？ 对于所有声明了专业的 32 个三年级，我们是正确的，对于那 30 个二年级，我们是错误的。 因此，我们的正确几率大约是 0.516。</p>
<p>换句话说，我们正确几率是声明专业的学生中三年级的比例。</p>
<pre><code class="lang-py"><span class="hljs-number">32</span>/(<span class="hljs-number">30</span>+<span class="hljs-number">32</span>)
<span class="hljs-number">0.5161290322580645</span>
</code></pre>
<h2 id="树形图">树形图</h2>
<p>我们刚刚计算的比例基于 100 名学生。 但是班级没有理由没有 200 名学生，只要单元格中的所有比例都是正确的。 那么我们的计算就变成了<code>64 /(60 + 64)</code>，就是 0.516。</p>
<p>所以计算只取决于不同类别的比例，而不是计数。 为了便于比较，比例可以用树形图可视化，直接显示在数据透视表下方。</p>
<pre><code class="lang-py">students.pivot(<span class="hljs-string">'Major'</span>, <span class="hljs-string">'Year'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Year</th>
<th>Declared</th>
<th>Undeclared</th>
</tr>
</thead>
<tbody>
<tr>
<td>Second</td>
<td>30</td>
<td>30</td>
</tr>
<tr>
<td>Third</td>
<td>32</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>像数据透视表一样，该图将学生分成四个不同的组，称为“分支”。请注意，“三年级已声明”分支中的学生比例为<code>0.4 x 0.8 = 0.32</code>，对应于数据透视表中“三年级已声明”单元格中的 32 名学生。 “二年级已声明”分支中包含学生的<code>0.6 x 0.5 = 0.3</code>，对应于数据透视表中“二年级已声明”单元格中的 30 个。</p>
<p>我们知道，被挑选的学生属于“已声明”分支。也就是说，学生在两个顶层分支之一。这两个分支现在形成了我们的简化概率空间，所有几率的计算必须相对于这个简化空间的总概率。</p>
<p>所以，考虑到学生已声明专业，他们是三年级的几率可以直接从树中计算出来。答案是相对于两个“已声明”分类的总比例，“三年级已声明”分类的比例。</p>
<p>也就是说，答案是和以前一样，已声明的学生中三年级的比例。</p>
<pre><code class="lang-py">(<span class="hljs-number">0.4</span> * <span class="hljs-number">0.8</span>)/(<span class="hljs-number">0.6</span> * <span class="hljs-number">0.5</span>  +  <span class="hljs-number">0.4</span> * <span class="hljs-number">0.8</span>)
<span class="hljs-number">0.5161290322580645</span>
</code></pre>
<h3 id="贝叶斯法则">贝叶斯法则</h3>
<p>我们刚刚使用的方法来源于托马斯·贝叶斯牧师（1701-1761）。他的方法解决了所谓的“逆向概率”问题：假设有了新的数据，如何更新之前发现的几率？虽然贝叶斯生活在三个世纪之前，但他的方法现在在机器学习中广泛使用。</p>
<p>我们将在学生总体的背景下讲述这个规则。首先，一些术语：</p>
<p>先验概率。在我们知道所选学生的专业声明状态之前，学生是二年级的几率是 60%，学生是三年级的几率是 40%。这是两个类别的先验概率。</p>
<p>可能性。这是专业状态在给出学生类别情况下的几率；因此可以从树形图中读出。例如，假设学生是二年级，已声明的可能性是 0.5。</p>
<p>后验概率。这些是考虑专业声明状态的信息后，二年级的概率。我们计算了其中的一个：</p>
<p>假设学生已经声明，学生是三年级的后验概率表示为 <img src="img/tex-17-1.gif" alt=""></img>，计算如下。</p>
<p><img src="img/tex-17-2.gif" alt=""></img></p>
<p>另一个后验概率是：</p>
<p><img src="img/tex-17-3.gif" alt=""></img></p>
<pre><code class="lang-py">(<span class="hljs-number">0.6</span> * <span class="hljs-number">0.5</span>)/(<span class="hljs-number">0.6</span> * <span class="hljs-number">0.5</span>  +  <span class="hljs-number">0.4</span> * <span class="hljs-number">0.8</span>)
<span class="hljs-number">0.4838709677419354</span>
</code></pre>
<p>这大概是 0.484，还不到一半，与我们三年的分类一致。</p>
<p>请注意，两个后验概率的分母相同：新信息，也就是学生已声明的几率。</p>
<p>正因为如此，贝叶斯方法有时被归纳为比例陈述：</p>
<p><img src="img/tex-17-4.gif" alt=""></img></p>
<p>公式非常便于高效地描述计算。 但是在我们的学生示例这样的情况中，不用公式来思考更简单。 我们仅仅使用树形图。</p>
<h2 id="做出决策">做出决策</h2>
<p>贝叶斯规则的一个主要用途，是基于不完整的信息做出决策，并在新的信息到来时纳入它们。本节指出了在决策时保持你的假设的重要性。</p>
<p>许多疾病的医学检测都会返回阳性或阴性结果。阳性结果意味着，根据检测患者有疾病。阴性结果意味着，检测的结论是患者没有这种疾病。</p>
<p>医学检测经过精心设计，非常准确。但是很少有检测是 100% 准确的。几乎所有检测都有两种错误：</p>
<p>假阳性是，检测结果为阳性，但患者没有该疾病的错误。</p>
<p>假阴性是，检测结果为阴性，但患者确实有这种疾病的错误。</p>
<p>这些错误可能会影响人们的决策。假阳性可能引起焦虑和不必要的治疗（在某些情况下，这是昂贵的或危险的）。如果由于其阴性检测结果，患者未接受治疗，则假阴性可能具有更严重的后果。</p>
<h3 id="罕见疾病的检测">罕见疾病的检测</h3>
<p>假设总体很大，疾病只占总体的一小部分。 下面的属性图总结了这种疾病的信息，以及它的医学检测。</p>
<p><img src="img/17-2.png" alt=""></img></p>
<p>总的来说，只有千分之四的总体有这种疾病。 检测相当准确：假阳性几率非常小，为 5/1000，但是假阴性更大（尽管还是很小），为 1/100。</p>
<p>个体可能知道也可能不知道他们是否患有这种疾病；通常情况下，人们会进行检测来确认他们是否拥有。</p>
<p>所以假设随机从总体中挑选一个人并进行检测。 如果检测结果是阳性的，你会如何分类：患病还是没有患病？</p>
<p>我们可以通过应用贝叶斯规则，和使用我们的“更可能”的分类器来回答这个问题。 鉴于该人已经检测出阳性，他或她患病的几率是相对于<code>Test Positive</code>分支中的总比例，顶层分支的比例。</p>
<pre><code class="lang-py">(<span class="hljs-number">0.004</span> * <span class="hljs-number">0.99</span>)/(<span class="hljs-number">0.004</span> * <span class="hljs-number">0.99</span>  +  <span class="hljs-number">0.996</span>*<span class="hljs-number">0.005</span> )
<span class="hljs-number">0.44295302013422816</span>
</code></pre>
<p>鉴于这个人已经检测出阳性，他或她有这种疾病的几率是大约 44%。 所以我们将它们分类为：没有疾病。</p>
<p>这是一个奇怪的结论。 我们有一个相当准确的检测，一个人检测出阳性，我们的分类是...他们没有这种疾病？ 这似乎没有任何意义。</p>
<p>面对一个令人不安的答案，首先要做的是检查计算。 上面的算法是正确的。 我们来看看是否可以用不同的方式得到相同的答案。</p>
<p>函数<code>population</code>群体返回 100,000 名患者的结果表格，它的列展示了实际情况和检测结果。 检测与树中描述的相同。 但是有这种疾病的比例是这个函数的参数。</p>
<p>我们将 0.004 用作参数来调用<code>population</code>，然后调用<code>pivot</code>，对这十万人中的每一个人进行交叉分类。</p>
<pre><code class="lang-py">population(<span class="hljs-number">0.004</span>).pivot(<span class="hljs-string">'Test Result'</span>, <span class="hljs-string">'True Condition'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>True Condition</th>
<th>Negative</th>
<th>Positive</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disease</td>
<td>4</td>
<td>396</td>
</tr>
<tr>
<td>No Disease</td>
<td>99102</td>
<td>498</td>
</tr>
</tbody>
</table>
<p>表的单元格计数正确。 例如，根据总体的描述，一千人中有四人患有这种疾病。 表格中有十万人，所以 400 人应该有这种病。 这就是表格所显示的：<code>4 + 396 = 400</code>。在这 400 认中，99% 获得了阳性检测结果：<code>0.99 x 400 = 396</code>。</p>
<pre><code class="lang-py"><span class="hljs-number">396</span>/(<span class="hljs-number">396</span> + <span class="hljs-number">498</span>)
<span class="hljs-number">0.4429530201342282</span>
</code></pre>
<p>这就是我们通过使用贝叶斯规则得到的答案。<code>Positives</code>列中的计数显示为什么它小于 1/2。 在阳性的人中，更多的人没有疾病而不是有疾病。</p>
<p>原因是，很大一部分人没有这种疾病。检测出假阳性的一小部分人比真阳性要多。 这在树形图中更容易可视化：</p>
<p><img src="img/17-2.png" alt=""></img></p>
<p>真阳性的比例是总体一小部分（0.004）的很大一部分（0.99）。
假阳性的比例是总体很大一部分（0.996）的一小部分（0.005）。
这两个比例是可比的；第二个大一点。</p>
<p>所以，鉴于随机选择的人检测为阳性，我们将他们划分为，更有可能没有疾病，是正确的。</p>
<h3 id="主观先验">主观先验</h3>
<p>正确并不总令人满意。将阳性患者划分为不患有该疾病似乎仍然有些错误，对于这样的精确检测来说。由于计算是正确的，我们来看看我们的概率计算的基础：随机性假设。</p>
<p>我们的假设是，一个随机选择的人进行了检测，并得到了阳性结果。但是这在现实中并没有发生。因为他们认为他们可能有疾病，或者因为他们的医生认为他们可能有疾病，人们去接受检测。被检测的人不是随机选择的总体的成员。</p>
<p>这就是为什么，我们对被检测者的直觉与我们得到的答案不太相符。我们正在想象一个病人接受检测的现实情况，因为有一些理由让他们这样做，而计算基于随机选择的人进行检测。</p>
<p>所以让我们在更现实的假设下重做我们的计算，即病人正在接受检测，因为医生认为病人有发病的机会。</p>
<p>这里需要注意的是，“医生认为有机会”是指医生的意见，而不是总体中的比例。这被称为主观概率。在病人是否患有这种疾病的情况下，这也是主观的先验概率。</p>
<p>一些研究人员坚持认为，所有的概率必须是相对的频率，但主观概率导出都是。候选人赢得下一次选举的几率，大地震在下一个十年将会袭击湾区的几率，某个国家赢得下一届足球世界杯的几率：这些都不是基于相对频率或长期的频率。每个都包含主观因素。涉及它们的所有计算也都有主观因素。</p>
<p>假设医生的主观意见是，患者有 5% 的几率患病。那么树形图中的先验概率将会改变：</p>
<p><img src="img/17-3.png" alt=""></img></p>
<p>鉴于病人检测为阳性，他或她有这种疾病的几率是由贝叶斯规则给出。</p>
<pre><code class="lang-py">(<span class="hljs-number">0.05</span> * <span class="hljs-number">0.99</span>)/(<span class="hljs-number">0.05</span> * <span class="hljs-number">0.99</span>  +  <span class="hljs-number">0.95</span> * <span class="hljs-number">0.005</span>)
<span class="hljs-number">0.9124423963133641</span>
</code></pre>
<p>改变先验的效果是惊人的。 即使病人患病的医生的先验概率（5%）很低，一旦患者检测出阳性，患病的后验概率高达 91% 以上。</p>
<p>如果患者检测出阳性，医生认为患者患病是合理的。</p>
<h3 id="确认结果">确认结果</h3>
<p>虽然医生的意见是主观的，但我们可以产生一个人造总体，5% 的人患有这种疾病，并且使用相同的检测来进行检测。 然后，我们可以计算不同类别的人数，看看这些计数是否与我们使用贝叶斯规则得到的答案一致。</p>
<p>我们可以使用<code>population(0.05)</code>和<code>pivot</code>构建相应的总体，并看看四个单元格中的计数。</p>
<pre><code class="lang-py">population(<span class="hljs-number">0.05</span>).pivot(<span class="hljs-string">'Test Result'</span>, <span class="hljs-string">'True Condition'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>True Condition</th>
<th>Negative</th>
<th>Positive</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disease</td>
<td>50</td>
<td>4950</td>
</tr>
<tr>
<td>No Disease</td>
<td>94525</td>
<td>475</td>
</tr>
</tbody>
</table>
<p>在这个人工创建的 10 万人的总体中，有 5000 人（5%）患有这种疾病，其中 99% 的人检测为阳性，导致 4950 人为真阳性。 将其与 475 个假阳性相比：在阳性中，拥有疾病的比例与我们通过贝叶斯规则得到的结果相同。</p>
<pre><code class="lang-py"><span class="hljs-number">4950</span>/(<span class="hljs-number">4950</span> + <span class="hljs-number">475</span>)
<span class="hljs-number">0.9124423963133641</span>
</code></pre>
<p>因为我们可以一个具有合适比例的总体，我们也可以使用模拟来确认我们的答案是否合理。 <code>pop_05</code>表包含 10 万人的总体，使用医生的先验患病概率 5%，以及检测的错误率来生成。 我们从总体中抽取一个规模为 10,000 的简单随机样本，并提取<code>positive</code>表，仅包含样本中阳性检测结果的个体。</p>
<pre><code class="lang-py">pop_05 = population(<span class="hljs-number">0.05</span>)

sample = pop_05.sample(<span class="hljs-number">10000</span>, with_replacement=<span class="hljs-keyword">False</span>)

positive = sample.where(<span class="hljs-string">'Test Result'</span>, are.equal_to(<span class="hljs-string">'Positive'</span>))
</code></pre>
<p>在这些阳性结果中，真实比例是多少？ 那是拥有这种疾病的阳性的比例：</p>
<pre><code class="lang-py">positive.where(<span class="hljs-string">'True Condition'</span>, are.equal_to(<span class="hljs-string">'Disease'</span>)).num_rows/positive.num_rows
<span class="hljs-number">0.9131205673758865</span>
</code></pre>
<p>运行这两个单元格几次，你会发现，阳性中真阳性的比例位于我们通过贝叶斯规则计算的值 0.912 周围。</p>
<p>你也可以以不同参数调用<code>population</code>函数，来改变先验患病概率，并查看后验概率如何受到影响。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="16.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: 十六、比较两个样本">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"description":"计算与推断思维","title":"十七、更新预测","level":"1.1.18","depth":2,"previous":{"title":"十六、比较两个样本","level":"1.1.17","depth":2,"path":"16.md","ref":"16.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*","description":"计算与推断思维"},"file":{"path":"17.md","mtime":"2025-05-12T03:21:14.487Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-12T03:27:43.472Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

