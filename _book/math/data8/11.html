
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>十一、估计 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="12.html" />
    
    
    <link rel="prev" href="10.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    计算与推断思维
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="READ_ME.html">
            
                <a href="READ_ME.html">
            
                    
                    计算与推断思维
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="1.html">
            
                <a href="1.html">
            
                    
                    一、数据科学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="2.html">
            
                <a href="2.html">
            
                    
                    二、因果和实验
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="3.html">
            
                <a href="3.html">
            
                    
                    三、Python 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="4.html">
            
                <a href="4.html">
            
                    
                    四、数据类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="5.html">
            
                <a href="5.html">
            
                    
                    五、表格
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="6.html">
            
                <a href="6.html">
            
                    
                    六、可视化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="7.html">
            
                <a href="7.html">
            
                    
                    七、函数和表格
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="8.html">
            
                <a href="8.html">
            
                    
                    八、随机性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="9.html">
            
                <a href="9.html">
            
                    
                    九、经验分布
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="10.html">
            
                <a href="10.html">
            
                    
                    十、假设检验
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.12" data-path="11.html">
            
                <a href="11.html">
            
                    
                    十一、估计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="12.html">
            
                <a href="12.html">
            
                    
                    十二、为什么均值重要
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="13.html">
            
                <a href="13.html">
            
                    
                    十三、预测
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.15" data-path="14.html">
            
                <a href="14.html">
            
                    
                    十四、回归的推断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.16" data-path="15.html">
            
                <a href="15.html">
            
                    
                    十五、分类
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.17" data-path="16.html">
            
                <a href="16.html">
            
                    
                    十六、比较两个样本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.18" data-path="17.html">
            
                <a href="17.html">
            
                    
                    十七、更新预测
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >十一、估计</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="十一、估计">十一、估计</h1>
<blockquote>
<p>原文：<a href="https://github.com/data-8/textbook/tree/gh-pages/chapters/11" target="_blank">Estimation</a></p>
<p>译者：<a href="https://github.com/wizardforcel" target="_blank">飞龙</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/" target="_blank">谷歌翻译</a></p>
</blockquote>
<p>在前一章中，我们开始开发推断思维的方法。特别是，我们学会了如何使用数据，在世界的两个假设之间做决策。但是我们通常只想知道，某件事情有多大。</p>
<p>例如，在前面的章节中，我们调查了敌人可能拥有的战机数量。在选举年，我们可能想知道有多少选民赞成特定候选人。为了评估目前的经济状况，我们可能会对美国家庭年收入的中位数感兴趣。</p>
<p>在本章中，我们将开发一种估计未知参数的方法。请记住，参数是总体相关的数值。</p>
<p>要弄清参数的值，我们需要数据。如果我们有整个人口的相关数据，我们可以简单地计算参数。</p>
<p>但是，如果人口非常庞大（例如，如果它由美国的所有家庭组成），那么收集整个人口的数据可能过于昂贵和耗时。在这种情况下，数据科学家依赖从人口中随机抽样。</p>
<p>这导致了一个推断问题：如何根据随机样本中的数据，对未知参数做出正确的结论？我们将用推断思维来回答这个问题。</p>
<p>基于随机样本的统计量可能是总体中未知参数的合理估计。例如，你可能希望使用家庭样本的年收入中位数，来估计美国所有家庭的年收入中位数。</p>
<p>但任何统计量的值都取决于样本，样本基于随机抽取。所以每次数据科学家得到了一个基于随机样本的估计，他们都面临一个问题：</p>
<p>“如果样本是不同的，这个估计有多大的不同呢？”</p>
<p>在本章中，你将学习一种回答这个问题的方法。答案将为你提供工具来估算数值参数，并量化估算中的误差量。</p>
<p>我们将以百分位数开始。最有名的百分位数是中位数，通常用于收入数据的摘要。在我们即将开发的估计方法中，其他百分位数也是非常重要的。所以我们一开始要仔细定义百分位数。</p>
<h2 id="百分位数">百分位数</h2>
<p>数值数据可以按照升序或降序排序。因此，数值数据集的值具有等级顺序。百分位数是特定等级的值。</p>
<p>例如，如果你的考试成绩在第 95 个百分位，一个常见的解释是只有 5% 的成绩高于你的成绩。中位数是第 50 个百分位；通常假定数据集中 50% 的值高于中值。</p>
<p>但是，给予百分位一个精确定义，适用于所有等级和所有列表，需要一些谨慎。为了明白为什么，考虑一个极端的例子，一个班级的所有学生在考试中得分为 75 分。那么 75 是中位数的自然候选，但是 50% 的分数高于 75 并不是真的。另外，75 同样是第 95 个或第 25 个百分位数，或任何其他百分位数的自然候选。在定义百分位数时，必须将重复 - 也就是相同的数据值 - 考虑在内。</p>
<p>当相关的索引不明确时，你还必须小心列表到底有多长。例如，10 个值的集合的第 87 个百分位数是多少？有序集合的第 8 个值，还是第 9 个，还是其中的某个位置？</p>
<h3 id="数值的例子">数值的例子</h3>
<p>在给出所有百分位数的一般定义之前，我们将把数值集合的第80个百分点定义为集合中的（一定条件的）最小值，它至少与所有值的 80% 一样大。</p>
<p>例如，考虑非洲，南极洲，亚洲，北美洲和南美洲五大洲的大小，四舍五入到最接近的百万平方英里。</p>
<pre><code class="lang-py">sizes = make_array(<span class="hljs-number">12</span>, <span class="hljs-number">17</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>)
</code></pre>
<p>第 80 个百分位数是（一定条件的）最小值，至少和 80% 的值一样大，也就是五个元素的五分之四。等于 12：</p>
<pre><code class="lang-py">np.sort(sizes)
array([ <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">17</span>])
</code></pre>
<p>第 80 个百分位数是列表中的一个值，也就是 12。你可以看到，80% 的值小于等于它，并且它是列表中满足这个条件的最小值。</p>
<p>与之类似，第 70 个百分位数是该集合中（一定条件的）最小值，至少与 70% 的元素一样大。 现在 5 个元素中的 70% 是“3.5 个元素”，所以第 70 个百分位数是列表中的第 4 个元素。 它是 12，与这些数据的第 80 百分位数相同。</p>
<h3 id="percentile函数"><code>percentile</code>函数</h3>
<p><code>percentile</code>函数接受两个参数：一个 0 到 100 之间的等级，和一个数组。它返回数组相应的百分位数。</p>
<pre><code class="lang-py">percentile(<span class="hljs-number">70</span>, sizes)
<span class="hljs-number">12</span>
</code></pre>
<h3 id="一般定义">一般定义</h3>
<p>令<code>p</code>为 0 到 100 之间的数字。集合的第<code>p</code>个百分位数是集合中的（一定条件）的最小值，它至少与<code>p%</code>的所有值一样大。</p>
<p>通过这个定义，可以计算任何值的集合的任何 0 到 100 之间的百分位数，并且它始终是集合的一个元素。</p>
<p>实际上，假设集合中有<code>n</code>个元素。 要找到第<code>p</code>个百分位数：</p>
<ul>
<li>对集合升序排序。</li>
<li>计算<code>n</code>的<code>p%</code>：<code>(p/100) * n</code>。叫做<code>k</code>。</li>
<li>如果<code>k</code>是一个整数，则取有序集合的第<code>k</code>个元素。</li>
<li>如果<code>k</code>不是一个整数，则将其四舍五入到下一个整数，并采用有序集合的那个元素。</li>
</ul>
<h3 id="示例">示例</h3>
<p><code>scores_and_sections</code>表包含 359 名学生，每个学生一行。 列是学生的讨论分组和期中分数。</p>
<pre><code class="lang-py">scores_and_sections = Table.read_table(<span class="hljs-string">'scores_by_section.csv'</span>)
scores_and_sections
</code></pre>
<table>
<thead>
<tr>
<th>Section</th>
<th>Midterm</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>22</td>
</tr>
<tr>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>23</td>
</tr>
<tr>
<td>2</td>
<td>14</td>
</tr>
<tr>
<td>1</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>25</td>
</tr>
<tr>
<td>4</td>
<td>19</td>
</tr>
<tr>
<td>1</td>
<td>24</td>
</tr>
<tr>
<td>5</td>
<td>8</td>
</tr>
<tr>
<td>6</td>
<td>14</td>
</tr>
</tbody>
</table>
<p>（省略了 349 列）</p>
<pre><code class="lang-py">scores_and_sections.select(<span class="hljs-string">'Midterm'</span>).hist(bins=np.arange(-<span class="hljs-number">0.5</span>, <span class="hljs-number">25.6</span>, <span class="hljs-number">1</span>))
</code></pre>
<p><img src="img/11-1.png" alt=""></img></p>
<p>分数的第 85 个百分位数是多少？ 为了使用<code>percentile</code>函数，创建包含期中分数的数组<code>scores</code>，并找到第 85 个百分位数：</p>
<pre><code class="lang-py">scores = scores_and_sections.column(<span class="hljs-number">1</span>)
percentile(<span class="hljs-number">85</span>, scores)
<span class="hljs-number">22</span>
</code></pre>
<p>根据<code>percentile</code>函数，第 85 个百分点数是 22。为了检查这是否符合我们的新定义，我们直接应用定义。</p>
<p>首先，把分数升序排列：</p>
<pre><code class="lang-py">sorted_scores = np.sort(scores_and_sections.column(<span class="hljs-number">1</span>))
</code></pre>
<p>数组中有 359 个分数。所以下面，计算 359 的 85%，它是 305.15。</p>
<pre><code class="lang-py"><span class="hljs-number">0.85</span> * <span class="hljs-number">359</span>
<span class="hljs-number">305.15</span>
</code></pre>
<p>这不是一个整数。 根据我们的定义，中位数是<code>sorted_scores</code>的第 306 个元素，按 Python 的索引约定，它是数组的第 305 项。</p>
<pre><code class="lang-py"><span class="hljs-comment"># The 306th element of the sorted array</span>

sorted_scores.item(<span class="hljs-number">305</span>)
<span class="hljs-number">22</span>
</code></pre>
<p>它和我们通过使用<code>percentile</code>得到的答案一样。以后，我们会仅仅使用<code>percentile</code>。</p>
<h3 id="四分位数">四分位数</h3>
<p>数值集合的第一个四分位数是第 25 个百分分数。 这个术语（quartile）来自第一个季度（quarter）。 第二个四分位数是中位数，第三个四分位数是第 75 个百分位数。</p>
<p>对于我们的分数数据，这些值是：</p>
<pre><code class="lang-py">percentile(<span class="hljs-number">25</span>, scores)
<span class="hljs-number">11</span>
percentile(<span class="hljs-number">50</span>, scores)
<span class="hljs-number">16</span>
percentile(<span class="hljs-number">75</span>, scores)
<span class="hljs-number">20</span>
</code></pre>
<p>分数的分布有时归纳为“中等 50%”区间，在第一和第三个四分位数之间。</p>
<h2 id="自举法">自举法</h2>
<p>一个数据科学家正在使用随机样本中的数据来估计未知参数。她使用样本来计算用作估计值的统计量。</p>
<p>一旦她计算出了统计量的观察值，她就可以把它作为她的估计值，然后顺其自然。 但她是一名数据科学家。 她知道她的随机样本只是众多可能的随机样本之一，因此她的估计只是众多合理估算之一。</p>
<p>这些估计的变化有多大？ 为了回答这个问题，似乎她需要从总体中抽取另一个样本，并根据新样本计算一个新的估计值。 但是她没有资源来回到总体中，再抽取一个样本。</p>
<p>这个数据科学家看起来好像卡住了。</p>
<p>幸运的是，一个叫做自举法的好主意可以帮助她。 由于从总体中生成新样本是不可行的，自举法通过称为重采样的方法生成新的随机样本：新样本从原始样本中随机抽取。</p>
<p>在本节中，我们将看到自举法的工作方式和原因。 在本章的其余部分，我们将使用自举法进行推理。</p>
<h3 id="旧金山市的雇员薪资">旧金山市的雇员薪资</h3>
<p><a href="https://data.sfgov.org/" target="_blank">SF OpenData</a> 是一个网站，旧金山市和县在上面公开提供他们的一些数据。 其中一个数据集包含城市雇员的薪资数据。 其中包括市营医院的医疗专业人员，警察，消防员，运输工人，民选官员以及市内所有其他雇员。</p>
<p>2015 日历年的薪资数据见表<code>sf2015</code>。</p>
<pre><code class="lang-py">sf2015 = Table.read_table(<span class="hljs-string">'san_francisco_2015.csv'</span>)
sf2015
</code></pre>
<table>
<thead>
<tr>
<th>Year Type</th>
<th>Year</th>
<th>Organization Group Code</th>
<th>Organization Group</th>
<th>Department Code</th>
<th>Department</th>
<th>Union Code</th>
<th>Union</th>
<th>Job Family Code</th>
<th>Job Family</th>
<th>Job Code</th>
<th>Job</th>
<th>Employee Identifier</th>
<th>Salaries</th>
<th>Overtime</th>
<th>Other Salaries</th>
<th>Total Salary</th>
<th>Retirement</th>
<th>Health/Dental</th>
<th>Other Benefits</th>
<th>Total Benefits</th>
<th>Total Compensation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>2</td>
<td>Public Works, Transportation &amp; Commerce</td>
<td>WTR</td>
<td>PUC Water Department</td>
<td>21</td>
<td>Prof &amp; Tech Engineers - Miscellaneous, Local 21</td>
<td>2400</td>
<td>Lab, Pharmacy &amp; Med Techs</td>
<td>2481</td>
<td>Water Qualitytech I/II</td>
<td>21538</td>
<td>82146</td>
<td>0</td>
<td>0</td>
<td>82146</td>
<td>16942.2</td>
<td>12340.9</td>
<td>6337.73</td>
<td>35620.8</td>
<td>117767</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>2</td>
<td>Public Works, Transportation &amp; Commerce</td>
<td>DPW</td>
<td>General Services Agency - Public Works</td>
<td>12</td>
<td>Carpet, Linoleum and Soft Tile Workers, Local 12</td>
<td>7300</td>
<td>Journeyman Trade</td>
<td>7393</td>
<td>Soft Floor Coverer</td>
<td>5459</td>
<td>32165.8</td>
<td>973.19</td>
<td>848.96</td>
<td>33987.9</td>
<td>0</td>
<td>4587.51</td>
<td>2634.42</td>
<td>7221.93</td>
<td>41209.8</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>4</td>
<td>Community Health</td>
<td>DPH</td>
<td>Public Health</td>
<td>790</td>
<td>SEIU - Miscellaneous, Local 1021</td>
<td>1600</td>
<td>Payroll, Billing &amp; Accounting</td>
<td>1636</td>
<td>Health Care Billing Clerk 2</td>
<td>41541</td>
<td>71311</td>
<td>5757.98</td>
<td>0</td>
<td>77069</td>
<td>14697.6</td>
<td>12424.5</td>
<td>6370.06</td>
<td>33492.2</td>
<td>110561</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>4</td>
<td>Community Health</td>
<td>DPH</td>
<td>Public Health</td>
<td>351</td>
<td>Municipal Executive Association - Miscellaneous</td>
<td>0900</td>
<td>Management</td>
<td>2620</td>
<td>Food Service Mgr Administrator</td>
<td>26718</td>
<td>28430.2</td>
<td>0</td>
<td>763.07</td>
<td>29193.3</td>
<td>0</td>
<td>4223.14</td>
<td>5208.51</td>
<td>9431.65</td>
<td>38625</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>2</td>
<td>Public Works, Transportation &amp; Commerce</td>
<td>MTA</td>
<td>Municipal Transportation Agency</td>
<td>790</td>
<td>SEIU - Miscellaneous, Local 1021</td>
<td>8200</td>
<td>Protection &amp; Apprehension</td>
<td>8201</td>
<td>School Crossing Guard</td>
<td>45810</td>
<td>7948.75</td>
<td>0</td>
<td>0</td>
<td>7948.75</td>
<td>0</td>
<td>2873.17</td>
<td>616.24</td>
<td>3489.41</td>
<td>11438.2</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>1</td>
<td>Public Protection</td>
<td>POL</td>
<td>Police</td>
<td>911</td>
<td>Police Officers' Association</td>
<td>Q000</td>
<td>Police Services</td>
<td>Q002</td>
<td>Police Officer</td>
<td>32906</td>
<td>2235</td>
<td>0</td>
<td>0</td>
<td>2235</td>
<td>490.36</td>
<td>286.72</td>
<td>176.57</td>
<td>953.65</td>
<td>3188.65</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>4</td>
<td>Community Health</td>
<td>DPH</td>
<td>Public Health</td>
<td>791</td>
<td>SEIU - Staff and Per Diem Nurses, Local 1021</td>
<td>2300</td>
<td>Nursing</td>
<td>2328</td>
<td>Nurse Practitioner</td>
<td>7506</td>
<td>187247</td>
<td>0</td>
<td>11704.1</td>
<td>198951</td>
<td>37683.7</td>
<td>12424.5</td>
<td>11221.7</td>
<td>61329.9</td>
<td>260281</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>2</td>
<td>Public Works, Transportation &amp; Commerce</td>
<td>MTA</td>
<td>Municipal Transportation Agency</td>
<td>253</td>
<td>Transport Workers - Transit Operators, Local 250-A</td>
<td>9100</td>
<td>Street Transit</td>
<td>9163</td>
<td>Transit Operator</td>
<td>36773</td>
<td>66988.5</td>
<td>3512.88</td>
<td>2770.39</td>
<td>73271.8</td>
<td>19127.2</td>
<td>13203</td>
<td>5455.1</td>
<td>37785.3</td>
<td>111057</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>6</td>
<td>General Administration &amp; Finance</td>
<td>CAT</td>
<td>City Attorney</td>
<td>311</td>
<td>Municipal Attorneys' Association</td>
<td>8100</td>
<td>Legal &amp; Court</td>
<td>8177</td>
<td>Attorney (Civil/Criminal)</td>
<td>12963</td>
<td>135190</td>
<td>0</td>
<td>1562.5</td>
<td>136752</td>
<td>27501.8</td>
<td>12424.5</td>
<td>10103</td>
<td>50029.3</td>
<td>186781</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>3</td>
<td>Human Welfare &amp; Neighborhood Development</td>
<td>DSS</td>
<td>Human Services</td>
<td>535</td>
<td>SEIU - Human Services, Local 1021</td>
<td>9700</td>
<td>Community Development</td>
<td>9703</td>
<td>Emp &amp; Training Spec 2</td>
<td>35179</td>
<td>70474.8</td>
<td>147.28</td>
<td>1647.24</td>
<td>72269.3</td>
<td>14650.3</td>
<td>10696.9</td>
<td>5993.11</td>
<td>31340.3</td>
<td>103610</td>
</tr>
</tbody>
</table>
<p>（省略了 42979 行）</p>
<p>共有 42,979 名员工，每个人一行。 有许多列包含市政部门隶属关系的信息，以及员工薪酬方案不同部分的详细信息。 这是对应市长 Ed Lee 的一行。</p>
<pre><code class="lang-py">sf2015.where(<span class="hljs-string">'Job'</span>, are.equal_to(<span class="hljs-string">'Mayor'</span>))
</code></pre>
<table>
<thead>
<tr>
<th>Year Type</th>
<th>Year</th>
<th>Organization Group Code</th>
<th>Organization Group</th>
<th>Department Code</th>
<th>Department</th>
<th>Union Code</th>
<th>Union</th>
<th>Job Family Code</th>
<th>Job Family</th>
<th>Job Code</th>
<th>Job</th>
<th>Employee Identifier</th>
<th>Salaries</th>
<th>Overtime</th>
<th>Other Salaries</th>
<th>Total Salary</th>
<th>Retirement</th>
<th>Health/Dental</th>
<th>Other Benefits</th>
<th>Total Benefits</th>
<th>Total Compensation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>6</td>
<td>General Administration &amp; Finance</td>
<td>MYR</td>
<td>Mayor</td>
<td>556</td>
<td>Elected Officials</td>
<td>1100</td>
<td>Administrative &amp; Mgmt (Unrep)</td>
<td>1190</td>
<td>Mayor</td>
<td>22433</td>
<td>288964</td>
<td>0</td>
<td>0</td>
<td>288964</td>
<td>58117</td>
<td>12424.5</td>
<td>20293</td>
<td>90834.5</td>
<td>379798</td>
</tr>
</tbody>
</table>
<p>我们要研究最后一栏，总薪酬。 这是员工的工资加上市政府对退休和福利计划的贡献。</p>
<p>日历年的财务方案有时难以理解，因为它们取决于雇用日期，员工是否在城市内部换工作等等。 例如，<code>Total Compensation</code>列中的最低值看起来有点奇怪。</p>
<pre><code class="lang-py">sf2015.sort(<span class="hljs-string">'Total Compensation'</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Year Type</th>
<th>Year</th>
<th>Organization Group Code</th>
<th>Organization Group</th>
<th>Department Code</th>
<th>Department</th>
<th>Union Code</th>
<th>Union</th>
<th>Job Family Code</th>
<th>Job Family</th>
<th>Job Code</th>
<th>Job</th>
<th>Employee Identifier</th>
<th>Salaries</th>
<th>Overtime</th>
<th>Other Salaries</th>
<th>Total Salary</th>
<th>Retirement</th>
<th>Health/Dental</th>
<th>Other Benefits</th>
<th>Total Benefits</th>
<th>Total Compensation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>1</td>
<td>Public Protection</td>
<td>FIR</td>
<td>Fire Department</td>
<td>798</td>
<td>Firefighters - Miscellaneous, Local 798</td>
<td>H000</td>
<td>Fire Services</td>
<td>H002</td>
<td>Firefighter</td>
<td>43833</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-423.76</td>
<td>-423.76</td>
<td>-423.76</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>4</td>
<td>Community Health</td>
<td>DPH</td>
<td>Public Health</td>
<td>790</td>
<td>SEIU - Miscellaneous, Local 1021</td>
<td>9900</td>
<td>Public Service Aide</td>
<td>9924</td>
<td>PS Aide Health Services</td>
<td>27871</td>
<td>-292.4</td>
<td>0</td>
<td>0</td>
<td>-292.4</td>
<td>0</td>
<td>-95.58</td>
<td>-22.63</td>
<td>-118.21</td>
<td>-410.61</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>1</td>
<td>Public Protection</td>
<td>JUV</td>
<td>Juvenile Probation</td>
<td>790</td>
<td>SEIU - Miscellaneous, Local 1021</td>
<td>8300</td>
<td>Correction &amp; Detention</td>
<td>8320</td>
<td>Counselor, Juvenile Hall</td>
<td>10517</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-159.12</td>
<td>-159.12</td>
<td>-159.12</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>6</td>
<td>General Administration &amp; Finance</td>
<td>CPC</td>
<td>City Planning</td>
<td>21</td>
<td>Prof &amp; Tech Engineers - Miscellaneous, Local 21</td>
<td>1000</td>
<td>Information Systems</td>
<td>1053</td>
<td>IS Business Analyst-Senior</td>
<td>18961</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-26.53</td>
<td>-26.53</td>
<td>-26.53</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>6</td>
<td>General Administration &amp; Finance</td>
<td>CPC</td>
<td>City Planning</td>
<td>21</td>
<td>Prof &amp; Tech Engineers - Miscellaneous, Local 21</td>
<td>5200</td>
<td>Professional Engineering</td>
<td>5277</td>
<td>Planner 1</td>
<td>19387</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-9.51</td>
<td>-9.51</td>
<td>-9.51</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>2</td>
<td>Public Works, Transportation &amp; Commerce</td>
<td>PUC</td>
<td>PUC Public Utilities Commission</td>
<td>21</td>
<td>Prof &amp; Tech Engineers - Miscellaneous, Local 21</td>
<td>1000</td>
<td>Information Systems</td>
<td>1044</td>
<td>IS Engineer-Principal</td>
<td>28988</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-3.1</td>
<td>-3.1</td>
<td>-3.1</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>1</td>
<td>Public Protection</td>
<td>JUV</td>
<td>Juvenile Probation</td>
<td>39</td>
<td>Stationary Engineers, Local 39</td>
<td>7300</td>
<td>Journeyman Trade</td>
<td>7335</td>
<td>Senior Stationary Engineer</td>
<td>19125</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>-0.01</td>
<td>-0.01</td>
<td>-0.01</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>1</td>
<td>Public Protection</td>
<td>ECD</td>
<td>Department of Emergency Management</td>
<td>351</td>
<td>Municipal Executive Association - Miscellaneous</td>
<td>0900</td>
<td>Management</td>
<td>0922</td>
<td>Manager I</td>
<td>30025</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>7</td>
<td>General City Responsibilities</td>
<td>UNA</td>
<td>General Fund Unallocated</td>
<td>790</td>
<td>SEIU - Miscellaneous, Local 1021</td>
<td>3200</td>
<td>Recreation</td>
<td>3280</td>
<td>Assistant Recreation Director</td>
<td>49784</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1.27</td>
<td>1.27</td>
<td>1.27</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>4</td>
<td>Community Health</td>
<td>DPH</td>
<td>Public Health</td>
<td>250</td>
<td>SEIU - Health Workers, Local 1021</td>
<td>2600</td>
<td>Dietary &amp; Food</td>
<td>2654</td>
<td>Cook</td>
<td>26768</td>
<td>0</td>
<td>0</td>
<td>2.21</td>
<td>2.21</td>
<td>0</td>
<td>0</td>
<td>0.17</td>
<td>0.17</td>
<td>2.38</td>
</tr>
</tbody>
</table>
<p>（省略了 42979 行）</p>
<p>为了便于比较，我们将专注于那些工作时间相当于至少半年的人。 最低工资约为每小时 10 美元，52 周每周 20 小时，工资约为 1 万美元。</p>
<pre><code class="lang-py">sf2015 = sf2015.where(<span class="hljs-string">'Salaries'</span>, are.above(<span class="hljs-number">10000</span>))
sf2015.num_rows
<span class="hljs-number">36569</span>
</code></pre>
<h3 id="总体和参数">总体和参数</h3>
<p>让这张超过 36500 行的表格成为我们的总体。 这是总薪资的直方图。</p>
<pre><code class="lang-py">sf_bins = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">700000</span>, <span class="hljs-number">25000</span>)
sf2015.select(<span class="hljs-string">'Total Compensation'</span>).hist(bins=sf_bins)
</code></pre>
<p><img src="img/11-2.png" alt=""></img></p>
<p>虽然大部分值都低于 300,000 美元，但有一些还是比较高的。 例如，首席投资官的总薪资不多是 65 万美元。 这就是为什么横轴延伸到了 700,000 美元。</p>
<pre><code class="lang-py">sf2015.sort(<span class="hljs-string">'Total Compensation'</span>, descending=<span class="hljs-keyword">True</span>).show(<span class="hljs-number">2</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Year Type</th>
<th>Year</th>
<th>Organization Group Code</th>
<th>Organization Group</th>
<th>Department Code</th>
<th>Department</th>
<th>Union Code</th>
<th>Union</th>
<th>Job Family Code</th>
<th>Job Family</th>
<th>Job Code</th>
<th>Job</th>
<th>Employee Identifier</th>
<th>Salaries</th>
<th>Overtime</th>
<th>Other Salaries</th>
<th>Total Salary</th>
<th>Retirement</th>
<th>Health/Dental</th>
<th>Other Benefits</th>
<th>Total Benefits</th>
<th>Total Compensation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>6</td>
<td>General Administration &amp; Finance</td>
<td>RET</td>
<td>Retirement System</td>
<td>351</td>
<td>Municipal Executive Association - Miscellaneous</td>
<td>1100</td>
<td>Administrative &amp; Mgmt (Unrep)</td>
<td>1119</td>
<td>Chief Investment Officer</td>
<td>46881</td>
<td>507832</td>
<td>0</td>
<td>0</td>
<td>507832</td>
<td>105053</td>
<td>12424.5</td>
<td>23566.2</td>
<td>141044</td>
<td>648875</td>
</tr>
<tr>
<td>Calendar</td>
<td>2015</td>
<td>6</td>
<td>General Administration &amp; Finance</td>
<td>ADM</td>
<td>General Services Agency - City Admin</td>
<td>164</td>
<td>Physicians and Dentists - Miscellaneous</td>
<td>2500</td>
<td>Med Therapy &amp; Auxiliary</td>
<td>2598</td>
<td>Asst Med Examiner</td>
<td>1016</td>
<td>279311</td>
<td>3829.36</td>
<td>114434</td>
<td>397574</td>
<td>56211.6</td>
<td>12424.5</td>
<td>14299.1</td>
<td>82935.2</td>
<td>480509</td>
</tr>
</tbody>
</table>
<p>（省略了 36567 行）</p>
<p>现在让参数为总薪资的中位数。</p>
<p>既然我们有能力从总体中得到所有数据，我们可以简单计算参数：</p>
<pre><code class="lang-py">pop_median = percentile(<span class="hljs-number">50</span>, sf2015.column(<span class="hljs-string">'Total Compensation'</span>))
pop_median
<span class="hljs-number">110305.78999999999</span>
</code></pre>
<p>所有员工的薪酬总额的中位数刚刚超过 110,300 美元。</p>
<p>从实际的角度来看，我们没有理由抽取样本来估计这个参数，因为我们只是知道它的值。 但在本节中，我们假装不知道这个值，看看我们如何根据随机样本来估计它。</p>
<p>在后面的章节中，我们将回到现实，在参数未知的情况下工作。 就目前而言，我们是无所不知的。</p>
<h3 id="随机样本和估计">随机样本和估计</h3>
<p>让我们无放回地随机抽取 500 名员工的样本，并将所选员工的总薪酬的中位数作为我们的参数估计量。</p>
<pre><code class="lang-py">our_sample = sf2015.sample(<span class="hljs-number">500</span>, with_replacement=<span class="hljs-keyword">False</span>)
our_sample.select(<span class="hljs-string">'Total Compensation'</span>).hist(bins=sf_bins)
</code></pre>
<p><img src="img/11-3.png" alt=""></img></p>
<pre><code class="lang-py">est_median = percentile(<span class="hljs-number">50</span>, our_sample.column(<span class="hljs-string">'Total Compensation'</span>))
est_median
<span class="hljs-number">113598.99000000001</span>
</code></pre>
<p>样本量很大。 根据平均定律，样本的分布与总体的分布相似，因此样本中位数与总体中位数相差不大（尽管当然并不完全相同）。</p>
<p>所以现在我们有了参数的估计。 但是，如果样本是不同的，估计的值也会不同。 我们希望能够量化估计的值在不同样本间的差异。 这个变化的测量将有助于我们衡量我们可以将参数估计得多么准确。</p>
<p>为了查看样本有多么不同，我们可以从总体中抽取另一个样本，但这样做就作弊了。 我们正试图模仿现实生活，我们不能掌握所有的人口数据。</p>
<p>用某种方式，我们必须得到另一个随机样本，而不从总体中抽样。</p>
<h3 id="自举法：从样本中重采样">自举法：从样本中重采样</h3>
<p>我们所做的是，从样本中随机抽样。 我们知道了，大型随机样本可能类似于用于抽取的总体。 这一观察使得数据科学家可以通过自举来提升自己：抽样过程可以通过从样本中抽样来复制。</p>
<p>以下是自举法的步骤，用于生成类似总体的另一个随机样本：</p>
<ul>
<li>将原始样本看做总体。</li>
<li>从样本中随机抽取样本，与原始样本大小相同。</li>
</ul>
<p>二次样本的大小与原始样本相同很重要。 原因是估计量的变化取决于样本的大小。 由于我们的原始样本由 500 名员工组成，我们的样本中位数基于 500 个值。 为了看看样本变化多少，我们必须将其与 500 个其他样本的中位数进行比较。</p>
<p>如果我们从大小为 500 的样本中，无放回地随机抽取了 500 次，我们只会得到相同的样本。 通过带放回抽取，我们就可以让新样本与原始样本不同，因为有些员工可能会被抽到一次以上，其他人则完全不会。</p>
<p>为什么这是一个好主意？ 按照平均定律，原始样本的分布可能与总体相似，所有“二次样本”的分布可能与原始样本相似。 因此，所有二次样本的分布也可能与总体相似。</p>
<p><img src="img/11-4.png" alt=""></img></p>
<h3 id="二次样本的中位数">二次样本的中位数</h3>
<p>回想一下，使用<code>sample</code>方法而没有指定样本大小时，默认情况下样本大小等于用于抽取样本的表的行数。 这是完美的自举！ 这是从原始样本中抽取的一个新样本，以及相应的样本中位数。</p>
<pre><code class="lang-py">resample_1 = our_sample.sample()
resample_1.select(<span class="hljs-string">'Total Compensation'</span>).hist(bins=sf_bins)
</code></pre>
<p><img src="img/11-5.png" alt=""></img></p>
<pre><code class="lang-py">resampled_median_1 = percentile(<span class="hljs-number">50</span>, resample_1.column(<span class="hljs-string">'Total Compensation'</span>))
resampled_median_1
<span class="hljs-number">110001.16</span>
</code></pre>
<p>通过重采样，我们有了总体中位数的另一个估计。 通过一次又一次的重采样，我们得到许多这样的估计，因此有了估计的经验分布。</p>
<pre><code class="lang-py">resample_2 = our_sample.sample()
resampled_median_2 = percentile(<span class="hljs-number">50</span>, resample_2.column(<span class="hljs-string">'Total Compensation'</span>))
resampled_median_2
<span class="hljs-number">110261.39999999999</span>
</code></pre>
<h3 id="自举样本中位数的经验分布">自举样本中位数的经验分布</h3>
<p>让我们定义一个函数<code>bootstrap_median</code>，该函数接受我们的原始样本，包含变量的列的标签，以及我们想要的自举样本的数量，并返回二次样本的相应中值的数组。</p>
<p>每次我们重采样并找到中位数，我们重复自举过程。 所以自举样本的数量将被称为重复数量。</p>
<pre><code class="lang-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bootstrap_median</span><span class="hljs-params">(original_sample, label, replications)</span>:</span>
    <span class="hljs-string">"""Returns an array of bootstrapped sample medians:
    original_sample: table containing the original sample
    label: label of column containing the variable
    replications: number of bootstrap samples
    """</span>
    just_one_column = original_sample.select(label)
    medians = make_array()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(replications):
        bootstrap_sample = just_one_column.sample()
        resampled_median = percentile(<span class="hljs-number">50</span>, bootstrap_sample.column(<span class="hljs-number">0</span>))
        medians = np.append(medians, resampled_median)

    <span class="hljs-keyword">return</span> medians
</code></pre>
<p>我们现在将自举过程重复 5000 次。 数组<code>bstrap_medians</code>包含所有 5,000 个自举样本的中位数。 注意代码的运行时间比我们以前的代码要长。 因为要做很多重采样！</p>
<pre><code class="lang-py">bstrap_medians = bootstrap_median(our_sample, <span class="hljs-string">'Total Compensation'</span>, <span class="hljs-number">5000</span>)
</code></pre>
<p>这是 5000 个中位数的直方图。 红点是总体的参数：它是整个总体的中位数，我们碰巧知道但没有在自举过程中使用。</p>
<pre><code class="lang-py">resampled_medians = Table().with_column(<span class="hljs-string">'Bootstrap Sample Median'</span>, bstrap_medians)

<span class="hljs-comment">#median_bins=np.arange(100000, 130000, 2500)</span>
<span class="hljs-comment">#resampled_medians.hist(bins = median_bins)</span>
resampled_medians.hist()

plots.scatter(pop_median, <span class="hljs-number">0</span>, color=<span class="hljs-string">'red'</span>, s=<span class="hljs-number">30</span>);
</code></pre>
<p><img src="img/11-6.png" alt=""></img></p>
<p>重要的是要记住，红点是固定的：110,305.79 美元，总体的中位数。 经验直方图是随机抽取的结果，将相对于红点随机定位。</p>
<p>请记住，所有这些计算的重点是估计人口中位数，它是红点。我们的估计是所有随机生成的样本中位数，它们的直方图你在上面看到了。 我们希望这些估计量包含参数 - 如果没有，它们就脱线了。</p>
<h3 id="估计量是否捕获了参数">估计量是否捕获了参数</h3>
<p>红点正好落在二次样本的中位数的经验直方图中间，而不是尾部的几率有多少？ 要回答这个问题，我们必须定义“中间”。 让我们将它看做“红点落在二次样本的中位数的中间 95%”。</p>
<p>以下是二次采样中位数的“中间 95%”的两端：</p>
<pre><code class="lang-py">left = percentile(<span class="hljs-number">2.5</span>, bstrap_medians)
left
<span class="hljs-number">107652.71000000001</span>
right = percentile(<span class="hljs-number">97.5</span>, bstrap_medians)
right
<span class="hljs-number">119256.73</span>
</code></pre>
<p>总体中位数 110,305 美元在这两个数中间。下面的直方图展示了区间和总体中位数。</p>
<pre><code class="lang-py"><span class="hljs-comment">#median_bins=np.arange(100000, 130000, 2500)</span>
<span class="hljs-comment">#resampled_medians.hist(bins = median_bins)</span>
resampled_medians.hist()

plots.plot(make_array(left, right), make_array(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), color=<span class="hljs-string">'yellow'</span>, lw=<span class="hljs-number">3</span>, zorder=<span class="hljs-number">1</span>)
plots.scatter(pop_median, <span class="hljs-number">0</span>, color=<span class="hljs-string">'red'</span>, s=<span class="hljs-number">30</span>, zorder=<span class="hljs-number">2</span>);
</code></pre>
<p><img src="img/11-7.png" alt=""></img></p>
<p>我们例子中，估计量的“中间 95%”的区间捕获了参数。 但是，这是一个偶然吗？</p>
<p>要查看区间包含参数的频率，我们必须一遍又一遍地运行整个过程。具体而言，我们将重复以下过程 100 次：</p>
<ul>
<li>从总体中抽取一个大小为 500 的原始样本。</li>
<li>执行 5000 次重复的自举过程，并生成二次样本的中位数的“中间 95％”的区间。</li>
<li>我们最后得到了 100 个区间，并计算其中有多少个包含总体中位数。</li>
</ul>
<p>剧透警告：自举的统计理论表明，这个数字应该在 95 左右。它可能高于或低于 95，但不会离得太远。</p>
<pre><code class="lang-py"><span class="hljs-comment"># THE BIG SIMULATION: This one takes several minutes.</span>

<span class="hljs-comment"># Generate 100 intervals, in the table intervals</span>

left_ends = make_array()
right_ends = make_array()

total_comps = sf2015.select(<span class="hljs-string">'Total Compensation'</span>)

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(<span class="hljs-number">100</span>):
    first_sample = total_comps.sample(<span class="hljs-number">500</span>, with_replacement=<span class="hljs-keyword">False</span>)
    medians = bootstrap_median(first_sample, <span class="hljs-string">'Total Compensation'</span>, <span class="hljs-number">5000</span>)
    left_ends = np.append(left_ends, percentile(<span class="hljs-number">2.5</span>, medians))
    right_ends = np.append(right_ends, percentile(<span class="hljs-number">97.5</span>, medians))

intervals = Table().with_columns(
    <span class="hljs-string">'Left'</span>, left_ends,
    <span class="hljs-string">'Right'</span>, right_ends
)
</code></pre>
<p>对于 100 个重复中的每个，我们得到了一个中位数估计量的区间。</p>
<pre><code class="lang-py">intervals
</code></pre>
<table>
<thead>
<tr>
<th>Left</th>
<th>Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>100547</td>
<td>115112</td>
</tr>
<tr>
<td>98788.4</td>
<td>112129</td>
</tr>
<tr>
<td>107981</td>
<td>121218</td>
</tr>
<tr>
<td>100965</td>
<td>114796</td>
</tr>
<tr>
<td>102596</td>
<td>112056</td>
</tr>
<tr>
<td>105386</td>
<td>113909</td>
</tr>
<tr>
<td>105225</td>
<td>116918</td>
</tr>
<tr>
<td>102844</td>
<td>116712</td>
</tr>
<tr>
<td>106584</td>
<td>118054</td>
</tr>
<tr>
<td>108451</td>
<td>118421</td>
</tr>
</tbody>
</table>
<p>（省略了 90 行）</p>
<p>良好的区间是那些包含我们试图估计的参数的区间。 通常参数是未知的，但在本节中，我们碰巧知道参数是什么。</p>
<pre><code class="lang-py">pop_median
<span class="hljs-number">110305.78999999999</span>
</code></pre>
<p>100 个区间中有多少个包含总体中位数？ 这是左端低于且右端高于总体中位数的区间数量。</p>
<pre><code class="lang-py">intervals.where(<span class="hljs-string">'Left'</span>, are.below(pop_median)).where(<span class="hljs-string">'Right'</span>, are.above(pop_median)).num_rows
<span class="hljs-number">95</span>
</code></pre>
<p>构建所有区间需要花费几分钟时间，但如果你有耐心，请再试一次。最有可能的是，100 个区间中有大约 95 个将是良好的：它们将包含参数。</p>
<p>因为它们有较大的重叠，所以很难在横轴上显示所有的区间 - 毕竟，它们都试图估计相同的参数。下图通过竖直堆叠，在相同轴域上展示的每个区间。纵轴简单地是重复的序号，区间从中生成。</p>
<p>红线是参数所在的位置。良好的区间覆盖了参数；通常有大约 95 个。</p>
<p>如果一个区间不能覆盖这个参数，就是个糟糕的事情。在这个地方，你可以看到红线周围的“亮光”。他们中只有很少 - 通常是大约 5 个 - 但是他们确实存在。</p>
<p>任何基于抽样的方法都有可能脱线。基于随机抽样的方法的优点是，我们可以量化它们可能脱线的频率。</p>
<p><img src="img/11-8.png" alt=""></img></p>
<p>为了总结模拟所示的内容，假设你通过以下过程来估计总体中位数：</p>
<p>从总体中随机抽取一个大样本。
自举你的随机样本，并从新的随机样本中获取估计量。
重复上述步骤数千次，并获得数千个估计量。
挑选所有估计量的“中间 95％”的区间。
这给了你一个估计量的区间。现在，如果重复整个过程 100 次，会得到 100 个区间，那么 100 个区间中的大约 95 个将包含总体的参数。</p>
<p>换句话说，95% 的时间内，这个估计过程捕获了参数。</p>
<p>你可以用一个不同的值代替 95%，只要它不是 100。假设你用 80% 代替了 95%，并保持样本大小为 500。那么你的估计量的区间将比我们这里的模拟要短，因为“中间 80％”是比“中间 95％”更小的范围。只有大约 80% 的区间将包含参数。</p>
<h2 id="置信区间">置信区间</h2>
<p>我们已经开发了一种方法，通过使用随机抽样和自举来估计参数。我们的方法产生一个估计区间，来解释随机样本的机会变异。通过提供一个估计区间而不是一个估计量，我们给自己一些回旋的余地。</p>
<p>在前面的例子中，我们看到我们的估计过程在 95% 的时间内产生了一个良好的区间，一个“良好”的区间就是包含这个参数的区间。对于这个过程的结果很好，我们说我们有 95% 的置信度（信心）。我们的估计区间称为参数的 95% 置信区间，95% 称为区间的置信度。</p>
<p>前一个例子中的情况有点不寻常。因为我们碰巧知道参数的值，所以我们能够检查一个区间是好还是不好，这反过来又帮助我们看到，我们的估计过程每 100 次中有 95 次捕获了参数。</p>
<p>但通常情况下，数据科学家不知道参数的值。这就是他们首先想要估计的原因。在这种情况下，他们通过使用一些方法，类似我们开发的方法，获得未知参数的估计区间。由于统计理论，和我们所看到的演示，数据科学家可以确信，他们产生区间的过程，会以已知百分比的几率，产生一个良好的区间。</p>
<h3 id="总体中位数的置信区间：自举百分位数方法">总体中位数的置信区间：自举百分位数方法</h3>
<p>现在我们使用自举法来估计未知总体的中位数。 数据来自大型医院系统中的新生儿样本; 我们将把它看作是一个简单的随机样本，虽然抽样分多个阶段完成。 Deborah Nolan 和 Terry Speed 的 Stat Labs 拥有一个大数据集的详细信息，这个样本是从中抽取的。</p>
<p><code>baby</code>表中包含以下母婴偶对的数量：婴儿的出生体重（盎司），孕期天数，母亲的年龄，母亲身高（英寸），孕期体重（磅），母亲是否在孕期吸烟。</p>
<pre><code class="lang-py">baby = Table.read_table(<span class="hljs-string">'baby.csv'</span>)
baby
</code></pre>
<table>
<thead>
<tr>
<th>Birth Weight</th>
<th>Gestational Days</th>
<th>Maternal Age</th>
<th>Maternal Height</th>
<th>Maternal Pregnancy Weight</th>
<th>Maternal Smoker</th>
</tr>
</thead>
<tbody>
<tr>
<td>120</td>
<td>284</td>
<td>27</td>
<td>62</td>
<td>100</td>
<td>False</td>
</tr>
<tr>
<td>113</td>
<td>282</td>
<td>33</td>
<td>64</td>
<td>135</td>
<td>False</td>
</tr>
<tr>
<td>128</td>
<td>279</td>
<td>28</td>
<td>64</td>
<td>115</td>
<td>True</td>
</tr>
<tr>
<td>108</td>
<td>282</td>
<td>23</td>
<td>67</td>
<td>125</td>
<td>True</td>
</tr>
<tr>
<td>136</td>
<td>286</td>
<td>25</td>
<td>62</td>
<td>93</td>
<td>False</td>
</tr>
<tr>
<td>138</td>
<td>244</td>
<td>33</td>
<td>62</td>
<td>178</td>
<td>False</td>
</tr>
<tr>
<td>132</td>
<td>245</td>
<td>23</td>
<td>65</td>
<td>140</td>
<td>False</td>
</tr>
<tr>
<td>120</td>
<td>289</td>
<td>25</td>
<td>62</td>
<td>125</td>
<td>False</td>
</tr>
<tr>
<td>143</td>
<td>299</td>
<td>30</td>
<td>66</td>
<td>136</td>
<td>True</td>
</tr>
<tr>
<td>140</td>
<td>351</td>
<td>27</td>
<td>68</td>
<td>120</td>
<td>False</td>
</tr>
</tbody>
</table>
<p>（省略了 1164 行）</p>
<p>出生体重是新生儿健康的一个重要因素 - 较小的婴儿比较大的婴儿在初期需要更多的医疗护理。 因此，在婴儿出生前估计出生体重是有帮助的。 一种方法是检查出生体重和怀孕天数之间的关系。</p>
<p>这种关系的一个简单的衡量标准是出生体重与怀孕天数的比值。<code>ratios</code>表包含<code>baby</code>的前两列，以及一列<code>ratios</code>。 这一列的第一个条目按以下方式计算：</p>
<p><img src="img/tex-11-1.gif" alt=""></img></p>
<pre><code class="lang-py">ratios = baby.select(<span class="hljs-string">'Birth Weight'</span>, <span class="hljs-string">'Gestational Days'</span>).with_column(
    <span class="hljs-string">'Ratio BW/GD'</span>, baby.column(<span class="hljs-string">'Birth Weight'</span>)/baby.column(<span class="hljs-string">'Gestational Days'</span>)
)
ratios
</code></pre>
<table>
<thead>
<tr>
<th>Birth Weight</th>
<th>Gestational Days</th>
<th>Ratio BW/GD</th>
</tr>
</thead>
<tbody>
<tr>
<td>120</td>
<td>284</td>
<td>0.422535</td>
</tr>
<tr>
<td>113</td>
<td>282</td>
<td>0.400709</td>
</tr>
<tr>
<td>128</td>
<td>279</td>
<td>0.458781</td>
</tr>
<tr>
<td>108</td>
<td>282</td>
<td>0.382979</td>
</tr>
<tr>
<td>136</td>
<td>286</td>
<td>0.475524</td>
</tr>
<tr>
<td>138</td>
<td>244</td>
<td>0.565574</td>
</tr>
<tr>
<td>132</td>
<td>245</td>
<td>0.538776</td>
</tr>
<tr>
<td>120</td>
<td>289</td>
<td>0.415225</td>
</tr>
<tr>
<td>143</td>
<td>299</td>
<td>0.478261</td>
</tr>
<tr>
<td>140</td>
<td>351</td>
<td>0.39886</td>
</tr>
</tbody>
</table>
<p>（省略了 1164 行）</p>
<pre><code class="lang-py">ratios.select(<span class="hljs-string">'Ratio BW/GD'</span>).hist()
</code></pre>
<p><img src="img/11-9.png" alt=""></img></p>
<p>一眼望去，直方图看起来相当对称，密度在 4opd 到 4.5opd 的区间内是最大的。 但仔细一看，就可以看出一些比例相当大。 比率的最大值刚好超过 0.78opd，几乎是通常值的两倍。</p>
<pre><code class="lang-py">ratios.sort(<span class="hljs-string">'Ratio BW/GD'</span>, descending=<span class="hljs-keyword">True</span>).take(<span class="hljs-number">0</span>)
</code></pre>
<table>
<thead>
<tr>
<th>Birth Weight</th>
<th>Gestational Days</th>
<th>Ratio BW/GD</th>
</tr>
</thead>
<tbody>
<tr>
<td>116</td>
<td>148</td>
<td>0.783784</td>
</tr>
</tbody>
</table>
<p>中位数提供了通常比例的感觉，因为它不受非常大或非常小的比例的影响。 样本（比值）的中位数约为 0.429opd。</p>
<pre><code class="lang-py">np.median(ratios.column(<span class="hljs-number">2</span>))
<span class="hljs-number">0.42907801418439717</span>
</code></pre>
<p>但是总体中位数是多少？ 我们不知道，所以我们会估计它。</p>
<p>我们的方法将与前一节完全相同。 我们将自举样本 5000 次，结果是 5000 个中位数的估计量。 我们 95% 的置信区间将是我们所有估计量的“中间 95%”。</p>
<p>回忆前一节定义的<code>bootstrap_median</code>函数。 我们将调用这个函数，并构造总体（比值）中位数的 95% 置信区间。请记住，<code>ratios</code>表包含来自我们的原始样本的相关数据。</p>
<pre><code class="lang-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bootstrap_median</span><span class="hljs-params">(original_sample, label, replications)</span>:</span>

    <span class="hljs-string">"""Returns an array of bootstrapped sample medians:
    original_sample: table containing the original sample
    label: label of column containing the variable
    replications: number of bootstrap samples
    """</span>

    just_one_column = original_sample.select(label)
    medians = make_array()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(replications):
        bootstrap_sample = just_one_column.sample()
        resampled_median = percentile(<span class="hljs-number">50</span>, bootstrap_sample.column(<span class="hljs-number">0</span>))
        medians = np.append(medians, resampled_median)

    <span class="hljs-keyword">return</span> medians
<span class="hljs-comment"># Generate the medians from 5000 bootstrap samples</span>
bstrap_medians = bootstrap_median(ratios, <span class="hljs-string">'Ratio BW/GD'</span>, <span class="hljs-number">5000</span>)
<span class="hljs-comment"># Get the endpoints of the 95% confidence interval</span>
left = percentile(<span class="hljs-number">2.5</span>, bstrap_medians)
right = percentile(<span class="hljs-number">97.5</span>, bstrap_medians)

make_array(left, right)
array([ <span class="hljs-number">0.42545455</span>,  <span class="hljs-number">0.43262411</span>])
</code></pre>
<p>95% 置信区间是 0.425opd 到 0.433opd。 我们估计的总体（出生重量与怀孕天数的比值）中位数，在 0.425opd 到 0.433opd 的范围内。</p>
<p>基于原始样本的估计量 0.429 恰好在区间两端的中间，尽管这通常不是真的。</p>
<p>为了使我们的结果可视化，让我们画出我们自举的中位数的经验直方图，并将置信区间置于横轴上。</p>
<pre><code class="lang-py">resampled_medians = Table().with_column(
    <span class="hljs-string">'Bootstrap Sample Median'</span>, bstrap_medians
)
resampled_medians.hist(bins=<span class="hljs-number">15</span>)
plots.plot(make_array(left, right), make_array(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), color=<span class="hljs-string">'yellow'</span>, lw=<span class="hljs-number">8</span>);
</code></pre>
<p><img src="img/11-10.png" alt=""></img></p>
<p>这个直方图和区间就像我们在前一节中绘制的直方图和区间，只有一个很大的区别 - 没有显示参数的红点。 我们不知道这个点应该在哪里，或者它是否在区间中。</p>
<p>我们只是有一个估计区间。 这是估计量的 95% 置信区间，因为生成它的过程在 95% 的时间中产生了良好的区间。 那肯定是在随机猜测！</p>
<p>请记住，这个区间是一个大约 95% 的置信区间。 计算中涉及到很多近似值。 近似值并不差，但并不准确。</p>
<h3 id="总体均值的置信区间：自举百分位数方法">总体均值的置信区间：自举百分位数方法</h3>
<p>我们为中位数所做的事情也可以用于均值。 假设我们想估计总体中的母亲的平均年龄。 自然估计量是样本中的母亲的平均年龄。 这是他们的年龄分布，他们的平均年龄大约是 27.2 岁。</p>
<pre><code class="lang-py">baby.select(<span class="hljs-string">'Maternal Age'</span>).hist()
</code></pre>
<p><img src="img/11-11.png" alt=""></img></p>
<pre><code class="lang-py">np.mean(baby.column(<span class="hljs-string">'Maternal Age'</span>))
<span class="hljs-number">27.228279386712096</span>
</code></pre>
<p>母亲的平均年龄是多少？ 我们不知道这个参数的值。</p>
<p>我们用自举法来估计未知参数。 为此，我们将编辑<code>bootstrap_median</code>的代码，而不是定义函数<code>bootstrap_mean</code>。 代码是相同的，除了统计量是代替中位数的均值，并且收集在一个名为<code>means</code>而不是<code>medians</code>的数组中。</p>
<pre><code class="lang-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bootstrap_mean</span><span class="hljs-params">(original_sample, label, replications)</span>:</span>

    <span class="hljs-string">"""Returns an array of bootstrapped sample means:
    original_sample: table containing the original sample
    label: label of column containing the variable
    replications: number of bootstrap samples
    """</span>

    just_one_column = original_sample.select(label)
    means = make_array()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(replications):
        bootstrap_sample = just_one_column.sample()
        resampled_mean = np.mean(bootstrap_sample.column(<span class="hljs-number">0</span>))
        means = np.append(means, resampled_mean)

    <span class="hljs-keyword">return</span> means
<span class="hljs-comment"># Generate the means from 5000 bootstrap samples</span>
bstrap_means = bootstrap_mean(baby, <span class="hljs-string">'Maternal Age'</span>, <span class="hljs-number">5000</span>)

<span class="hljs-comment"># Get the endpoints of the 95% confidence interval</span>
left = percentile(<span class="hljs-number">2.5</span>, bstrap_means)
right = percentile(<span class="hljs-number">97.5</span>, bstrap_means)

make_array(left, right)
array([ <span class="hljs-number">26.89778535</span>,  <span class="hljs-number">27.55962521</span>])
</code></pre>
<p>95% 置信区间是约 26.9 岁到约 27.6 岁。 也就是说，我们估计的母亲的平均年龄在 26.9 岁到 27.6 岁之间。</p>
<p>注意两端距原始样本均值 27.2 岁的距离。 样本量非常大 - 1174 个母亲 - 所以样本均值变化不大。 我们将在下一章进一步探讨这个观察。</p>
<p>下面显示了 5000 个自举均值的经验直方图，以及总体均值的 95% 置信区间。</p>
<pre><code class="lang-py">resampled_means = Table().with_column(
    <span class="hljs-string">'Bootstrap Sample Mean'</span>, bstrap_means
)
resampled_means.hist(bins=<span class="hljs-number">15</span>)
plots.plot(make_array(left, right), make_array(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), color=<span class="hljs-string">'yellow'</span>, lw=<span class="hljs-number">8</span>);
</code></pre>
<p><img src="img/11-12.png" alt=""></img></p>
<p>原始样本的均值（27.23 岁）同样接近区间中心。 这并不奇怪，因为每个自举样本都是从相同的原始样本中抽取的。 自举样本的均值大约对称分布原始样本（从其中抽取）的均值的两侧。</p>
<p>还要注意，即使所采样的年龄的直方图完全不是对称的，二次样本的均值的经验直方图也是大致对称的钟形：</p>
<pre><code class="lang-py">baby.select(<span class="hljs-string">'Maternal Age'</span>).hist()
</code></pre>
<p><img src="img/11-13.png" alt=""></img></p>
<p>这是概率统计的中心极限定理的结果。 在后面的章节中，我们将看到这个定理是什么。</p>
<h3 id="80-置信区间">80% 置信区间</h3>
<p>你可以使用自举法来构建任意水平的置信区间。 例如，要为总体中的平均年龄构建 80% 置信区间，可以选取二次样本的均值的“中间 80%”。 所以你会希望为两个尾巴的每一个分配 10%，因此端点是二次样本的均值的第 10 和第 90 个百分位数。</p>
<pre><code class="lang-py">left_80 = percentile(<span class="hljs-number">10</span>, bstrap_means)
right_80 = percentile(<span class="hljs-number">90</span>, bstrap_means)
make_array(left_80, right_80)
array([ <span class="hljs-number">27.01192504</span>,  <span class="hljs-number">27.439523</span>  ])
resampled_means.hist(bins=<span class="hljs-number">15</span>)
plots.plot(make_array(left_80, right_80), make_array(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), color=<span class="hljs-string">'yellow'</span>, lw=<span class="hljs-number">8</span>);
</code></pre>
<p><img src="img/11-14.png" alt=""></img></p>
<p>这个 80% 置信区间比 95% 置信区间要短得多。 它只是约定 27.0 岁到约 27.4 岁。 虽然这是估计量的较窄区间，你知道这个过程在 80% 的时间内产生良好的区间。</p>
<p>之前过程产生了较宽的区间，但是我们对产生它的过程拥有更高的置信度。</p>
<p>为了以较高的置信度获得较窄的置信区间，你必须从较大的样本开始。 我们将在下一章看到为什么。</p>
<h3 id="总体比例的置信区间：自举百分位数方法">总体比例的置信区间：自举百分位数方法</h3>
<p>在样本中，39% 的母亲在怀孕期间吸烟。</p>
<pre><code class="lang-py">baby.where(<span class="hljs-string">'Maternal Smoker'</span>, are.equal_to(<span class="hljs-keyword">True</span>)).num_rows/baby.num_rows
<span class="hljs-number">0.3909710391822828</span>
</code></pre>
<p>以下对观察很实用，这个比例也可以通过数组操作来计算：</p>
<pre><code class="lang-py">smoking = baby.column(<span class="hljs-string">'Maternal Smoker'</span>)
np.count_nonzero(smoking)/len(smoking)
<span class="hljs-number">0.3909710391822828</span>
</code></pre>
<blockquote>
<p>译者注：</p>
<p><code>np.count_nonzero(arr)</code>等价于<code>np.sum(arr != 0)</code>。</p>
</blockquote>
<p>总体中有百分之多少的母亲在怀孕期间吸烟？ 这是一个未知的参数，我们可以通过自举置信区间来估计。 这个过程中的步骤与我们用来估计总体均值和中位数的步骤相似。</p>
<p>我们将首先定义一个函数<code>bootstrap_proportion</code>，返回一个自举样本的比例的数组。 我们再一次通过编辑<code>bootstrap_median</code>的定义来实现它。 计算中唯一的变化是用二次样本的吸烟者比例代替中位数。 该代码假定数据列由布尔值组成。 其他的改变只是数组的名字，来帮助我们阅读和理解我们的代码。</p>
<pre><code class="lang-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bootstrap_proportion</span><span class="hljs-params">(original_sample, label, replications)</span>:</span>

    <span class="hljs-string">"""Returns an array of bootstrapped sample proportions:
    original_sample: table containing the original sample
    label: label of column containing the Boolean variable
    replications: number of bootstrap samples
    """</span>

    just_one_column = original_sample.select(label)
    proportions = make_array()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(replications):
        bootstrap_sample = just_one_column.sample()
        resample_array = bootstrap_sample.column(<span class="hljs-number">0</span>)
        resampled_proportion = np.count_nonzero(resample_array)/len(resample_array)
        proportions = np.append(proportions, resampled_proportion)

    <span class="hljs-keyword">return</span> proportions
</code></pre>
<p>让我们使用<code>bootstrap_proportion</code>来构建总体的母亲吸烟者百分比的 95% 置信区间。 该代码类似于均值和中位数的相应代码。</p>
<pre><code class="lang-py"><span class="hljs-comment"># Generate the proportions from 5000 bootstrap samples</span>
bstrap_props = bootstrap_proportion(baby, <span class="hljs-string">'Maternal Smoker'</span>, <span class="hljs-number">5000</span>)

<span class="hljs-comment"># Get the endpoints of the 95% confidence interval</span>
left = percentile(<span class="hljs-number">2.5</span>, bstrap_props)
right = percentile(<span class="hljs-number">97.5</span>, bstrap_props)

make_array(left, right)
array([ <span class="hljs-number">0.36286201</span>,  <span class="hljs-number">0.41908007</span>])
</code></pre>
<p>置信区间是 36% 到 42%。原始样本的百分比 39% 非常接近于区间的中心。你可以在下面看到：</p>
<pre><code class="lang-py">resampled_proportions = Table().with_column(
    <span class="hljs-string">'Bootstrap Sample Proportion'</span>, bstrap_props
)
resampled_proportions.hist(bins=<span class="hljs-number">15</span>)
plots.plot(make_array(left, right), make_array(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), color=<span class="hljs-string">'yellow'</span>, lw=<span class="hljs-number">8</span>);
</code></pre>
<p><img src="img/11-15.png" alt=""></img></p>
<h3 id="自举法的注意事项">自举法的注意事项</h3>
<p>自举法是一个优雅而强大的方法。在使用之前，记住一些要点非常重要。</p>
<p>以大型随机样本开始。如果你不这样做，该方法可能无法正常工作。它的成功基于大型随机样本（因此也从样本中重采样）。平均定律说，如果随机样本很大，这很可能是真的。</p>
<p>为了近似统计量的概率分布，最好多次复制重采样过程。数千次重复将产生样本中位数分布的正确近似，特别是如果总体分布存在峰值并且不是非常不对称的话。在我们的例子中，我们使用了 5000 次重复，但一般会推荐 10000 次。</p>
<p>自举百分位数方法适用于基于大型随机样本，估计总体中位数或均值。但是，它也有其局限性，所有的估计方法也是如此。例如，在以下情况下，它预期没有效果。</p>
<ul>
<li>目标是估计总体中的最小值或最大值，或非常低或非常高的百分位数，或受总体中稀有元素影响较大的参数。</li>
<li>统计量的概率分布不是近似钟形的。</li>
<li>原始样本非常小，比如 10 或 15。</li>
</ul>
<h2 id="使用置信区间">使用置信区间</h2>
<pre><code class="lang-py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bootstrap_median</span><span class="hljs-params">(original_sample, label, replications)</span>:</span>

    <span class="hljs-string">"""Returns an array of bootstrapped sample medians:
    original_sample: table containing the original sample
    label: label of column containing the variable
    replications: number of bootstrap samples
    """</span>

    just_one_column = original_sample.select(label)
    medians = make_array()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(replications):
        bootstrap_sample = just_one_column.sample()
        resampled_median = percentile(<span class="hljs-number">50</span>, bootstrap_sample.column(<span class="hljs-number">0</span>))
        medians = np.append(medians, resampled_median)

    <span class="hljs-keyword">return</span> medians
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bootstrap_mean</span><span class="hljs-params">(original_sample, label, replications)</span>:</span>

    <span class="hljs-string">"""Returns an array of bootstrapped sample means:
    original_sample: table containing the original sample
    label: label of column containing the variable
    replications: number of bootstrap samples
    """</span>

    just_one_column = original_sample.select(label)
    means = make_array()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(replications):
        bootstrap_sample = just_one_column.sample()
        resampled_mean = np.mean(bootstrap_sample.column(<span class="hljs-number">0</span>))
        means = np.append(means, resampled_mean)

    <span class="hljs-keyword">return</span> means
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bootstrap_proportion</span><span class="hljs-params">(original_sample, label, replications)</span>:</span>

    <span class="hljs-string">"""Returns an array of bootstrapped sample proportions:
    original_sample: table containing the original sample
    label: label of column containing the Boolean variable
    replications: number of bootstrap samples
    """</span>

    just_one_column = original_sample.select(label)
    proportions = make_array()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> np.arange(replications):
        bootstrap_sample = just_one_column.sample()
        resample_array = bootstrap_sample.column(<span class="hljs-number">0</span>)
        resampled_proportion = np.count_nonzero(resample_array)/len(resample_array)
        proportions = np.append(proportions, resampled_proportion)

    <span class="hljs-keyword">return</span> proportions
</code></pre>
<p>置信区间只有一个目的 - 根据随机样本中的数据估计未知参数。在最后一节中，我们说区间<code>(36%, 42%)</code>是总体中吸烟者百分比的约 95% 的置信区间。正式的表述方式为，据我们估计，总体中的吸烟者比例在 36% 到 42% 之间，我们的估计过程在 95% 的时间内是正确的。</p>
<p>克制住将置信区间用于其他目的的冲动，这很重要。例如，回想一下，我们计算了区间<code>(26.9 yr, 27.6 yr)</code>，作为母亲平均年龄的约 95% 的置信区间。区间的一个令人惊讶的常见误用是得出这样的结论，约 95% 的女性在 26.9 岁至 27.6 岁之间。你不需要怎么了解置信区间，来查看这是不是正确的 - 你不会预计 95% 的母亲的年龄在这个较小的范围内。实际上，抽样年龄的直方图显示出相当多的变化。</p>
<pre><code class="lang-py">baby = Table.read_table(<span class="hljs-string">'baby.csv'</span>)
baby.select(<span class="hljs-string">'Maternal Age'</span>).hist()
</code></pre>
<p><img src="img/11-16.png" alt=""></img></p>
<p>抽样年龄的一小部分在<code>(26.9, 27.6)</code>的区间内，你可能会预计总体中的百分比很小。 区间只是估计一个数字：总体中所有年龄的平均值。</p>
<p>但是，除了仅仅告诉我们这个参数有多大之外，用置信区间来估计一个参数确实有重要的用处。</p>
<h3 id="使用置信区间来检验假设">使用置信区间来检验假设</h3>
<p>我们总体（年龄）均值的 95% 置信区间是 26.9 岁到 27.6 岁。假设有人想要测试以下假设：</p>
<p>原假设。人口的平均年龄是 30 岁。</p>
<p>备选假设。人口的平均年龄不是 30 岁。</p>
<p>那么，如果你使用 5% 的截断值作为 P 值，则会拒绝原假设。这是因为总体平均值 30 不在 95% 置信区间内。在 5% 的显着性水平上，30 对于人口平均值并不合理。</p>
<p>置信区间的使用是置信区间和检验之间二元性结果：如果你正在测试总体平均值是否是特定值 x，并且你使用的 5% 截断值作为 P 值，那么如果 x 不在平均值的 95% 置信区间内，你将拒绝原零假设。</p>
<p>这可以由统计理论来确定。在实践中，它只是归结为，检查原假设中指定的值是否在置信区间内。</p>
<p>如果你使用 1% 的截断值作为 P 值，你必须检查，原假设中指定的值是否在总体均值的 99% 置信区间内。</p>
<p>粗略地说，如果样本量很大，这些陈述也适用于总体比例。</p>
<p>虽然我们现在有一种方法，使用置信区间来检验一种特定假设，但是你可能想知道，测试总体（年龄）的均值是否等于 30 的意义。实际上，这个意义并不清楚。但是在某些情况下，对这种假设的检验既自然又有用。</p>
<p>我们将在数据的背景下来研究它，这些数据是霍奇金病治疗的随机对照试验中收集的信息的子集。霍奇金病是一种通常影响年轻人的癌症。这种疾病是可以治愈的，但治疗可能非常艰难。该试验的目的是找出治疗癌症的剂量，并且将对患者的不利影响最小化。</p>
<p>这张表格包含治疗对 22 名患者肺部的影响的数据。这些列是：</p>
<ul>
<li>身高（厘米）</li>
<li>覆盖物辐射的测量（颈部，胸部，手臂下）</li>
<li>化疗的测量</li>
<li>基线下，即在治疗开始时的肺健康得分；较高的分数对应于更健康的肺</li>
<li>治疗后 15 个月，相同的肺的健康得分</li>
</ul>
<pre><code class="lang-py">hodgkins = Table.read_table(<span class="hljs-string">'hodgkins.csv'</span>)
hodgkins
</code></pre>
<table>
<thead>
<tr>
<th>height</th>
<th>rad</th>
<th>chemo</th>
<th>base</th>
<th>month15</th>
</tr>
</thead>
<tbody>
<tr>
<td>164</td>
<td>679</td>
<td>180</td>
<td>160.57</td>
<td>87.77</td>
</tr>
<tr>
<td>168</td>
<td>311</td>
<td>180</td>
<td>98.24</td>
<td>67.62</td>
</tr>
<tr>
<td>173</td>
<td>388</td>
<td>239</td>
<td>129.04</td>
<td>133.33</td>
</tr>
<tr>
<td>157</td>
<td>370</td>
<td>168</td>
<td>85.41</td>
<td>81.28</td>
</tr>
<tr>
<td>160</td>
<td>468</td>
<td>151</td>
<td>67.94</td>
<td>79.26</td>
</tr>
<tr>
<td>170</td>
<td>341</td>
<td>96</td>
<td>150.51</td>
<td>80.97</td>
</tr>
<tr>
<td>163</td>
<td>453</td>
<td>134</td>
<td>129.88</td>
<td>69.24</td>
</tr>
<tr>
<td>175</td>
<td>529</td>
<td>264</td>
<td>87.45</td>
<td>56.48</td>
</tr>
<tr>
<td>185</td>
<td>392</td>
<td>240</td>
<td>149.84</td>
<td>106.99</td>
</tr>
<tr>
<td>178</td>
<td>479</td>
<td>216</td>
<td>92.24</td>
<td>73.43</td>
</tr>
</tbody>
</table>
<p>（省略了 12 行）</p>
<p>我们将比较基准和 15 个月的得分。 由于每行对应一个病人，我们说基线得分的样本和 15 个月得分的样本是成对的 - 它们不是每组 22 个值的两组，而是 22 对值，每个病人一个。</p>
<p>一眼望去，你可以看到，15 个月的得分往往低于基线得分 - 抽样患者的肺似乎在治疗后 15 个月更差。 这个由<code>drop</code>列主要是正值来证实，它是基线得分减去 15 个月的得分。</p>
<pre><code class="lang-py">hodgkins = hodgkins.with_column(
    <span class="hljs-string">'drop'</span>, hodgkins.column(<span class="hljs-string">'base'</span>) - hodgkins.column(<span class="hljs-string">'month15'</span>)
)
hodgkins
</code></pre>
<p><img src="img/11-17.png" alt=""></img></p>
<table>
<thead>
<tr>
<th>height</th>
<th>rad</th>
<th>chemo</th>
<th>base</th>
<th>month15</th>
<th>drop</th>
</tr>
</thead>
<tbody>
<tr>
<td>164</td>
<td>679</td>
<td>180</td>
<td>160.57</td>
<td>87.77</td>
<td>72.8</td>
</tr>
<tr>
<td>168</td>
<td>311</td>
<td>180</td>
<td>98.24</td>
<td>67.62</td>
<td>30.62</td>
</tr>
<tr>
<td>173</td>
<td>388</td>
<td>239</td>
<td>129.04</td>
<td>133.33</td>
<td>-4.29</td>
</tr>
<tr>
<td>157</td>
<td>370</td>
<td>168</td>
<td>85.41</td>
<td>81.28</td>
<td>4.13</td>
</tr>
<tr>
<td>160</td>
<td>468</td>
<td>151</td>
<td>67.94</td>
<td>79.26</td>
<td>-11.32</td>
</tr>
<tr>
<td>170</td>
<td>341</td>
<td>96</td>
<td>150.51</td>
<td>80.97</td>
<td>69.54</td>
</tr>
<tr>
<td>163</td>
<td>453</td>
<td>134</td>
<td>129.88</td>
<td>69.24</td>
<td>60.64</td>
</tr>
<tr>
<td>175</td>
<td>529</td>
<td>264</td>
<td>87.45</td>
<td>56.48</td>
<td>30.97</td>
</tr>
<tr>
<td>185</td>
<td>392</td>
<td>240</td>
<td>149.84</td>
<td>106.99</td>
<td>42.85</td>
</tr>
<tr>
<td>178</td>
<td>479</td>
<td>216</td>
<td>92.24</td>
<td>73.43</td>
<td>18.81</td>
</tr>
</tbody>
</table>
<p>（省略了 12 行）</p>
<pre><code class="lang-py">hodgkins.select(<span class="hljs-string">'drop'</span>).hist(bins=np.arange(-<span class="hljs-number">20</span>, <span class="hljs-number">81</span>, <span class="hljs-number">20</span>))
</code></pre>
<pre><code class="lang-py">np.mean(hodgkins.column(<span class="hljs-string">'drop'</span>))
<span class="hljs-number">28.615909090909096</span>
</code></pre>
<p>但是，这可能是机会变异的结果吗？ 似乎并不如此，但数据来自随机样本。 难道在整个人群中，平均下降值只有 0 吗？</p>
<p>为了回答这个问题，我们可以设定两个假设：</p>
<p>原假设：总体（下降值）均值为 0。</p>
<p>备选假设：总体（下降值）均值不为 0。</p>
<p>为了使用 1% 的截断值作为 P 值来验证这个假设，让我们为总体（下降值）均值构建近似 99% 置信区间。</p>
<pre><code class="lang-py">bstrap_means = bootstrap_mean(hodgkins, <span class="hljs-string">'drop'</span>, <span class="hljs-number">10000</span>)

left = percentile(<span class="hljs-number">0.5</span>, bstrap_means)
right = percentile(<span class="hljs-number">99.5</span>, bstrap_means)

make_array(left, right)
array([ <span class="hljs-number">17.25045455</span>,  <span class="hljs-number">40.60136364</span>])
resampled_means = Table().with_column(
    <span class="hljs-string">'Bootstrap Sample Mean'</span>, bstrap_means
)
resampled_means.hist()
plots.plot(make_array(left, right), make_array(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), color=<span class="hljs-string">'yellow'</span>, lw=<span class="hljs-number">8</span>);
</code></pre>
<p><img src="img/11-18.png" alt=""></img></p>
<p>总体均值的 99% 置信区间是约 17 到约 40。区间不包含 0。因此，我们拒绝原假设。</p>
<p>但是请注意，我们所做的不仅仅是简单得出结论：总体均值不是 0，我们估计了均值的幅度是多大。这比仅仅说“不是 0”更有用。</p>
<p>对于准确性的注解：我们的置信区间相当宽泛，主要有两个原因：</p>
<ul>
<li>置信水平很高（99％）。</li>
<li>与我们之前的例子相比，样本量相对较小。</li>
</ul>
<p>在下一章中，我们将研究样本大小如何影响准确性。我们还将研究，样本均值的经验分布为何经常出现钟形，尽管底层数据的分布根本不是钟形的。</p>
<h3 id="尾注">尾注</h3>
<p>一个领域的术语通常来自该领域的主要研究人员。首先提出自举技术的 <a href="https://en.wikipedia.org/wiki/Bradley_Efron" target="_blank">Brad Efron</a> 用了一个<a href="https://en.wikipedia.org/wiki/Bootstrapping" target="_blank">美国血统的术语</a>。中国统计学家不甘示弱，<a href="http://econpapers.repec.org/article/eeestapro/v_3a37_3ay_3a1998_3ai_3a4_3ap_3a321-329.htm" target="_blank">提出了自己的方法</a>。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="10.html" class="navigation navigation-prev " aria-label="Previous page: 十、假设检验">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="12.html" class="navigation navigation-next " aria-label="Next page: 十二、为什么均值重要">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"十一、估计","level":"1.1.12","depth":2,"next":{"title":"十二、为什么均值重要","level":"1.1.13","depth":2,"path":"12.md","ref":"12.md","articles":[]},"previous":{"title":"十、假设检验","level":"1.1.11","depth":2,"path":"10.md","ref":"10.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"11.md","mtime":"2025-04-20T02:47:36.156Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-09T01:10:57.952Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

