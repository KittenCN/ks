
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>四、数据类型 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="5.html" />
    
    
    <link rel="prev" href="3.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    计算与推断思维
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="READ_ME.html">
            
                <a href="READ_ME.html">
            
                    
                    计算与推断思维
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="1.html">
            
                <a href="1.html">
            
                    
                    一、数据科学
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="2.html">
            
                <a href="2.html">
            
                    
                    二、因果和实验
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="3.html">
            
                <a href="3.html">
            
                    
                    三、Python 编程
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.5" data-path="4.html">
            
                <a href="4.html">
            
                    
                    四、数据类型
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="5.html">
            
                <a href="5.html">
            
                    
                    五、表格
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="6.html">
            
                <a href="6.html">
            
                    
                    六、可视化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="7.html">
            
                <a href="7.html">
            
                    
                    七、函数和表格
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="8.html">
            
                <a href="8.html">
            
                    
                    八、随机性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="9.html">
            
                <a href="9.html">
            
                    
                    九、经验分布
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="10.html">
            
                <a href="10.html">
            
                    
                    十、假设检验
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="11.html">
            
                <a href="11.html">
            
                    
                    十一、估计
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="12.html">
            
                <a href="12.html">
            
                    
                    十二、为什么均值重要
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="13.html">
            
                <a href="13.html">
            
                    
                    十三、预测
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.15" data-path="14.html">
            
                <a href="14.html">
            
                    
                    十四、回归的推断
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.16" data-path="15.html">
            
                <a href="15.html">
            
                    
                    十五、分类
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.17" data-path="16.html">
            
                <a href="16.html">
            
                    
                    十六、比较两个样本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.18" data-path="17.html">
            
                <a href="17.html">
            
                    
                    十七、更新预测
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >四、数据类型</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="四、数据类型">四、数据类型</h1>
<blockquote>
<p>原文：<a href="https://github.com/data-8/textbook/tree/gh-pages/chapters/04" target="_blank">Data Types</a></p>
<p>译者：<a href="https://github.com/wizardforcel" target="_blank">飞龙</a></p>
<p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></p>
<p>自豪地采用<a href="https://translate.google.cn/" target="_blank">谷歌翻译</a></p>
</blockquote>
<p>每个值都有一个类型，内建的<code>type</code>函数返回任何表达式的结果的类型：</p>
<pre><code class="lang-py">type(<span class="hljs-number">3</span>)
int
type(<span class="hljs-number">3</span>/<span class="hljs-number">1</span>)
float
</code></pre>
<p>表达式的<code>type</code>是其最终值的类型。 所以，<code>type</code>函数永远不会表明，表达式的类型是一个名称，因为名称总是求值为它们被赋予的值。</p>
<pre><code class="lang-py">x = <span class="hljs-number">3</span>
type(x) <span class="hljs-comment"># The type of x is an int, not a name</span>
int
</code></pre>
<p>我们已经遇到的另一种类型是内置函数。 Python 表明这个类型是一个<code>builtin_function_or_method</code>；函数和方法之间的区别在这个阶段并不重要。</p>
<pre><code class="lang-py">type(abs)
builtin_function_or_method
</code></pre>
<p>这一章会探索其他实用的数据类型。</p>
<h2 id="字符串">字符串</h2>
<p>世界上大部分的数据都是文本，计算机中表示的文本被称为字符串。 字符串可以代表一个单词，一个句子，甚至是图书馆中每本书的内容。 由于文本可以包含数字（如<code>5</code>）或布尔值（<code>True</code>），字符串也可以描述这些东西。</p>
<p>表达式的含义取决于其结构和正在组合的值的类型。 因此，例如，将两个字符串加在一起会产生另一个字符串。 这个表达式仍然是一个加法表达式，但是它组合了一个不同类型的值。</p>
<pre><code class="lang-py"><span class="hljs-string">"data"</span> + <span class="hljs-string">"science"</span>
<span class="hljs-string">'datascience'</span>
</code></pre>
<p>加法完全是字面的；它将这两个字符串组合在一起而不考虑其内容。 它不增加空间，因为这些是不同的词；它取决于程序员（你）来指定。</p>
<pre><code class="lang-py"><span class="hljs-string">"data"</span> + <span class="hljs-string">" "</span> + <span class="hljs-string">"science"</span>
<span class="hljs-string">'data science'</span>
</code></pre>
<p>单引号和双引号都可以用来创建字符串：<code>'hi'</code>和<code>"hi"</code>是相同的表达式。 双引号通常是首选，因为它们允许在字符串中包含单引号。</p>
<pre><code class="lang-py"><span class="hljs-string">"This won't work with a single-quoted string!"</span>
<span class="hljs-string">"This won't work with a single-quoted string!"</span>
</code></pre>
<p>为什么不能？ 试试看。</p>
<p><code>str</code>函数返回任何值的字符串表示形式。 使用此函数，可以构建具有嵌入值的字符串。</p>
<pre><code class="lang-py"><span class="hljs-string">"That's "</span> + str(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>) + <span class="hljs-string">' '</span> + str(<span class="hljs-keyword">True</span>)
<span class="hljs-string">"That's 2 True"</span>
</code></pre>
<h2 id="字符串方法">字符串方法</h2>
<p>可以使用字符串方法，从现有的字符串中构造相关的字符串，这些方法是操作字符串的函数。 这些方法通过在字符串后面放置一个点，然后调用该函数来调用。</p>
<p>例如，以下方法生成一个字符串的大写版本。</p>
<pre><code class="lang-py"><span class="hljs-string">"loud"</span>.upper()
<span class="hljs-string">'LOUD'</span>
</code></pre>
<p>也许最重要的方法是<code>replace</code>，它替换字符串中的所有子字符串的实例。 <code>replace</code>方法有两个参数，即被替换的文本和替代值。</p>
<pre><code class="lang-py"><span class="hljs-string">'hitchhiker'</span>.replace(<span class="hljs-string">'hi'</span>, <span class="hljs-string">'ma'</span>)
<span class="hljs-string">'matchmaker'</span>
</code></pre>
<p>字符串方法也可以使用变量名称进行调用，只要这些名称绑定到字符串。 因此，例如，通过首先创建<code>"ingrain"</code>然后进行第二次替换，以下两个步骤的过程从<code>"train"</code>生成<code>"degrade"</code>一词。</p>
<pre><code class="lang-py">s = <span class="hljs-string">"train"</span>
t = s.replace(<span class="hljs-string">'t'</span>, <span class="hljs-string">'ing'</span>)
u = t.replace(<span class="hljs-string">'in'</span>, <span class="hljs-string">'de'</span>)
u
<span class="hljs-string">'degrade'</span>
</code></pre>
<p>注意<code>t = s.replace('t', 'ing')</code>的一行，不改变字符串<code>s</code>，它仍然是<code>"train"</code>。 方法调用<code>s.replace('t', 'ing')</code>只有一个值，即字符串<code>"ingrain"</code>。</p>
<pre><code class="lang-py">s
<span class="hljs-string">'train'</span>
</code></pre>
<p>这是我们第一次看到方法，但是方法并不是字符串仅有的。 我们将很快看到，其他类型的对象可以拥有它们。</p>
<h2 id="比较">比较</h2>
<p>布尔值通常来自比较运算符。 Python 包含了各种比较值的运算符。 例如，<code>3 &gt; 1 + 1</code>。</p>
<pre><code class="lang-py"><span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span> + <span class="hljs-number">1</span>
<span class="hljs-keyword">True</span>
</code></pre>
<p>值<code>True</code>表明这个比较是有效的；Python 已经证实了<code>3</code>和<code>1 + 1</code>之间关系的这个简单的事实。下面列出了一整套通用的比较运算符。</p>
<table>
<thead>
<tr>
<th>比较</th>
<th>运算符</th>
<th>True 示例</th>
<th>False 示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>小于</td>
<td><code>&lt;</code></td>
<td><code>2 &lt; 3</code></td>
<td><code>2 &lt; 2</code></td>
</tr>
<tr>
<td>大于</td>
<td><code>&gt;</code></td>
<td><code>3 &gt; 2</code></td>
<td><code>3 &gt; 3</code></td>
</tr>
<tr>
<td>小于等于</td>
<td><code>&lt;=</code></td>
<td><code>2 &lt;= 2</code></td>
<td><code>3 &lt;= 2</code></td>
</tr>
<tr>
<td>大于等于</td>
<td><code>&gt;=</code></td>
<td><code>3 &gt;= 3</code></td>
<td><code>2 &gt;= 3</code></td>
</tr>
<tr>
<td>等于</td>
<td><code>==</code></td>
<td><code>3 == 3</code></td>
<td><code>3 == 2</code></td>
</tr>
<tr>
<td>不等于</td>
<td><code>!=</code></td>
<td><code>3 != 2</code></td>
<td><code>2 != 2</code></td>
</tr>
</tbody>
</table>
<p>一个表达式可以包含多个比较，并且为了使整个表达式为真，它们都必须有效。 例如，我们可以用下面的表达式表示<code>1 + 1</code>在<code>1</code>和<code>3</code>之间。</p>
<pre><code class="lang-py"><span class="hljs-number">1</span> &lt; <span class="hljs-number">1</span> + <span class="hljs-number">1</span> &lt; <span class="hljs-number">3</span>
<span class="hljs-keyword">True</span>
</code></pre>
<p>两个数字的平均值总是在较小的数字和较大的数字之间。 我们用下面的数字<code>x</code>和<code>y</code>来表示这种关系。 你可以尝试不同的<code>x</code>和<code>y</code>值来确认这种关系。</p>
<pre><code class="lang-py">x = <span class="hljs-number">12</span>
y = <span class="hljs-number">5</span>
min(x, y) &lt;= (x+y)/<span class="hljs-number">2</span> &lt;= max(x, y)
<span class="hljs-keyword">True</span>
</code></pre>
<p>字符串也可以比较，他们的顺序是字典序。 较短的字符串小于以较短的字符串开头的较长的字符串。</p>
<pre><code class="lang-py"><span class="hljs-string">"Dog"</span> &gt; <span class="hljs-string">"Catastrophe"</span> &gt; <span class="hljs-string">"Cat"</span>
<span class="hljs-keyword">True</span>
</code></pre>
<h2 id="序列">序列</h2>
<p>值可以分组到集合中，这允许程序员组织这些值，并使用单个名称引用它们中的所有值。 通过将值分组在一起，我们可以编写代码，一次执行许多数据计算。</p>
<p>在几个值上调用<code>make_array</code>函数，将它们放到一个数组中，这是一种顺序集合。 下面，我们将四个不同的温度收集到一个名为<code>temps</code>的数组中。 这些分别是 1850 年，1900 年，1950 年和 2000 年的几十年间，地球上所有陆地的估计日平均绝对高温（摄氏度），表示为 1951 年至 1980 年间平均绝对高温的偏差，为 14.48 度。</p>
<p>集合允许我们使用单个名称，将多个值传递给一个函数。 例如，<code>sum</code>函数计算集合中所有值的和，<code>len</code>函数计算其长度。 （这是我们放入的值的数量。）一起使用它们，我们可以计算一个集合的平均值。</p>
<pre><code class="lang-py">sum(highs)/len(highs)
<span class="hljs-number">14.434000000000001</span>
</code></pre>
<p>日高温和低温的完整图表在下面。</p>
<h3 id="日高温均值">日高温均值</h3>
<p><img src="img/4-1.png" alt=""></img></p>
<h3 id="日低温均值">日低温均值</h3>
<p><img src="img/4-2.png" alt=""></img></p>
<h2 id="数组">数组</h2>
<p>Python 中有很多种类的集合，我们在这门课中主要使用数组。 我们已经看到，<code>make_array</code>函数可以用来创建数值的数组。</p>
<p>数组也可以包含字符串或其他类型的值，但是单个数组只能包含单一类型的数据。 （无论如何，把不相似的数据组合在一起，通常都没有意义）。例如：</p>
<pre><code class="lang-py">english_parts_of_speech = make_array(<span class="hljs-string">"noun"</span>, <span class="hljs-string">"pronoun"</span>, <span class="hljs-string">"verb"</span>, <span class="hljs-string">"adverb"</span>, <span class="hljs-string">"adjective"</span>, <span class="hljs-string">"conjunction"</span>, <span class="hljs-string">"preposition"</span>, <span class="hljs-string">"interjection"</span>)
english_parts_of_speech
array([<span class="hljs-string">'noun'</span>, <span class="hljs-string">'pronoun'</span>, <span class="hljs-string">'verb'</span>, <span class="hljs-string">'adverb'</span>, <span class="hljs-string">'adjective'</span>, <span class="hljs-string">'conjunction'</span>,
       <span class="hljs-string">'preposition'</span>, <span class="hljs-string">'interjection'</span>], 
      dtype=<span class="hljs-string">'&lt;U12'</span>)
</code></pre>
<blockquote>
<p>译者注：</p>
<pre><code class="lang-py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
make_array = <span class="hljs-keyword">lambda</span> *args: np.asarray(args)
</code></pre>
</blockquote>
<p>返回到温度数据，我们创建 1850 年，1900 年，1950 年和 2000 年的几十年间，<a href="http://berkeleyearth.lbl.gov/auto/Regional/TMAX/Text/global-land-TMAX-Trend.txt" target="_blank">日平均高温</a>的数组。</p>
<pre><code class="lang-py">baseline_high = <span class="hljs-number">14.48</span>
highs = make_array(baseline_high - <span class="hljs-number">0.880</span>, 
                   baseline_high - <span class="hljs-number">0.093</span>,
                   baseline_high + <span class="hljs-number">0.105</span>, 
                   baseline_high + <span class="hljs-number">0.684</span>)
highs
array([ <span class="hljs-number">13.6</span>  ,  <span class="hljs-number">14.387</span>,  <span class="hljs-number">14.585</span>,  <span class="hljs-number">15.164</span>])
</code></pre>
<p>数组可以用在算术表达式中来计算其内容。 当数组与单个数组合时，该数与数组的每个元素组合。 因此，我们可以通过编写熟悉的转换公式，将所有这些温度转换成华氏温度。</p>
<pre><code class="lang-py">(<span class="hljs-number">9</span>/<span class="hljs-number">5</span>) * highs + <span class="hljs-number">32</span>
array([ <span class="hljs-number">56.48</span>  ,  <span class="hljs-number">57.8966</span>,  <span class="hljs-number">58.253</span> ,  <span class="hljs-number">59.2952</span>])
</code></pre>
<p><img src="img/4-3.png" alt=""></img></p>
<p>数组也有方法，这些方法是操作数组值的函数。 数值集合的均值是其总和除以长度。 以下示例中的每对括号都是调用表达式的一部分；它调用一个无参函数来对数组<code>highs</code>进行计算。</p>
<pre><code class="lang-py">highs.size
<span class="hljs-number">4</span>
highs.sum()
<span class="hljs-number">57.736000000000004</span>
highs.mean()
<span class="hljs-number">14.434000000000001</span>
</code></pre>
<h3 id="数组上的函数">数组上的函数</h3>
<p><code>numpy</code>包，在程序中缩写为<code>np</code>，为 Python 程序员提供了创建和操作数组的，方便而强大的函数。</p>
<pre><code class="lang-py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
</code></pre>
<p>例如，<code>diff</code>函数计算数组中每两个相邻元素之间的差。 差数组的第一个元素是原数组的第二个元素减去第一个元素。</p>
<pre><code class="lang-py">np.diff(highs)
array([ <span class="hljs-number">0.787</span>,  <span class="hljs-number">0.198</span>,  <span class="hljs-number">0.579</span>])
</code></pre>
<p><a href="http://docs.scipy.org/doc/numpy/reference/" target="_blank">完整的 Numpy 参考</a>详细列出了这些功能，但一个小的子集通常用于数据处理应用。 它们分组到了<code>np</code>中不同的包中。 学习这些词汇是学习 Python 语言的重要组成部分，因此在你处理示例和问题时，请经常回顾这个列表。</p>
<p>但是，你不需要记住这些，只需要将它用作参考。</p>
<p>每个这些函数接受数组作为参数，并返回单个值。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>np.prod</code></td>
<td>将所有元素相乘</td>
</tr>
<tr>
<td><code>np.sum</code></td>
<td>将所有元素相加</td>
</tr>
<tr>
<td><code>np.all</code></td>
<td>测试是否所有元素是真值 （非零数值是真值）</td>
</tr>
<tr>
<td><code>np.any</code></td>
<td>测试是否任意元素是真值（非零数值是真值）</td>
</tr>
<tr>
<td><code>np.count_nonzero</code></td>
<td>计算非零元素的数量</td>
</tr>
</tbody>
</table>
<p>每个这些函数接受字符串数组作为参数，并返回数组。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>np.char.lower</code></td>
<td>将每个元素变成小写</td>
</tr>
<tr>
<td><code>np.char.upper</code></td>
<td>将每个元素变成大写</td>
</tr>
<tr>
<td><code>np.char.strip</code></td>
<td>移除每个元素开头或末尾的空格</td>
</tr>
<tr>
<td><code>np.char.isalpha</code></td>
<td>每个元素是否只含有字母（没有数字或者符号）</td>
</tr>
<tr>
<td><code>np.char.isnumeric</code></td>
<td>每个元素是否只含有数字（没有字母）</td>
</tr>
</tbody>
</table>
<p>每个这些函数接受字符串数组和一个搜索字符串。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>np.char.count</td>
<td>在数组的元素中，计算搜索字符串的出现次数</td>
</tr>
<tr>
<td>np.char.find</td>
<td>在每个元素中，搜索字符串的首次出现位置</td>
</tr>
<tr>
<td>np.char.rfind</td>
<td>在每个元素中，搜索字符串的最后一次出现位置</td>
</tr>
<tr>
<td>np.char.startswith</td>
<td>每个字符串是否以搜索字符串起始</td>
</tr>
</tbody>
</table>
<h2 id="范围">范围</h2>
<p>范围是一个数组，按照递增或递减的顺序排列，每个元素按照一定的间隔分开。 范围在很多情况下非常有用，所以值得了解它们。</p>
<p>范围使用<code>np.arange</code>函数来定义，该函数接受一个，两个或三个参数：起始值，终止值和“步长”。</p>
<p>如果将一个参数传递给<code>np.arange</code>，那么它将成为终止值，其中<code>start = 0</code>，<code>step = 1</code>。 两个参数提供了起始值和终止值，<code>step = 1</code>。 三个参数明确地提供了起始值，终止值和步长。</p>
<p>范围始终包含其<code>start</code>值，但不包括其<code>end</code>值。 它按照<code>step</code>计数，并在到达<code>end</code>之前停止。</p>
<pre><code class="lang-py">np.arange(end): An array starting <span class="hljs-keyword">with</span> <span class="hljs-number">0</span> of increasing consecutive integers, stopping before end.
np.arange(<span class="hljs-number">5</span>)
array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])
</code></pre>
<p>要注意，数值从<code>0</code>起始，并仅仅增加到<code>4</code>，并不是<code>5</code>。</p>
<pre><code class="lang-py">np.arange(start, end): An array of consecutive increasing integers <span class="hljs-keyword">from</span> start, stopping before end.
np.arange(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>)
array([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>])
np.arange(start, end, step): A range <span class="hljs-keyword">with</span> a difference of step between each pair of consecutive values, starting <span class="hljs-keyword">from</span> start <span class="hljs-keyword">and</span> stopping before end.
np.arange(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>, <span class="hljs-number">5</span>)
array([ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">13</span>, <span class="hljs-number">18</span>, <span class="hljs-number">23</span>, <span class="hljs-number">28</span>])
</code></pre>
<p>这个数组从<code>3</code>起始，增加了步长<code>5</code>变成<code>8</code>，然后增加步长<code>5</code>变成<code>13</code>，以此类推。</p>
<p>当你指定步长时，起始值、终止值和步长可正可负，可以是整数也可以是分数。</p>
<pre><code class="lang-py">np.arange(<span class="hljs-number">1.5</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">0.5</span>)
array([ <span class="hljs-number">1.5</span>,  <span class="hljs-number">1.</span> ,  <span class="hljs-number">0.5</span>,  <span class="hljs-number">0.</span> , -<span class="hljs-number">0.5</span>, -<span class="hljs-number">1.</span> , -<span class="hljs-number">1.5</span>])
</code></pre>
<h3 id="示例：莱布尼茨的-π-公式">示例：莱布尼茨的 π 公式</h3>
<p>伟大的德国数学家和哲学家戈特弗里德·威廉·莱布尼茨（Gottfried Wilhelm Leibniz，1646 ~ 1716年）发现了一个简单分数的无穷和。 公式是：</p>
<p><img src="img/tex-4-1.gif" alt=""></img></p>
<p>虽然需要一些数学来确定它，但我们可以用数组来说服我们自己，公式是有效的。 让我们计算莱布尼茨的无穷和的前 5000 个项，看它是否接近 π。</p>
<p>我们将计算这个有限的总和，首先加上所有的正项，然后减去所有负项的和 [1]：</p>
<p><img src="img/tex-4-2.gif" alt=""></img></p>
<blockquote>
<p>[1] 令人惊讶的是，当我们将无限多个分数相加时，顺序可能很重要。但是我们对 π 的近似只使用了大量的数量有限的分数，所以可以按照任何方便的顺序，将这些项相加。</p>
</blockquote>
<p>和中的正项的分母是<code>1, 5, 9</code>，以此类推。数组<code>by_four_to_20</code>包含<code>17</code>之前的这些数。</p>
<pre><code class="lang-py">by_four_to_20 = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">4</span>)
by_four_to_20
array([ <span class="hljs-number">1</span>,  <span class="hljs-number">5</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>])
</code></pre>
<p>为了获得 π 的准确近似，我们使用更长的数组<code>positive_term_denominators</code>。</p>
<pre><code class="lang-py">positive_term_denominators = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">4</span>)
positive_term_denominators
array([   <span class="hljs-number">1</span>,    <span class="hljs-number">5</span>,    <span class="hljs-number">9</span>, ..., <span class="hljs-number">9989</span>, <span class="hljs-number">9993</span>, <span class="hljs-number">9997</span>])
</code></pre>
<p>我们实际打算加起来的正项，就是一除以这些分母。</p>
<pre><code class="lang-py">positive_terms = <span class="hljs-number">1</span> / positive_term_denominators
</code></pre>
<p>负向的分母是<code>3, 7, 11</code>，以此类推。这个数组就是<code>positive_term_denominators</code>加二。</p>
<pre><code class="lang-py">negative_terms = <span class="hljs-number">1</span> / (positive_term_denominators + <span class="hljs-number">2</span>)
</code></pre>
<p>整体的和是：</p>
<pre><code class="lang-py"><span class="hljs-number">4</span> * ( sum(positive_terms) - sum(negative_terms) )
<span class="hljs-number">3.1413926535917955</span>
</code></pre>
<p>这非常接近于<code>π = 3.14159...</code>。莱布尼茨公式看起来不错。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="3.html" class="navigation navigation-prev " aria-label="Previous page: 三、Python 编程">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="5.html" class="navigation navigation-next " aria-label="Next page: 五、表格">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"四、数据类型","level":"1.1.5","depth":2,"next":{"title":"五、表格","level":"1.1.6","depth":2,"path":"5.md","ref":"5.md","articles":[]},"previous":{"title":"三、Python 编程","level":"1.1.4","depth":2,"path":"3.md","ref":"3.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"4.md","mtime":"2018-03-04T12:09:02.000Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:18:25.491Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

