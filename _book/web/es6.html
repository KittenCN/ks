
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>ES6 · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="design.html" />
    
    
    <link rel="prev" href="regexp.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    前端汇总
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="css.html">
            
                <a href="css.html">
            
                    
                    CSS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="html.html">
            
                <a href="html.html">
            
                    
                    Html
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="http.html">
            
                <a href="http.html">
            
                    
                    Http
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="javascript.html">
            
                <a href="javascript.html">
            
                    
                    Javascript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="array.html">
            
                <a href="array.html">
            
                    
                    Array
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="object.html">
            
                <a href="object.html">
            
                    
                    Object
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="module.html">
            
                <a href="module.html">
            
                    
                    Module
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="regexp.html">
            
                <a href="regexp.html">
            
                    
                    Regexp
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.9" data-path="es6.html">
            
                <a href="es6.html">
            
                    
                    ES6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="design.html">
            
                <a href="design.html">
            
                    
                    设计模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="fp.html">
            
                <a href="fp.html">
            
                    
                    函数编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="typescript.html">
            
                <a href="typescript.html">
            
                    
                    Typescript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="react.html">
            
                <a href="react.html">
            
                    
                    React
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="vue.html">
            
                <a href="vue.html">
            
                    
                    Vue
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.15" data-path="webpack.html">
            
                <a href="webpack.html">
            
                    
                    Webpack
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.16" data-path="vite.html">
            
                <a href="vite.html">
            
                    
                    Vite
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.17" data-path="babel.html">
            
                <a href="babel.html">
            
                    
                    Babel
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >ES6</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <p>ES 全称 ECMAScript，ECMAScript 是 ECMA 制定的标准化脚本语言</p>
<h2 id="es6">ES6</h2>
<h3 id="类（class）">类（class）</h3>
<p>对熟悉 Java，object-c，c#等纯面向对象语言的开发者来说，都会对 class 有一种特殊的情怀。ES6 引入了 class（类），让 JavaScript 的面向对象编程变得更加简单和易于理解。</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-comment">// 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.</span>
    constructor(name, color) {
        <span class="hljs-keyword">this</span>.name = name;
        <span class="hljs-keyword">this</span>.color = color;
    }
    <span class="hljs-comment">// toString 是原型对象上的属性</span>
    toString() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'name:'</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">',color:'</span> + <span class="hljs-keyword">this</span>.color);
    }
}

<span class="hljs-keyword">var</span> animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">'dog'</span>, <span class="hljs-string">'white'</span>); <span class="hljs-comment">//实例化Animal</span>
animal.toString();

<span class="hljs-built_in">console</span>.log(animal.hasOwnProperty(<span class="hljs-string">'name'</span>)); <span class="hljs-comment">//true</span>
<span class="hljs-built_in">console</span>.log(animal.hasOwnProperty(<span class="hljs-string">'toString'</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(animal.__proto__.hasOwnProperty(<span class="hljs-string">'toString'</span>)); <span class="hljs-comment">// true</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>{
    constructor(action) {
        <span class="hljs-comment">// 子类必须要在constructor中指定super 函数，否则在新建实例的时候会报错.</span>
        <span class="hljs-comment">// 如果没有置顶consructor,默认带super函数的constructor将会被添加、</span>
        <span class="hljs-keyword">super</span>(<span class="hljs-string">'cat'</span>, <span class="hljs-string">'white'</span>);
        <span class="hljs-keyword">this</span>.action = action;
    }
    toString() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">super</span>.toString());
    }
}

<span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">'catch'</span>);
cat.toString();

<span class="hljs-comment">// 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。</span>
<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span>
</code></pre>
<h3 id="模块化-module">模块化 (Module)</h3>
<p>ES5 不支持原生的模块化，在 ES6 中模块作为重要的组成部分被添加进来。模块的功能主要由 export 和 import 组成。每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过 import 来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。</p>
<pre><code class="lang-javascrript"> //test.js
 export const  name = 'hello module';

//index.js
 import {name} from './test.js';// test.js
</code></pre>
<h3 id="箭头函数-（arrow）">箭头函数 （Arrow）</h3>
<p>ES5 不支持原生的模块化，在 ES6 中模块作为重要的组成部分被添加进来。模块的功能主要由 export 和 import 组成。每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过 import 来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。</p>
<pre><code class="lang-javascrript">const addNum=(a,b)=&gt;(a+b);

const say=()=&gt;{
    return 'hello module'
}
</code></pre>
<h3 id="函数参数默认值">函数参数默认值</h3>
<pre><code class="lang-javascrript">const addNum=(a=10,b=10)=&gt;(a+b);
</code></pre>
<h3 id="模板字符串">模板字符串</h3>
<pre><code class="lang-javascrript">const addNum=(name,age)=&gt;{
   return  `Your name is ${name} you age is ${age}.`
};
</code></pre>
<h3 id="解构赋值">解构赋值</h3>
<pre><code class="lang-javascrript">const [name,age] = ["moudle", 12];
console.log(name,age)
</code></pre>
<h3 id="延展操作符spread-operator">延展操作符(Spread operator)</h3>
<pre><code class="lang-javascrript">const itemInfo= {
    name: 'module',
    age:20
}
var newIteminfo={
    age:19,
    address:'shanghai',
    ...itemInfo
}
</code></pre>
<h3 id="promise">Promise</h3>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案 callback 更加的优雅。它最早由社区提出和实现的，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    setTimeout(resolve, <span class="hljs-number">1000</span>);
});

promise1
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello world'</span>);
    })
    .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'erroe'</span>);
    });
</code></pre>
<h3 id="let-与-const">let 与 const</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'hello module'</span>;
<span class="hljs-keyword">let</span> age = <span class="hljs-number">12</span>;
</code></pre>
<h3 id="symbol">Symbol</h3>
<p>Symbol 是由 ES6 规范引入的一项新特性，它的功能类似于一种标识唯一性的 ID。通常情况下，我们可以通过调用 Symbol()函数来创建一个 Symbol 实例,</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> sy = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'hello world'</span>);
</code></pre>
<h3 id="proxy">Proxy</h3>
<p>proxy 用于修改某些操作的默认行为，可以理解为一种拦截外界对目标对象访问的一种机制，从而对外界的访问进行过滤和修改，即代理某些操作，也称“代理器”。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);
</code></pre>
<h2 id="es7">ES7</h2>
<h3 id="includes">includes()</h3>
<p>是查找一个值在不在数组里，若在，则返回 true，反之返回 false</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">'react'</span>, <span class="hljs-string">'angular'</span>, <span class="hljs-string">'vue'</span>];
arr.includes(<span class="hljs-string">'react'</span>); <span class="hljs-comment">//true</span>
</code></pre>
<h3 id="">**</h3>
<p>求幂运算符 **</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">10</span> ** <span class="hljs-number">2</span>);
</code></pre>
<h2 id="es8">ES8</h2>
<h3 id="asyncawait-异步">async/await 异步</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> getSubject = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">let</span> subjectInfo = <span class="hljs-keyword">await</span> getInfo();
    <span class="hljs-built_in">console</span>.log(subjectInfo);
};
</code></pre>
<h3 id="objectvalues">Object.values()</h3>
<p>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用 for...in 循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
<ul>
<li>语法：Object.values(obj)</li>
<li>参数：<ul>
<li>obj: 被返回可枚举属性值的对象.</li>
</ul>
</li>
<li>返回值：array 一个包含对象自身的所有可枚举属性值的数组。</li>
</ul>
<p>!&gt;Object.values()返回一个数组，其元素是在对象上找到的可枚举属性值。属性的顺序与通过手动循环对象的属性值所给出的顺序相同</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> obj = {
    foo: <span class="hljs-string">'bar'</span>,
    baz: <span class="hljs-number">42</span>,
    arr: {a: <span class="hljs-string">'aa'</span>, b: <span class="hljs-string">'BB'</span>},
    add: () =&gt; {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'add'</span>);
    }
};
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(obj)); <span class="hljs-comment">//["bar", 42, {a: "aa", b: "BB"}, () =&gt; {console.log('add');}]</span>

<span class="hljs-keyword">var</span> objArr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.values(objArr)); <span class="hljs-comment">//[1, 2, 3]</span>
</code></pre>
<h3 id="objectentries">Object.entries()</h3>
<p>返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>
<ul>
<li>语法：Object.entries(obj)</li>
<li>参数：<ul>
<li>obj: object 可以返回其可枚举属性的键值对的对象</li>
</ul>
</li>
<li>返回值：给定对象自身可枚举属性的键值对数组。</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> object1 = {
    a: <span class="hljs-string">'somestring'</span>,
    b: <span class="hljs-number">42</span>
};
<span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.entries(object1);
<span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">//[["a", "somestring"],"b", 42]]</span>
</code></pre>
<h3 id="objectgetownpropertydescriptors">Object.getOwnPropertyDescriptors()</h3>
<p>Object.getOwnPropertyDescriptors() 函数用来获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</p>
<ul>
<li>语法：Object.getOwnPropertyDescriptors(obj)</li>
<li>参数：<ul>
<li>obj: object 对象</li>
</ul>
</li>
<li>返回值：返回 obj 对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象</li>
</ul>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> obj = {
    name: <span class="hljs-string">'hello module'</span>,
    get age() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">'20'</span>;
    }
};
<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj);
</code></pre>
<h3 id="padstart，padend">padStart()，padEnd()</h3>
<p>padStart()，padEnd() 字符串补全</p>
<pre><code class="lang-javascript"><span class="hljs-string">'x'</span>.padStart(<span class="hljs-number">5</span>, <span class="hljs-string">'ab'</span>); <span class="hljs-comment">// 'ababx'</span>
<span class="hljs-string">'x'</span>.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">'ab'</span>); <span class="hljs-comment">// 'abax'</span>

<span class="hljs-string">'x'</span>.padEnd(<span class="hljs-number">5</span>, <span class="hljs-string">'ab'</span>); <span class="hljs-comment">// 'xabab'</span>
<span class="hljs-string">'x'</span>.padEnd(<span class="hljs-number">4</span>, <span class="hljs-string">'ab'</span>); <span class="hljs-comment">// 'xaba'</span>
</code></pre>
<h2 id="es9">ES9</h2>
<h3 id="异步迭代">异步迭代</h3>
<p>ES2018 引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了 next()方法返回一个 Promise。因此 await 可以和 for...of 循环一起使用，以串行的方式运行异步操作</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> array) {
        doSomething(i);
    }
}
</code></pre>
<h3 id="promisefinally">Promise.finally()</h3>
<p>一个 Promise 调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论 Promise 运行成功还是失败，运行相同的代码，</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
    setTimeout(resolve, <span class="hljs-number">1000</span>);
})
    .then(() =&gt; {})
    .catch(err =&gt; {
        <span class="hljs-built_in">console</span>.log(err);
    })
    .finally(() =&gt; {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>);
    });
</code></pre>
<h3 id="restspread-属性">Rest/Spread 属性</h3>
<p>对象解构提供了和数组一样的 Rest 参数（）和展开操作符</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> myObject = {
    a: <span class="hljs-number">1</span>,
    b: <span class="hljs-number">2</span>,
    c: <span class="hljs-number">3</span>
};
<span class="hljs-keyword">const</span> {a, ...x} = myObject;
<span class="hljs-comment">// a = 1</span>
<span class="hljs-comment">// x = { b: 2, c: 3 }</span>
</code></pre>
<h3 id="regexp-命名捕获组">Regexp 命名捕获组</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> reDate = <span class="hljs-regexp">/(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/</span>,
    match = reDate.exec(<span class="hljs-string">'2018-04-30'</span>),
    year = match.groups.year, <span class="hljs-comment">// 2018</span>
    month = match.groups.month, <span class="hljs-comment">// 04</span>
    day = match.groups.day; <span class="hljs-comment">// 30</span>
</code></pre>
<h3 id="正则表达式-dotall-模式">正则表达式 dotAll 模式</h3>
<p>标志：为这些表达式提供一致的行为。该特性旨在解决正则表达式中的点(.)不匹配行终止符的限制。s 标志改变了这一点。此标志将在选择的基础上运行，因此现有的正则表达式模式不会受到影响。</p>
<pre><code class="lang-javascript">/hello.world/.test(<span class="hljs-string">'hello\nworld'</span>); <span class="hljs-comment">// false</span>
/hello.world/s.test(<span class="hljs-string">'hello\nworld'</span>); <span class="hljs-comment">// true</span>
</code></pre>
<h3 id="正则表达式反向断言">正则表达式反向断言</h3>
<p>解决了环视（lookaround）的一个缺点，它是零宽度的断言，与字符串进行匹配，不消耗任何东西。使用隐藏的断言，开发人员可以确保模式之前有或没有另一个模式。例如：匹配美元的金额而不获取美元符号。</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> reLookbehind = <span class="hljs-regexp">/(?&lt;=\D)\d+/</span>,
    match = reLookbehind.exec(<span class="hljs-string">'$123.89'</span>);
<span class="hljs-built_in">console</span>.log(match[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 123.89</span>
</code></pre>
<h3 id="unicode-属性转义">Unicode 属性转义</h3>
<p>Regexp(正则表达式) Unicode 属性转义：使开发者能够更好地访问 Unicode 字符属性。属性转义将以\p{…}和\P{…}的形式添加。</p>
<h2 id="es10">ES10</h2>
<h3 id="arrayprototypeflatflatmap">Array.prototype.{flat,flatMap}</h3>
<p>数组降维，递归地将数组展平到指定的深度，对数组的内含数组进行展开操作并返回一个新数组</p>
<p>!&gt; depth: 需要展开内层数组的层数，默认为 1</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>]]];
array.flat(); <span class="hljs-comment">// → [1, 2, [3]]</span>
array.flat(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// → [1, 2, 3]</span>
[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].flatMap(x =&gt; [x, x * <span class="hljs-number">2</span>]);
<span class="hljs-comment">// → [2, 4, 3, 6, 4, 8]</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'Codedam'</span>, <span class="hljs-string">'is Awsome'</span>, <span class="hljs-string">'!'</span>];
<span class="hljs-keyword">const</span> mapResult = arr.map(item =&gt; item.split(<span class="hljs-string">' '</span>));
<span class="hljs-built_in">console</span>.log(mapResult); <span class="hljs-comment">// [ [ 'Codedam' ], [ 'is', 'Awsome' ], [ '!' ] ]</span>
</code></pre>
<h3 id="functionprototypetostring">Function.prototype.toString</h3>
<p>Function.prototype.toString 方法,返回一个表示当前函数源代码的字符串</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> fun = name =&gt; {
    <span class="hljs-built_in">console</span>.log(name);
};
fun.toString(); <span class="hljs-comment">// "(name) =&gt; { console.log(name) }"</span>
</code></pre>
<h3 id="objectfromentries">Object.fromEntries()</h3>
<p>把键值对列表转换为一个对象</p>
<ul>
<li>语法：Object.fromEntries(iterable)</li>
<li>参数：<ul>
<li>iterable: 迭代对象，类似 Array 、 Map 或者其它实现了可迭代协议的对象</li>
</ul>
</li>
<li>返回值：一个由该迭代对象条目提供对应属性的新对象。</li>
</ul>
<p>?&gt; 迭代对象:第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值,其他的忽略</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> arr = [[<span class="hljs-string">'0'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>], [<span class="hljs-string">'1'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'F'</span>], [<span class="hljs-string">'2'</span>]];
<span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.fromEntries(arr);
<span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// { 0: "a", 1: "c", 2: undefined }</span>
</code></pre>
<h3 id="trimstart-和-trimend">trimStart 和 trimEnd</h3>
<pre><code class="lang-javascript"><span class="hljs-comment">// Trim</span>
<span class="hljs-keyword">const</span> name = <span class="hljs-string">'   Codedam '</span>;
<span class="hljs-built_in">console</span>.log(name.trim()); <span class="hljs-comment">// "Codedam"</span>
<span class="hljs-comment">// Trim Start</span>
<span class="hljs-keyword">const</span> description = <span class="hljs-string">'   Unlocks Secret Codes '</span>;
<span class="hljs-built_in">console</span>.log(description.trimStart()); <span class="hljs-comment">// "Unlocks Secret Codes "</span>
<span class="hljs-comment">// Trim End</span>
<span class="hljs-keyword">const</span> category = <span class="hljs-string">'  JavaScript '</span>;
<span class="hljs-built_in">console</span>.log(category.trimEnd()); <span class="hljs-comment">// "  JavaScript"</span>
</code></pre>
<h2 id="es11">ES11</h2>
<h3 id="bigint">BigInt</h3>
<p>es11 为了解决大数问题，推出了新的数据类型 BigInt。这种数据类型可以进行大整数运算.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> a = Bigint(<span class="hljs-number">122</span>);
<span class="hljs-keyword">let</span> b = <span class="hljs-number">123</span>n;
</code></pre>
<p>!&gt; BigInt 和普通的 Number 类型不能进行运算。</p>
<h3 id="链判断运算符（）">链判断运算符（?.）</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> firstName = message?.body?.user?.firstName || <span class="hljs-string">'default'</span>;
<span class="hljs-keyword">const</span> fooValue = myForm.querySelector(<span class="hljs-string">'input[name=foo]'</span>)?.value;
</code></pre>
<h3 id="nullundifined-判断运算符">?? (null,undifined) 判断运算符</h3>
<p>而空值合并运算符，是在左边的表达式为空值（null,undifined）时取右边的值</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> b = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">const</span> c = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">const</span> d = <span class="hljs-literal">false</span>;

<span class="hljs-built_in">console</span>.log(a || d); <span class="hljs-comment">//flase</span>
<span class="hljs-built_in">console</span>.log(a ?? b); <span class="hljs-comment">//0</span>
<span class="hljs-built_in">console</span>.log(b ?? c); <span class="hljs-comment">//undefined</span>
</code></pre>
<h3 id="matchall">matchAll</h3>
<p>matchAll 方法返回一个包含所有匹配正则表达式的结果的迭代器。使用 for...of 遍历或者使用 操作符 ... Array.from 将其转换成数组。</p>
<h3 id="dynamic-import">Dynamic import</h3>
<p>标准用法的 import 导入的模块是静态的，会使所有被导入的模块，在加载时就被编译（无法做到按需编译，降低首页加载速度）。有些场景中，你可能希望根据条件导入模块或者按需导入模块，这时你可以使用动态导入代替静态导入。</p>
<p>!&gt; 之前的 import 只能写在顶层作用域，不能写在函数内部，现在的动态 import 可以写在非顶层作用域内</p>
<h3 id="promiseallsettled">Promise.allSettled</h3>
<p>Promise.allSettled 也是接收一个 Promise 数组作为参数，等所有的参数状态都完成的时候（不管是成功还是失败），回调就会触发。回调函数的参数是一个数组，数组的每个元素有两个属性，一个是 status，值为'rejected'或者'fullfilled'，对应表示这个 promise 是成功还是失败，另一个属性是 reason，表示 promise 的回调参数。</p>

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="regexp.html" class="navigation navigation-prev " aria-label="Previous page: Regexp">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="design.html" class="navigation navigation-next " aria-label="Next page: 设计模式">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"ES6","level":"1.1.9","depth":2,"next":{"title":"设计模式","level":"1.1.10","depth":2,"path":"design.md","ref":"design.md","articles":[]},"previous":{"title":"Regexp","level":"1.1.8","depth":2,"path":"regexp.md","ref":"regexp.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"es6.md","mtime":"2024-01-02T00:10:55.813Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T04:18:22.048Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

