
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Webpack · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="vite.html" />
    
    
    <link rel="prev" href="vue.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    前端汇总
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="css.html">
            
                <a href="css.html">
            
                    
                    CSS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="html.html">
            
                <a href="html.html">
            
                    
                    Html
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="http.html">
            
                <a href="http.html">
            
                    
                    Http
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="javascript.html">
            
                <a href="javascript.html">
            
                    
                    Javascript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="array.html">
            
                <a href="array.html">
            
                    
                    Array
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="object.html">
            
                <a href="object.html">
            
                    
                    Object
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="module.html">
            
                <a href="module.html">
            
                    
                    Module
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="regexp.html">
            
                <a href="regexp.html">
            
                    
                    Regexp
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="es6.html">
            
                <a href="es6.html">
            
                    
                    ES6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="design.html">
            
                <a href="design.html">
            
                    
                    设计模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="fp.html">
            
                <a href="fp.html">
            
                    
                    函数编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="typescript.html">
            
                <a href="typescript.html">
            
                    
                    Typescript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="react.html">
            
                <a href="react.html">
            
                    
                    React
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.14" data-path="vue.html">
            
                <a href="vue.html">
            
                    
                    Vue
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.15" data-path="webpack.html">
            
                <a href="webpack.html">
            
                    
                    Webpack
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.16" data-path="vite.html">
            
                <a href="vite.html">
            
                    
                    Vite
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.17" data-path="babel.html">
            
                <a href="babel.html">
            
                    
                    Babel
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Webpack</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="webpack">Webpack</h1>
<div align="center">

  <img src="web/img/webpack.jpeg" width="300" alt="logo" align="center"></img>
</div>

<p><a href="https://webpack.js.org/" target="_blank">webpack</a>是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<h3 id="webpack-编译方式">Webpack 编译方式</h3>
<ol>
<li>使用 module map,维护项目中的依赖关系</li>
<li>使用了包裹函数，对每个模块进行包裹</li>
<li>使用了一个“runtime”方法（wepackBundle）最终合成 bundle 内容</li>
</ol>
<h2 id="语法">语法</h2>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-comment">//页面入口文件配置</span>
    entry: {
        index : <span class="hljs-string">'./src/app.js'</span>
    },
    <span class="hljs-comment">//入口文件输出配置</span>
    output: {
        path: <span class="hljs-string">'dist/'</span>,
        filename: <span class="hljs-string">'[name:hash].js'</span>
    },
    <span class="hljs-built_in">module</span>: {
        <span class="hljs-comment">//loader配置</span>
        loaders: [
            { test: <span class="hljs-regexp">/\.js$/</span>, loader: <span class="hljs-string">'babel-loader'</span> }
        ]
    },
    <span class="hljs-comment">//插件项</span>
    plugins: [<span class="hljs-keyword">new</span> webpackPlugin()],
    <span class="hljs-comment">//其它解决方案配置</span>
    devServer: {
    contentBase: path.join(__dirname, <span class="hljs-string">"dist"</span>),
    compress: <span class="hljs-literal">true</span>,
    port: <span class="hljs-number">9000</span>
    },
    resolve: {
        extensions: [<span class="hljs-string">''</span>, <span class="hljs-string">'.js'</span>, <span class="hljs-string">'.json'</span>, <span class="hljs-string">'.less'</span>],
        alias: {
            @ : <span class="hljs-string">'./src/'</span>,
        }
    }
</code></pre>
<h2 id="模块">模块</h2>
<ol>
<li>entry:入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</li>
<li>output: 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。</li>
<li>module： 这些选项决定了如何处理项目中的不同类型的模块</li>
<li>loaders：loader 用于对模块的源代码进行转换。loader 可以使你在 import 或"加载"模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。</li>
<li>plugins：插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！插件目的在于解决 loader 无法实现的其他事</li>
<li>devServer:利用 webpack-dev-server 能够快速启动一个本地服务</li>
<li>resolve ： 这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节</li>
</ol>
<h3 id="hash、chunkhash-和-contenthash-三者的区别">hash、chunkhash 和 contenthash 三者的区别</h3>
<ol>
<li>hash:所有文件的 hash 都是一样的，而且每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。</li>
<li>chunkhash;根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用 chunkhash 的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响</li>
<li>contenthash: 表示由文件内容产生的 hash 值，内容不同产生的 contenthash 值也不一样。在项目中，通常做法是把项目中 css 都抽离出对应的 css 文件来加以引用,所以 css 文件最好使用 contenthash</li>
</ol>
<h2 id="moduleloader">module.loader</h2>
<p>loader 是 webpack 提供的最激动人心的功能之一了。通过使用不同的 loader，webpack 有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换 scss 为 css，或者把下一代的 JS 文件（ES6，ES7)转换为现代浏览器兼容的 JS 文件，对 React 的开发而言，合适的 Loaders 可以把 React 的中用到的 JSX 文件转换为 JS 文件。</p>
<p>webpack 的规则提供了多种配置形式</p>
<ol>
<li>{ test: ... } 匹配特定条件</li>
<li>{ include: ... } 匹配特定路径</li>
<li>{ exclude: ... } 排除特定路径</li>
<li>{ and: [...] }必须匹配数组中所有条件</li>
<li>{ or: [...] } 匹配数组中任意一个条件</li>
<li>{ not: [...] } 排除匹配数组中所有条件</li>
</ol>
<p>上述的所谓条件的值可以是</p>
<ol>
<li>字符串：必须以提供的字符串开始，所以是字符串的话，这里我们需要提供绝对路径</li>
<li>正则表达式：调用正则的 test 方法来判断匹配</li>
<li>函数：(path) =&gt; boolean，返回 true 表示匹配</li>
<li>数组：至少包含一个条件的数组</li>
<li>对象：匹配所有属性值的条件</li>
</ol>
<h3 id="实现方式">实现方式</h3>
<p>webpack 先解析成字符串 然后字符串解析成 AST(静态语法分析树) (acorn)</p>
<pre><code class="lang-javascript">moduel.exports=function(content,map,meta){
     console.log('得到的数据：‘， content);
     console.log('loader预选处理‘， this.data.value);
}

moduel.exports.pitch=function(r1,r2,data){
     data.value='hello moto';
}
</code></pre>
<h3 id="手写-loader">手写 loader</h3>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">code</span>) </span>{
  <span class="hljs-comment">//同步</span>
  <span class="hljs-keyword">this</span>.callback(<span class="hljs-literal">null</span>, code <span class="hljs-comment">/*source-map*/</span>);
  <span class="hljs-comment">//异步</span>
  <span class="hljs-keyword">var</span> callback = <span class="hljs-keyword">this</span>.callback;
  someAsyncOperation(code, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, res</span>) </span>{
    <span class="hljs-keyword">if</span> (!err) {
      callback(<span class="hljs-literal">null</span>, res);
    }
  });
};
</code></pre>
<h2 id="moduletype">module.type</h2>
<p>webpack 会有针对性地进行处理，现阶段实现了以下 5 种模块类型。</p>
<ol>
<li>javascript/auto：即 webpack 3 默认的类型，支持现有的各种 JS 代码模块类型 —— CommonJS、AMD、ESM</li>
<li>javascript/esm：ECMAScript modules，其他模块系统，例如 CommonJS 或者 AMD 等不支持，是 .mjs 文件的默认类型</li>
<li>javascript/dynamic：CommonJS 和 AMD，排除 ESM</li>
<li>javascript/json：JSON 格式数据，require 或者 import 都可以引入，是 .json 文件的默认类型</li>
<li>webassembly/experimental：WebAssembly modules，当前还处于试验阶段，是 .wasm 文件的默认类型</li>
</ol>
<pre><code class="lang-javascript">{
  test: <span class="hljs-regexp">/\.js/</span>,
  include: [
    path.resolve(__dirname, <span class="hljs-string">'src'</span>),
  ],
  type: <span class="hljs-string">'javascript/esm'</span>, <span class="hljs-comment">// 这里指定模块类型</span>
}
</code></pre>
<p>use 字段可以是一个数组，也可以是一个字符串或者表示 loader 的对象。如果只需要一个 loader，也可以这样：use: { loader: 'babel-loader', options: { ... } }。</p>
<h3 id="modulenoparse">module.noParse</h3>
<p>可以用于配置哪些模块文件的内容不需要进行解析。对于一些不需要解析依赖（即无依赖）的第三方大型类库等，可以通过这个字段来配置，以提高整体的构建速度。</p>
<pre><code class="lang-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-built_in">module</span>: {
    noParse: <span class="hljs-regexp">/jquery|lodash/</span>, <span class="hljs-comment">// 正则表达式</span>

    <span class="hljs-comment">// 或者使用 function</span>
    noParse(content) {
      <span class="hljs-keyword">return</span> <span class="hljs-regexp">/jquery|lodash/</span>.test(content);
    }
  }
};
</code></pre>
<h2 id="plugins">Plugins</h2>
<p>插件（Plugins）是用来拓展 Webpack 功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders 和 Plugins 常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders 是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。</p>
<p><img src="img/webpack/04.png" alt="webpack"></img></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> pluginName = <span class="hljs-string">'ConsoleLogOnBuildWebpackPlugin'</span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsoleLogOnBuildWebpackPlugin</span> </span>{
  <span class="hljs-comment">//</span>
  apply(compiler) {
    <span class="hljs-comment">// 在 compiler的hooks中注册⼀个⽅法，当执⾏到该阶段时会调⽤</span>
    compiler.hooks.run.tap(pluginName, compilation =&gt; {
      <span class="hljs-comment">//运行时</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The webpack build process is starting!!!'</span>);
    });
  }
}

plugins: [<span class="hljs-keyword">new</span> ConsoleLogOnBuildWebpackPlugin()];
</code></pre>
<h3 id="原理">原理</h3>
<p>webpack 利用了 <a href="https://github.com/webpack/tapable" target="_blank">tapable 这个库</a>来协助实现对于整个
构建流程各个步骤的控制。 tapable 定义了主要构建流程后，使用 tapable 这个库添加了各种各样的
钩子方法来将 webpack 扩展至功能十分丰富,这就是 plugin 的机制。</p>
<h3 id="钩子方法">钩子方法</h3>
<p>(参考文档)[<a href="https://webpack.docschina.org/api/compiler/#%E4%BA%8B%E4%BB%B6%E9%92%A9%E5%AD%90" target="_blank">https://webpack.docschina.org/api/compiler/#%E4%BA%8B%E4%BB%B6%E9%92%A9%E5%AD%90</a>]</p>
<p>钩子作用参数类型</p>
<ol>
<li>after-plugins 设置完一组初始化插件之后 compiler sync</li>
<li>after-resolvers 设置完 resolvers 之后 compiler sync</li>
<li>run 在读取记录之前 compiler async</li>
<li>compile 在创建新 compilation 之前 compilationParams sync</li>
<li>compilation compilation 创建完成 compilation sync</li>
<li>emit 在生成资源并输出到目录之前 compilationa sync</li>
<li>after-emit 在生成资源并输出到目录之后 compilation async</li>
<li>done 完成</li>
</ol>
<h3 id="手写插件">手写插件</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">new</span> P();

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span> </span>{
  apply(compiler) {
    compiler.hooks.emit.tap(<span class="hljs-string">'emit'</span>, () =&gt; {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'hello  Plugin'</span>);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello  Plugin'</span>);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'hello  Plugin'</span>);
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'hello  Plugin'</span>);
    });
  }
}
</code></pre>
<h2 id="resolve">resolve</h2>
<ol>
<li>resolve.alias 配置某个模块的别名</li>
<li>resolve.extensions 定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找</li>
<li>resolve.modules 这样配置在某种程度上可以简化模块的查找，提升构建速度</li>
<li>resolve.mainFields 有 package.json 文件则按照文件中 main 字段的文件名来查找文件</li>
<li>resolve.mainFiles 当目录下没有 package.json 文件时，我们说会默认使用目录下的 index.js 这个文件，其实这个也是可以配置的，是的，使用 resolve.mainFiles 字段，</li>
<li>resolve.resolveLoader 用于配置解析 loader 时的 resolve 配置，原本 resolve 的配置项在这个字段下基本都有</li>
</ol>
<pre><code class="lang-javascript">resolve: {
  alias: {
      utils$: path.resolve(__dirname, <span class="hljs-string">'src/utils'</span>) <span class="hljs-comment">// 只会匹配 import 'utils'</span>
    },
   extensions: [<span class="hljs-string">'.wasm'</span>, <span class="hljs-string">'.mjs'</span>, <span class="hljs-string">'.js'</span>, <span class="hljs-string">'.json'</span>, <span class="hljs-string">'.jsx'</span>, <span class="hljs-string">'.css'</span>],
  modules: [
    path.resolve(__dirname, <span class="hljs-string">'node_modules'</span>), <span class="hljs-comment">// 指定当前目录下的 node_modules 优先查找</span>
    <span class="hljs-string">'node_modules'</span>, <span class="hljs-comment">// 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录</span>
  ],
    mainFields: [<span class="hljs-string">"module"</span>, <span class="hljs-string">"main"</span>],
    mainFiles: [<span class="hljs-string">'index'</span>], <span class="hljs-comment">// 你可以添加其他默认使用的文件名</span>
},
</code></pre>
<h2 id="ast静态语法分析树">AST(静态语法分析树)</h2>
<p>是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p>
<p>javascript 转译、代码压缩、css 预处理器、elint、pretiier 等。有很多 js 模块我们不会在生产环境用到，但是它们在我们的开发过程中充当着重要的角色。所有的上述工具，不管怎样，都建立在了 AST 这个巨人的肩膀上。</p>
<ol>
<li><a href="http://lisperator.net/uglifyjs/ast" target="_blank">uglify</a></li>
<li><a href="https://github.com/jquery/esprima" target="_blank">esprima</a></li>
<li><a href="https://github.com/acornjs/acorn" target="_blank">Acorn</a>（webpack）</li>
<li>[Babel(<a href="https://github.com/babel/babel" target="_blank">https://github.com/babel/babel</a>)<!-- 5. aglify、shift、espres -->
</li>
</ol>
<p>解析方式</p>
<p><img src="img/webpack01.png" alt=""></img></p>
<ol>
<li>词法分析，也叫扫描 scanner：读取我们的代码，然后把它们按照预定的规则合并成一个个的标识 tokens。同时，它会移除空白符、注释等。最后，整个代码将被分割进一个 tokens 列表（或者说一维数组）</li>
<li>语法分析，也称解析器:将词法分析出来的数组转换成树形的形式，同时，验证语法。语法如果有错的话，抛出语法错误</li>
</ol>
<p><a href="https://esprima.org/demo/parse.html#" target="_blank">esprima</a></p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> add=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>{
    <span class="hljs-keyword">return</span> a+b
}

<span class="hljs-comment">// 转换后的AST</span>
{
    <span class="hljs-string">"type"</span>: <span class="hljs-string">"Program"</span>,
    <span class="hljs-string">"body"</span>: [
        {
            <span class="hljs-string">"type"</span>: <span class="hljs-string">"VariableDeclaration"</span>,
            <span class="hljs-string">"declarations"</span>: [
                {
                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"VariableDeclarator"</span>,
                    <span class="hljs-string">"id"</span>: {
                        <span class="hljs-string">"type"</span>: <span class="hljs-string">"Identifier"</span>,
                        <span class="hljs-string">"name"</span>: <span class="hljs-string">"add"</span>
                    },
                    <span class="hljs-string">"init"</span>: {
                        <span class="hljs-string">"type"</span>: <span class="hljs-string">"FunctionExpression"</span>,
                        <span class="hljs-string">"id"</span>: <span class="hljs-literal">null</span>,
                        <span class="hljs-string">"params"</span>: [
                            {
                                <span class="hljs-string">"type"</span>: <span class="hljs-string">"Identifier"</span>,
                                <span class="hljs-string">"name"</span>: <span class="hljs-string">"a"</span>
                            },
                            {
                                <span class="hljs-string">"type"</span>: <span class="hljs-string">"Identifier"</span>,
                                <span class="hljs-string">"name"</span>: <span class="hljs-string">"b"</span>
                            }
                        ],
                        <span class="hljs-string">"body"</span>: {
                            <span class="hljs-string">"type"</span>: <span class="hljs-string">"BlockStatement"</span>,
                            <span class="hljs-string">"body"</span>: [
                                {
                                    <span class="hljs-string">"type"</span>: <span class="hljs-string">"ReturnStatement"</span>,
                                    <span class="hljs-string">"argument"</span>: {
                                        <span class="hljs-string">"type"</span>: <span class="hljs-string">"BinaryExpression"</span>,
                                        <span class="hljs-string">"operator"</span>: <span class="hljs-string">"+"</span>,
                                        <span class="hljs-string">"left"</span>: {
                                            <span class="hljs-string">"type"</span>: <span class="hljs-string">"Identifier"</span>,
                                            <span class="hljs-string">"name"</span>: <span class="hljs-string">"a"</span>
                                        },
                                        <span class="hljs-string">"right"</span>: {
                                            <span class="hljs-string">"type"</span>: <span class="hljs-string">"Identifier"</span>,
                                            <span class="hljs-string">"name"</span>: <span class="hljs-string">"b"</span>
                                        }
                                    }
                                }
                            ]
                        },
                        <span class="hljs-string">"generator"</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-string">"expression"</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-string">"async"</span>: <span class="hljs-literal">false</span>
                    }
                }
            ],
            <span class="hljs-string">"kind"</span>: <span class="hljs-string">"var"</span>
        }
    ],
    <span class="hljs-string">"sourceType"</span>: <span class="hljs-string">"script"</span>
}
</code></pre>
<h5 id="为什么-parcel-比-webpack-快？">为什么 parcel 比 webpack 快？</h5>
<ol>
<li>webpack 先解析成字符串 然后字符串解析成 AST(静态语法分析树) (acorn)</li>
<li>parcel 直接解析 AST(静态语法分析树)</li>
</ol>
<h2 id="webpack-整体运行流程">Webpack 整体运行流程</h2>
<p><img src="img/webpack02.jpg" alt=""></img></p>
<h4 id="webpack-缺点：">webpack 缺点：</h4>
<ol>
<li>代码全量构建速度过慢，即使是很小的改动，也要等待很长时间才能查看更新与编译之后的结果（引入 HMR 热更新之后有明显的改进）</li>
<li>随着项目业务的复杂度增加，工程模块的体积也会急剧增大，构建后的模块通常要以 M 为单位计算</li>
<li>多个项目之间公用基础资源存在重复打包，基础库代码复用率不算太高</li>
<li>node 的单进程实现在 CPU 计算型的 loader 中表现不佳</li>
</ol>
<h3 id="webpack-分析工具">webpack 分析工具</h3>
<p>webpack-bundle-analyzer：自动帮你计算出各个模块在你的项目中的依赖和分部情况</p>
<h3 id="优化建议：">优化建议：</h3>
<ol>
<li>利用 dllPlugin 和 dllReferencePlugin 预编译资源模块：因为 npm 包不会进行修改，所以构建的时候没必要每次都去解析</li>
<li>使用 happypack 加速代码构建--开启多线程：happypack 在编译过程中除了利用多进程的模式加速编译，还同时开启了 cache 计算，能充分利用缓存读取构建文件</li>
<li>增加 uglify，在构建的时候发现，webpack build 走到 80%左右的时候，会发生很长时间的停滞，经测试对比发现正是 uglifyJS 在对我们 output 中的 bundle 部门进行压缩导致耗时过长，针对这块儿可以使用 webpack-uglify-parallel 来提成压缩速度（才用多核并行压缩的方式）</li>
<li>配置 external +libraryTarget，把各种库的源码 external 一下，使用了之后，webpack 就不会去打包，加快速度</li>
<li>生成输出的文件要走 chunkhash 而不用 trunk</li>
<li>激活代码热更新功能 HMR</li>
</ol>
<h2 id="版本更新">版本更新</h2>
<h3 id="webpack4">webpack4</h3>
<ol>
<li>一个大的改变是 webpack 需要设置 mode 属性，可以是 development 或 production。</li>
<li>webpack4 受 Parcel 打包工具启发，尽可能的让开发者运行项目的成本变低。为了做到 0 配置，webpack4 不再强制需要 webpack.config.js 作为打包的入口配置文件了，它默认的入口为'./src/'和默认出口'./dist'，</li>
<li>webpack4 删除了 CommonsChunkPlugin 插件，它使用内置 API optimization.splitChunks 和 <strong> optimization.runtimeChunk </strong> 这意味着 webpack 会默认为你生成共享的代码块。其它插件变化如下:</li>
</ol>
<blockquote>
<p>NoEmitOnErrorsPlugin 废弃，使用 optimization.noEmitOnErrors 替代，在生产环境中默认开启该插件。
ModuleConcatenationPlugin 废弃，使用 optimization.concatenateModules 替代，在生产环境默认开启该插件。
NamedModulesPlugin 废弃，使用 optimization.namedModules 替代，在生产环境默认开启。
uglifyjs-webpack-plugin 升级到了 v1.0 版本, 默认开启缓存和并行功能。</p>
</blockquote>
<h3 id="webpack-4-内置优化点">webpack 4 内置优化点</h3>
<ol>
<li>v8 带来的优化（for of 替代 forEach , Map 、Set 替代 Objec、includes 替代 indexOf）</li>
<li>默认使用更快的 md4 hash 算法
3.webpack AST 可以直接从 loader 传递给 AST 减少解析时间</li>
<li>使用字符串替代正则表达式</li>
<li>开启多线程打包</li>
<li>开启 tree shacking</li>
</ol>
<h4 id="tree-shaking-原理">Tree Shaking 原理</h4>
<ol>
<li>webpack 在编译分析阶段，将每一个模块放入 ModuleGraph 中维护</li>
<li>依靠 HarmonyExportSpecifierDependency 和 HarmonyImportSpecifierDependency 分别识别和处理 import 和 export</li>
<li>依靠 HarmonyExportSpecifierDependency 识别 used export 和 unused export</li>
</ol>
<h4 id="tree-shakingw-为什么要依赖-esm-规范">Tree Shakingw 为什么要依赖 ESM 规范</h4>
<ol>
<li>import 模块名只能是字符串常量</li>
<li>import 一般只能在模块的最顶层出现</li>
<li>import binding 是 immutable 的</li>
</ol>
<h3 id="webpack5-展望">Webpack5 展望</h3>
<p>已经有不少关于 webpack5 的计划正在进行中了，包括以下：</p>
<blockquote>
<ul>
<li>对 WebAssembly 的支持更加稳定</li>
<li>支持开发者自定义模块类型</li>
<li>去除 ExtractTextWebpackPlugig 插件，支持开箱即用的 CSS 模块类型</li>
<li>支持 Html 模块类型</li>
<li>持久化缓存</li>
</ul>
</blockquote>
<p>今天 V5 可以在开发模式中启用了一个新命名的块 id 算法，该算法提供块(以及文件名)可读的引用。 模块 ID 由其相对于上下文的路径确定。 块 ID 是由块的内容决定的，所以你不再需要使用 Magic Comments。</p>
<p>V5 的版本中都带来些哪些改变呢？其实你只要在配置文件中加上这样一句</p>
<pre><code class="lang-code">module.exports = {
    cache: {
        type: "filesystem"
    }
}
</code></pre>
<p>minSize&amp;maxSize 更好的方式表达</p>
<pre><code class="lang-code">module.exports = {
    optimization: {
        splitChunks: {
            cacheGroups: {
                commons: {
                    chunks: "all",
                    name: "commons",
                }
            },
            //最小的文件大小 超过之后将不予打包
            minSize: {
                javascript: 0,
                style: 0,
            },
            //最大的文件 超过之后继续拆分
            maxSize: {
                javascript: 1, //故意写小的效果更明显
                style: 3000,
            }
        }
    }
}
</code></pre>
<h3 id="webpack5-特性">webpack5 特性</h3>
<ol>
<li>构建速度优化 ,通过 cache 特性来将 webpack 工作缓存到硬盘中</li>
<li>代码体积的优化</li>
<li>webpack 现在能够处理对嵌套模块的 tree shaking</li>
<li>webpack 5 开始新增一个属性 output.ecmaVersion, 可以生成 ES5 和 ES6 / ES2015 代码</li>
<li>Module Federation(模块联邦)</li>
</ol>
<!-- 打包过大  --max_old_space_size=4096 ./node_modules/.bin/webpack
> happypack thread-loader parellel-webpack:多核打包，加快 打包速度
> 原理 nodejs 多线程模块 cluster
> cache-laoder HardSourceWebpackPlugin 缓存 提升二次构建速度 -->
<!-- ## plugin

### optimization

```code
module.exports = {
  optimization: {
    splitChunks: {
      chunks: "all", // 所有的 chunks 代码公共的部分分离出来成为一个单独的文件
    },
  },
}
```

"sideEffects": false, -->

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="vue.html" class="navigation navigation-prev " aria-label="Previous page: Vue">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="vite.html" class="navigation navigation-next " aria-label="Next page: Vite">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Webpack","level":"1.1.15","depth":2,"next":{"title":"Vite","level":"1.1.16","depth":2,"path":"vite.md","ref":"vite.md","articles":[]},"previous":{"title":"Vue","level":"1.1.14","depth":2,"path":"vue.md","ref":"vue.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"webpack.md","mtime":"2025-05-03T00:37:28.029Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-09T01:11:18.640Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

