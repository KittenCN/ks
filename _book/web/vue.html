
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Vue · CoderFAN 资料库</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 6.0.3">
        <meta name="author" content="Todd Lyu">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-code/plugin.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="webpack.html" />
    
    
    <link rel="prev" href="react.html" />
    
    <!-- MathJax 配置：唯一且完整 -->
<script>
    window.MathJax = {
      tex: {
        inlineMath:  [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']],
        processEscapes: true,
        processEnvironments: true,
        strict: "ignore",
        macros: { "\\E":"\\mathbb{E}", "\\Var":"\\operatorname{Var}" }
      },
    };
    </script>
    
    <!-- 核心脚本（defer不阻塞渲染） -->
    <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
    <!-- 放在 tex-chtml.js 之后 -->
    <script>
    (function () {
      function typeset() {
        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise().catch(console.error);
        }
      }
    
      /* 第一次正文插入 */
      document.addEventListener('DOMContentLoaded', typeset);
    
      /*   关键：等待 gitbook.js 初始化成功   */
      function hookGitBook() {
        if (window.gitbook && gitbook.events) {
          gitbook.events.bind('page.change', typeset);   // 切章排版
        } else {
          /* gitbook.js 还没加载完 → 100 ms 后再试 */
          setTimeout(hookGitBook, 100);
        }
      }
      hookGitBook();   // 启动递归等待
    })();
    </script>
    
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                <a href=".." class="btn"><b></b>&#128512;返回上层&#128512;</b></a>
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    前端汇总
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.1.1" data-path="css.html">
            
                <a href="css.html">
            
                    
                    CSS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.2" data-path="html.html">
            
                <a href="html.html">
            
                    
                    Html
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.3" data-path="http.html">
            
                <a href="http.html">
            
                    
                    Http
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.4" data-path="javascript.html">
            
                <a href="javascript.html">
            
                    
                    Javascript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.5" data-path="array.html">
            
                <a href="array.html">
            
                    
                    Array
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.6" data-path="object.html">
            
                <a href="object.html">
            
                    
                    Object
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.7" data-path="module.html">
            
                <a href="module.html">
            
                    
                    Module
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.8" data-path="regexp.html">
            
                <a href="regexp.html">
            
                    
                    Regexp
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.9" data-path="es6.html">
            
                <a href="es6.html">
            
                    
                    ES6
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.10" data-path="design.html">
            
                <a href="design.html">
            
                    
                    设计模式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.11" data-path="fp.html">
            
                <a href="fp.html">
            
                    
                    函数编程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.12" data-path="typescript.html">
            
                <a href="typescript.html">
            
                    
                    Typescript
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.13" data-path="react.html">
            
                <a href="react.html">
            
                    
                    React
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.1.14" data-path="vue.html">
            
                <a href="vue.html">
            
                    
                    Vue
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.15" data-path="webpack.html">
            
                <a href="webpack.html">
            
                    
                    Webpack
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.16" data-path="vite.html">
            
                <a href="vite.html">
            
                    
                    Vite
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.1.17" data-path="babel.html">
            
                <a href="babel.html">
            
                    
                    Babel
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Vue</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <h1 id="vue">Vue</h1>
<div align="center">

  <img src="web/img/vue.jpg" width="300" alt="logo" align="center"></img>
</div>

<h3 id="mvvm">MVVM</h3>
<p>MVVM 是 Model-View-ViewModel 的简写。它本质上就是 MVC 的改进版。很早的时候微软就有了 Silverlight ，MVVM 就是将其中的 View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开,它是将“数据模型数据双向绑定”的思想作为核心，因此在 View 和 Model 之间没有联系，通过 ViewModel 进行交互，而且 Model 和 ViewModel 之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到 View 上。</p>
<p>典型的应用有.NET 的 WPF，js 框架 VUE ,AngularJS, Knockout 等。</p>
<p><img src="img/vue/timg.jpg" alt="mvvm"></img></p>
<h3 id="mvvm-的出现，完美解决以下三个问题">MVVM 的出现，完美解决以下三个问题</h3>
<ol>
<li>开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。</li>
<li>大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>
<li>当 Model 频繁发生变化，开发者需要主动更新到 View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到 Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>
</ol>
<h3 id="前端为什么要工程化">前端为什么要工程化</h3>
<p>相对 HTML4 , HTML5 最大的亮点是它为移动设备提供了一些非常有用的功能，使得 HTML5 具备了开发 App 的能力, HTML5 开发 App 最大的好处就是跨平台、快速迭代和上线，节省人力成本和提高效率，因此很多企业开始对传统的 App 进行改造，逐渐用 H5 代替 Native，到 2015 年的时候，市面上大多数 App 或多或少嵌入都了 H5 的页面,既然要用 H5 来构建 App, 那 View 层所做的事，就不仅仅是简单的数据展示了，它不仅要管理复杂的数据状态，还要处理移动设备上各种操作行为等等。因此，前端也需要工程化，也需要一个类似于 MVC 的框架来管理这些复杂的逻辑，使开发更加高效</p>
<h2 id="vue">VUE</h2>
<p>Vue 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的</p>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p><img src="img/vue/brower.png" alt="brower"></img></p>
<p>因此导致了 VUE 不支持 IE9 一下浏览器如果想要向下兼容，则需要使用 VBbScript 或者 <strong>defineGetter</strong>, <strong>defineSetter</strong>,</p>
<!-- ### 目录结构

![目录](img/vue/vuemulu.png)
![目录](img/vue/vuemulu2.png)
 -->
<h3 id="双向数据绑定">双向数据绑定</h3>
<p>把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p><img src="img/vue/img1.png" alt="流程图"></img></p>
<p><img src="img/vue/vueliucheng.png" alt="流程图"></img></p>
<p>setter 触发消息到 Watcher watcher 帮忙告诉 Directive 更新 DOM DOM 修改数据也会通知 Watcher，watcher 帮忙修改数据</p>
<h4 id="双向数据绑定原理">双向数据绑定原理</h4>
<ol>
<li>Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用 Object.defineProperty 的 getter 和 setter 来实现。</li>
<li>Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</li>
<li>Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。</li>
<li>Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发 notify 函数，再调用订阅者的 update 方法。</li>
</ol>
<blockquote>
<p>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面 Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器 Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅 Watcher 来更新视图， 此时 Wather 会将自己添加到消息订阅器中(Dep),初始化完毕
当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用 Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。</p>
</blockquote>
<h3 id="代码">代码</h3>
<pre><code class="lang-html">--------------html---------------------
1.全局创建一个vue实例
<span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"app"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"a"</span> <span class="hljs-attribute">v-model</span>=<span class="hljs-value">"text"</span>&gt;</span>
  { {text} }
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="actionscript">
    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
      el: <span class="hljs-string">'app'</span>,
      data: {
        text: <span class="hljs-string">'hello world'</span>
      }
    });
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>

----------------MVVM------------------------
2.创建VUE 类
function Vue(options) {
    // 2.实例挂载属性 data: {text:'hello'}
    this.data = options.data;
    var data = this.data;
   // 3.observe 遍历了data对象，进行拆分
    observe(data, this);
    var id = options.el;
   //7.Compile(app节点,vue的实例对象)将app节点内容转换成文档片段，拿回html，编译指令，插回到dom,并创建一个watcher
    var dom =new Compile(document.getElementById(id),this);
    // 编译完成后，将dom替换到html模板
    document.getElementById(id).appendChild(dom);
}

-----------------Observe--------------------
/**
 * obj: {text:'hello'}
 * vm: vue实例
 */
function observe(obj, vm) {
  //遍历
  Object.keys(obj).forEach(function(key) {
    //拆分
    defineReactive(vm, key, obj[key]);
  })
}
4.Object.defineProperty将data数据里的属性分别进行 set和get
/**
 * obj: vue实例
 * key: text
 * val: 'hello'
 */
function defineReactive(vm, key, val) {
  var dep = new Dep();
  Object.defineProperty(vm, key, {
    get: function() {
      //5.addSub添加观察者watcher到主题对象Dep
      if (Dep.target) {
        //JS的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用
        dep.addSub(Dep.target);
      }
      return val;
    },
   // 5.notify
    set: function(newVal) {
      //如果set的值与原来的值相同则返回
      if (newVal === val) return;
      //不同则由dep来notify发通知给watcher
      val = newVal;
      console.log(val);
      5.作为发布者发出通知
      dep.notify();
    }
  })
}

-------------------Dep----------------------
5.Dep 就是发布者，subs就是收集来的订阅者（就是一个个watcher），很好的实现了观察者模式
function Dep() {
  this.subs = [];
}
Dep.prototype = {
  addSub: function(sub) {
    this.subs.push(sub);
  },
  notify: function() {
    this.subs.forEach(function(sub) {
      sub.update();
    })
  }
}

--------------------Compile----------------------
6.Compile(app节点,vue的实例对象)将app节点内容转换成文档片段，拿回html，编译指令，插回到dom,并创建一个watcher
//此处代码比较多，简写一下
function Compile(node, vm) {
  if (node) {
    this.$frag = this.nodeToFragment(node, vm);
    return this.$frag;
  }
}
Compile.prototype = {
  nodeToFragment: function(node, vm) {
    var self = this;
    //创建DOM片段
    var frag = document.createDocumentFragment();
    var child;

    while (child = node.firstChild) {
      self.compileElement(child, vm);
       // 将所有子节点添加到fragment中
      frag.append(child);
    }
    return frag;
  },
  compileElement: function(node, vm) {
    var reg = /\{\{(.*)\}\}/;
    //节点类型为元素
    if (node.nodeType === 1) {
      var attr = node.attributes;
      // 解析属性
      for (var i = 0; i <span class="hljs-tag">&lt; <span class="hljs-attribute">attr.length</span>; <span class="hljs-attribute">i</span>++) {
        <span class="hljs-attribute">if</span> (<span class="hljs-attribute">attr</span>[<span class="hljs-attribute">i</span>]<span class="hljs-attribute">.nodeName</span> =<span class="hljs-value">=</span> '<span class="hljs-attribute">v-model</span>') {
          // 获取<span class="hljs-attribute">v-model</span>绑定的属性名
          <span class="hljs-attribute">var</span> <span class="hljs-attribute">name</span> = <span class="hljs-attribute">attr</span>[<span class="hljs-attribute">i</span>]<span class="hljs-attribute">.nodeValue</span>;
          <span class="hljs-attribute">node.addEventListener</span>('<span class="hljs-attribute">input</span>', <span class="hljs-attribute">function</span>(<span class="hljs-attribute">e</span>) {
            // 给相应的<span class="hljs-attribute">data</span>属性赋值，进而触发该属性的<span class="hljs-attribute">set</span>方法
            <span class="hljs-attribute">vm</span>[<span class="hljs-attribute">name</span>] = <span class="hljs-attribute">e.target.value</span>;
          });
          // 将<span class="hljs-attribute">data</span>的值赋给该<span class="hljs-attribute">node</span>
          // <span class="hljs-attribute">node.value</span> = <span class="hljs-attribute">vm</span>[<span class="hljs-attribute">name</span>];
          <span class="hljs-attribute">new</span> <span class="hljs-attribute">Watcher</span>(<span class="hljs-attribute">vm</span>, <span class="hljs-attribute">node</span>, <span class="hljs-attribute">name</span>, '<span class="hljs-attribute">value</span>');
        }
      };
    }
    //节点类型为文本节点或<span class="hljs-attribute">span</span>
    <span class="hljs-attribute">if</span> (<span class="hljs-attribute">node.nodeType</span> =<span class="hljs-value">==</span> <span class="hljs-attribute">3</span>) {
      <span class="hljs-attribute">if</span> (<span class="hljs-attribute">reg.test</span>(<span class="hljs-attribute">node.nodeValue</span>)) {
        // 获取匹配到的字符串
        <span class="hljs-attribute">var</span> <span class="hljs-attribute">name</span> = <span class="hljs-attribute">RegExp.</span>$<span class="hljs-attribute">1</span>;
        <span class="hljs-attribute">name</span> = <span class="hljs-attribute">name.trim</span>();
         // 将<span class="hljs-attribute">data</span>的值赋给该<span class="hljs-attribute">node</span>
        // <span class="hljs-attribute">node.nodeValue</span> = <span class="hljs-attribute">vm</span>[<span class="hljs-attribute">name</span>];
        <span class="hljs-attribute">new</span> <span class="hljs-attribute">Watcher</span>(<span class="hljs-attribute">vm</span>, <span class="hljs-attribute">node</span>, <span class="hljs-attribute">name</span>, '<span class="hljs-attribute">nodeValue</span>');
      }
    }
  },
}

<span class="hljs-attribute">----------------Watcher--------------------</span>
//<span class="hljs-attribute">7.</span>监听更新
<span class="hljs-attribute">function</span> <span class="hljs-attribute">Watcher</span>(<span class="hljs-attribute">vm</span>, <span class="hljs-attribute">node</span>, <span class="hljs-attribute">name</span>, <span class="hljs-attribute">type</span>) {
    <span class="hljs-attribute">Dep.target</span> = <span class="hljs-attribute">this</span>;
    <span class="hljs-attribute">this.name</span> = <span class="hljs-attribute">name</span>;
    <span class="hljs-attribute">this.node</span> = <span class="hljs-attribute">node</span>;
    <span class="hljs-attribute">this.vm</span> = <span class="hljs-attribute">vm</span>;
    <span class="hljs-attribute">this.type</span> = <span class="hljs-attribute">type</span>;
    <span class="hljs-attribute">this.update</span>();
    <span class="hljs-attribute">Dep.target</span> = <span class="hljs-attribute">null</span>;
}
<span class="hljs-attribute">Watcher.prototype</span> = {
    <span class="hljs-attribute">update:</span> <span class="hljs-attribute">function</span>() {
        <span class="hljs-attribute">this.get</span>();
        //<span class="hljs-attribute">9.</span>批量更新
        <span class="hljs-attribute">var</span> <span class="hljs-attribute">batcher</span> = <span class="hljs-attribute">new</span> <span class="hljs-attribute">Batcher</span>();
        <span class="hljs-attribute">batcher.push</span>(<span class="hljs-attribute">this</span>);
        // 订阅者执行相应操作
        // <span class="hljs-attribute">this.node</span>[<span class="hljs-attribute">this.type</span>] = <span class="hljs-attribute">this.value</span>;
        // <span class="hljs-attribute">this.cb</span>();
    },
    <span class="hljs-attribute">cb:function</span>(){
        // 订阅者执行相应操作
        <span class="hljs-attribute">this.node</span>[<span class="hljs-attribute">this.type</span>] = <span class="hljs-attribute">this.value</span>;
    },
    // 获取<span class="hljs-attribute">data</span>的属性值
    <span class="hljs-attribute">get:</span> <span class="hljs-attribute">function</span>() {
        //触发相应属性的<span class="hljs-attribute">get</span>
        <span class="hljs-attribute">this.value</span> = <span class="hljs-attribute">this.vm</span>[<span class="hljs-attribute">this.name</span>];
    }
}
</span></code></pre>
<ul>
<li>初始化：new vue -&gt;</li>
<li>observe.get- dep 存储一个监听数组</li>
<li>Compile-Watcher.update 更新数据</li>
<li>更新：observe -dep - watcher.update 更新数组</li>
</ul>
<h2 id="vue-生命周期">VUE 生命周期</h2>
<p><img src="img/vue/life.png" alt="流程图"></img>
<img src="img/vue/life2.png" alt="流程图"></img></p>
<h3 id="vue-30">VUE 3.0</h3>
<p>vm.data="2333" 无效
vm.$set(this.$data,) 要走监听麻烦
<img src="img/vue/del.png" alt="流程图"></img></p>
<p>VUE3.0 会去掉 DEP，Watcher，Observer 这一坨东西，为什么这么说呢，VUE3.0 将利用 ES6 的 proxy 代理和 Reflect 反射来实现双向绑定，监听，那么流程图就应该是这样了</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<p>Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect 对象的设计目的有这样几个。</p>
<ol>
<li>将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty），放到 Reflect 对象上。现阶段，某些方法同时在 Object 和 Reflect 对象上部署，未来的新方法将只部署在 Reflect 对象上。</li>
<li>修改某些 Object 方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而 Reflect.defineProperty(obj, name, desc)则会返回 false。</li>
</ol>
<h3 id="virtual-dom">Virtual DOM</h3>
<p>JavaScript 对象表示的树结构来构建一个真正的 DOM 。当状态变更时，重新渲染这个 JavaScript 的对象结构，实现视图的变更，结构根据变更的地方重新渲染。</p>
<p>DOM 很慢，为啥说它慢，先看一下 Webkit 引擎，所有浏览器都遵循类似的工作流，只是在细节处理有些不同。一旦浏览器接收到一个 HTML 文件，渲染引擎 Render Engine 就开始解析它，根据 HTML 元素 Elements 对应地生成 DOM 节点 Nodes，最终组成一棵 DOM 树。</p>
<p><img src="img/vue/dom.png" alt="流程图"></img></p>
<p>这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。</p>
<p>构造了渲染树以后，浏览器引擎开始着手布局 Layout。布局时，渲染树上的每个节点根据其在屏幕上应该出现的精确位置，分配一组屏幕坐标值。接着，浏览器将会通过遍历渲染树，调用每个节点的 Paint 方法来绘制这些 Render 对象。Paint 方法根据浏览器平台，使用不同的 UI 后端 API（Agnostic UI Backend API）通过绘制，最终将在屏幕上展示内容。只要在这过程中进行一次 DOM 更新，整个渲染流程都会重做一遍。</p>
<p><img src="img/vue/vdom.png" alt="流程图"></img></p>
<h3 id="virtual-dom-树的差异介绍（diff-算法）">Virtual DOM 树的差异介绍（Diff 算法）</h3>
<p>比较两个 DOM 树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。在前端当中，很少会跨越层级地移动 DOM 元素。所以 Virtual DOM 只会对同一个层级的元素进行对比，下面的 div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比。采用的是深度优先遍历，来记录差异，这样每个节点都会有一个唯一的标记。</p>
<p><img src="img/vue/diff.png" alt="流程图"></img></p>
<h5 id="节点的差异指的是什么呢？对-dom-操作可能会：">节点的差异指的是什么呢？对 DOM 操作可能会：</h5>
<ol>
<li>替换掉原来的节点，例如把上面的 div 换成了 section</li>
<li>移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换</li>
<li>修改了节点的属性</li>
<li>对于文本节点，文本内容可能会改变如修改上面的文本节点 2 内容为 Virtual DOM。</li>
</ol>
<h2 id="运行流程">运行流程</h2>
<p><img src="img/vue/liucheng.png" alt="流程图"></img></p>
<h2 id="单向数据流">单向数据流</h2>
<p><img src="img/vue/flow.png" alt="流程图"></img></p>
<ol>
<li>state，驱动应用的数据源；</li>
<li>view，以声明方式将 state 映射到视图；</li>
<li>actions，响应在 view 上的用户输入导致的状态变化。</li>
</ol>
<h5 id="但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：">但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：</h5>
<ol>
<li>多个视图依赖于同一状态。</li>
<li>来自不同视图的行为需要变更同一状态。</li>
</ol>
<h2 id="vuex">vuex</h2>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p>
<p><img src="img/vue/vuex.png" alt="流程图"></img></p>
<ol>
<li>State: 单一状态树用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照</li>
<li>Getters 有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数</li>
<li>Mutations 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。</li>
<li>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters</li>
<li>Modules Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</li>
</ol>
<!-- ## 项目结构

```base
├── index.html
├── main.js
├── api
│      └── ... # 抽取出API请求
├── components
│     ├── App.vue
│     └── ...
└── store
          ├── index.js          # 我们组装模块并导出 store 的地方
          ├── actions.js        # 根级别的 action
          ├── mutations.js      # 根级别的 mutation
          └── modules
                      ├── cart.js       # 购物车模块
                      └── products.js   # 产品模块
```
 -->

                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                <a href="react.html" class="navigation navigation-prev " aria-label="Previous page: React">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="webpack.html" class="navigation navigation-next " aria-label="Next page: Webpack">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Vue","level":"1.1.14","depth":2,"next":{"title":"Webpack","level":"1.1.15","depth":2,"path":"webpack.md","ref":"webpack.md","articles":[]},"previous":{"title":"React","level":"1.1.13","depth":2,"path":"react.md","ref":"react.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-search","-livereload","-lunr","-fontsettings","highlight","expandable-chapters-small","back-to-top-button","github","code","theme-default"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{"lang":{"eval_rst":"rst","toc":"text"}},"github":{"url":"https://github.com/KittenCN"},"expandable-chapters-small":{},"back-to-top-button":{},"code":{"copyButtons":true},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"Todd Lyu","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"CoderFAN 资料库","gitbook":"*"},"file":{"path":"vue.md","mtime":"2025-05-03T00:37:28.029Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-05T05:23:37.255Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-code/plugin.js"></script>
        
    

    </body>
</html>

